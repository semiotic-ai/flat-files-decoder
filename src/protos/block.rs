// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `block.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.Block)
pub struct Block {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.hash)
    pub hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.number)
    pub number: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.size)
    pub size: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.header)
    pub header: ::protobuf::MessageField<BlockHeader>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.uncles)
    pub uncles: ::std::vec::Vec<BlockHeader>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.transaction_traces)
    pub transaction_traces: ::std::vec::Vec<TransactionTrace>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.balance_changes)
    pub balance_changes: ::std::vec::Vec<BalanceChange>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.code_changes)
    pub code_changes: ::std::vec::Vec<CodeChange>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.ver)
    pub ver: i32,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.Block.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &Block| { &m.hash },
            |m: &mut Block| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "number",
            |m: &Block| { &m.number },
            |m: &mut Block| { &mut m.number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "size",
            |m: &Block| { &m.size },
            |m: &mut Block| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockHeader>(
            "header",
            |m: &Block| { &m.header },
            |m: &mut Block| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uncles",
            |m: &Block| { &m.uncles },
            |m: &mut Block| { &mut m.uncles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "transaction_traces",
            |m: &Block| { &m.transaction_traces },
            |m: &mut Block| { &mut m.transaction_traces },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "balance_changes",
            |m: &Block| { &m.balance_changes },
            |m: &mut Block| { &mut m.balance_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "code_changes",
            |m: &Block| { &m.code_changes },
            |m: &mut Block| { &mut m.code_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ver",
            |m: &Block| { &m.ver },
            |m: &mut Block| { &mut m.ver },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Block>(
            "Block",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Block {
    const NAME: &'static str = "Block";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.hash = is.read_bytes()?;
                },
                24 => {
                    self.number = is.read_uint64()?;
                },
                32 => {
                    self.size = is.read_uint64()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                50 => {
                    self.uncles.push(is.read_message()?);
                },
                82 => {
                    self.transaction_traces.push(is.read_message()?);
                },
                90 => {
                    self.balance_changes.push(is.read_message()?);
                },
                162 => {
                    self.code_changes.push(is.read_message()?);
                },
                8 => {
                    self.ver = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        if self.number != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.number);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.size);
        }
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.uncles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.transaction_traces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.balance_changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.code_changes {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.ver != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ver);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        if self.number != 0 {
            os.write_uint64(3, self.number)?;
        }
        if self.size != 0 {
            os.write_uint64(4, self.size)?;
        }
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.uncles {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.transaction_traces {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.balance_changes {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.code_changes {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        if self.ver != 0 {
            os.write_int32(1, self.ver)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Block {
        Block::new()
    }

    fn clear(&mut self) {
        self.hash.clear();
        self.number = 0;
        self.size = 0;
        self.header.clear();
        self.uncles.clear();
        self.transaction_traces.clear();
        self.balance_changes.clear();
        self.code_changes.clear();
        self.ver = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Block {
        static instance: Block = Block {
            hash: ::std::vec::Vec::new(),
            number: 0,
            size: 0,
            header: ::protobuf::MessageField::none(),
            uncles: ::std::vec::Vec::new(),
            transaction_traces: ::std::vec::Vec::new(),
            balance_changes: ::std::vec::Vec::new(),
            code_changes: ::std::vec::Vec::new(),
            ver: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Block {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Block").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.BlockHeader)
pub struct BlockHeader {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.parent_hash)
    pub parent_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.uncle_hash)
    pub uncle_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.coinbase)
    pub coinbase: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.state_root)
    pub state_root: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.transactions_root)
    pub transactions_root: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.receipt_root)
    pub receipt_root: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.logs_bloom)
    pub logs_bloom: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.difficulty)
    pub difficulty: ::protobuf::MessageField<BigInt>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.total_difficulty)
    pub total_difficulty: ::protobuf::MessageField<BigInt>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.number)
    pub number: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.gas_limit)
    pub gas_limit: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.gas_used)
    pub gas_used: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.timestamp)
    pub timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.extra_data)
    pub extra_data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.mix_hash)
    pub mix_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.nonce)
    pub nonce: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.hash)
    pub hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.base_fee_per_gas)
    pub base_fee_per_gas: ::protobuf::MessageField<BigInt>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.withdrawals_root)
    pub withdrawals_root: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.tx_dependency)
    pub tx_dependency: ::protobuf::MessageField<Uint64NestedArray>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.BlockHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockHeader {
    fn default() -> &'a BlockHeader {
        <BlockHeader as ::protobuf::Message>::default_instance()
    }
}

impl BlockHeader {
    pub fn new() -> BlockHeader {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parent_hash",
            |m: &BlockHeader| { &m.parent_hash },
            |m: &mut BlockHeader| { &mut m.parent_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uncle_hash",
            |m: &BlockHeader| { &m.uncle_hash },
            |m: &mut BlockHeader| { &mut m.uncle_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "coinbase",
            |m: &BlockHeader| { &m.coinbase },
            |m: &mut BlockHeader| { &mut m.coinbase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_root",
            |m: &BlockHeader| { &m.state_root },
            |m: &mut BlockHeader| { &mut m.state_root },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transactions_root",
            |m: &BlockHeader| { &m.transactions_root },
            |m: &mut BlockHeader| { &mut m.transactions_root },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "receipt_root",
            |m: &BlockHeader| { &m.receipt_root },
            |m: &mut BlockHeader| { &mut m.receipt_root },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "logs_bloom",
            |m: &BlockHeader| { &m.logs_bloom },
            |m: &mut BlockHeader| { &mut m.logs_bloom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "difficulty",
            |m: &BlockHeader| { &m.difficulty },
            |m: &mut BlockHeader| { &mut m.difficulty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "total_difficulty",
            |m: &BlockHeader| { &m.total_difficulty },
            |m: &mut BlockHeader| { &mut m.total_difficulty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "number",
            |m: &BlockHeader| { &m.number },
            |m: &mut BlockHeader| { &mut m.number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_limit",
            |m: &BlockHeader| { &m.gas_limit },
            |m: &mut BlockHeader| { &mut m.gas_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_used",
            |m: &BlockHeader| { &m.gas_used },
            |m: &mut BlockHeader| { &mut m.gas_used },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "timestamp",
            |m: &BlockHeader| { &m.timestamp },
            |m: &mut BlockHeader| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "extra_data",
            |m: &BlockHeader| { &m.extra_data },
            |m: &mut BlockHeader| { &mut m.extra_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mix_hash",
            |m: &BlockHeader| { &m.mix_hash },
            |m: &mut BlockHeader| { &mut m.mix_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nonce",
            |m: &BlockHeader| { &m.nonce },
            |m: &mut BlockHeader| { &mut m.nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &BlockHeader| { &m.hash },
            |m: &mut BlockHeader| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "base_fee_per_gas",
            |m: &BlockHeader| { &m.base_fee_per_gas },
            |m: &mut BlockHeader| { &mut m.base_fee_per_gas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "withdrawals_root",
            |m: &BlockHeader| { &m.withdrawals_root },
            |m: &mut BlockHeader| { &mut m.withdrawals_root },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Uint64NestedArray>(
            "tx_dependency",
            |m: &BlockHeader| { &m.tx_dependency },
            |m: &mut BlockHeader| { &mut m.tx_dependency },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockHeader>(
            "BlockHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockHeader {
    const NAME: &'static str = "BlockHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.parent_hash = is.read_bytes()?;
                },
                18 => {
                    self.uncle_hash = is.read_bytes()?;
                },
                26 => {
                    self.coinbase = is.read_bytes()?;
                },
                34 => {
                    self.state_root = is.read_bytes()?;
                },
                42 => {
                    self.transactions_root = is.read_bytes()?;
                },
                50 => {
                    self.receipt_root = is.read_bytes()?;
                },
                58 => {
                    self.logs_bloom = is.read_bytes()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.difficulty)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.total_difficulty)?;
                },
                72 => {
                    self.number = is.read_uint64()?;
                },
                80 => {
                    self.gas_limit = is.read_uint64()?;
                },
                88 => {
                    self.gas_used = is.read_uint64()?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestamp)?;
                },
                106 => {
                    self.extra_data = is.read_bytes()?;
                },
                114 => {
                    self.mix_hash = is.read_bytes()?;
                },
                120 => {
                    self.nonce = is.read_uint64()?;
                },
                130 => {
                    self.hash = is.read_bytes()?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base_fee_per_gas)?;
                },
                154 => {
                    self.withdrawals_root = is.read_bytes()?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tx_dependency)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.parent_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.parent_hash);
        }
        if !self.uncle_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.uncle_hash);
        }
        if !self.coinbase.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.coinbase);
        }
        if !self.state_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.state_root);
        }
        if !self.transactions_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.transactions_root);
        }
        if !self.receipt_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.receipt_root);
        }
        if !self.logs_bloom.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.logs_bloom);
        }
        if let Some(v) = self.difficulty.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.total_difficulty.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.number != 0 {
            my_size += ::protobuf::rt::uint64_size(9, self.number);
        }
        if self.gas_limit != 0 {
            my_size += ::protobuf::rt::uint64_size(10, self.gas_limit);
        }
        if self.gas_used != 0 {
            my_size += ::protobuf::rt::uint64_size(11, self.gas_used);
        }
        if let Some(v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.extra_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.extra_data);
        }
        if !self.mix_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(14, &self.mix_hash);
        }
        if self.nonce != 0 {
            my_size += ::protobuf::rt::uint64_size(15, self.nonce);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(16, &self.hash);
        }
        if let Some(v) = self.base_fee_per_gas.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.withdrawals_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(19, &self.withdrawals_root);
        }
        if let Some(v) = self.tx_dependency.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.parent_hash.is_empty() {
            os.write_bytes(1, &self.parent_hash)?;
        }
        if !self.uncle_hash.is_empty() {
            os.write_bytes(2, &self.uncle_hash)?;
        }
        if !self.coinbase.is_empty() {
            os.write_bytes(3, &self.coinbase)?;
        }
        if !self.state_root.is_empty() {
            os.write_bytes(4, &self.state_root)?;
        }
        if !self.transactions_root.is_empty() {
            os.write_bytes(5, &self.transactions_root)?;
        }
        if !self.receipt_root.is_empty() {
            os.write_bytes(6, &self.receipt_root)?;
        }
        if !self.logs_bloom.is_empty() {
            os.write_bytes(7, &self.logs_bloom)?;
        }
        if let Some(v) = self.difficulty.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.total_difficulty.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if self.number != 0 {
            os.write_uint64(9, self.number)?;
        }
        if self.gas_limit != 0 {
            os.write_uint64(10, self.gas_limit)?;
        }
        if self.gas_used != 0 {
            os.write_uint64(11, self.gas_used)?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if !self.extra_data.is_empty() {
            os.write_bytes(13, &self.extra_data)?;
        }
        if !self.mix_hash.is_empty() {
            os.write_bytes(14, &self.mix_hash)?;
        }
        if self.nonce != 0 {
            os.write_uint64(15, self.nonce)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(16, &self.hash)?;
        }
        if let Some(v) = self.base_fee_per_gas.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if !self.withdrawals_root.is_empty() {
            os.write_bytes(19, &self.withdrawals_root)?;
        }
        if let Some(v) = self.tx_dependency.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockHeader {
        BlockHeader::new()
    }

    fn clear(&mut self) {
        self.parent_hash.clear();
        self.uncle_hash.clear();
        self.coinbase.clear();
        self.state_root.clear();
        self.transactions_root.clear();
        self.receipt_root.clear();
        self.logs_bloom.clear();
        self.difficulty.clear();
        self.total_difficulty.clear();
        self.number = 0;
        self.gas_limit = 0;
        self.gas_used = 0;
        self.timestamp.clear();
        self.extra_data.clear();
        self.mix_hash.clear();
        self.nonce = 0;
        self.hash.clear();
        self.base_fee_per_gas.clear();
        self.withdrawals_root.clear();
        self.tx_dependency.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockHeader {
        static instance: BlockHeader = BlockHeader {
            parent_hash: ::std::vec::Vec::new(),
            uncle_hash: ::std::vec::Vec::new(),
            coinbase: ::std::vec::Vec::new(),
            state_root: ::std::vec::Vec::new(),
            transactions_root: ::std::vec::Vec::new(),
            receipt_root: ::std::vec::Vec::new(),
            logs_bloom: ::std::vec::Vec::new(),
            difficulty: ::protobuf::MessageField::none(),
            total_difficulty: ::protobuf::MessageField::none(),
            number: 0,
            gas_limit: 0,
            gas_used: 0,
            timestamp: ::protobuf::MessageField::none(),
            extra_data: ::std::vec::Vec::new(),
            mix_hash: ::std::vec::Vec::new(),
            nonce: 0,
            hash: ::std::vec::Vec::new(),
            base_fee_per_gas: ::protobuf::MessageField::none(),
            withdrawals_root: ::std::vec::Vec::new(),
            tx_dependency: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.Uint64NestedArray)
pub struct Uint64NestedArray {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Uint64NestedArray.val)
    pub val: ::std::vec::Vec<Uint64Array>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.Uint64NestedArray.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Uint64NestedArray {
    fn default() -> &'a Uint64NestedArray {
        <Uint64NestedArray as ::protobuf::Message>::default_instance()
    }
}

impl Uint64NestedArray {
    pub fn new() -> Uint64NestedArray {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "val",
            |m: &Uint64NestedArray| { &m.val },
            |m: &mut Uint64NestedArray| { &mut m.val },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Uint64NestedArray>(
            "Uint64NestedArray",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Uint64NestedArray {
    const NAME: &'static str = "Uint64NestedArray";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.val.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.val {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.val {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Uint64NestedArray {
        Uint64NestedArray::new()
    }

    fn clear(&mut self) {
        self.val.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Uint64NestedArray {
        static instance: Uint64NestedArray = Uint64NestedArray {
            val: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Uint64NestedArray {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Uint64NestedArray").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Uint64NestedArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Uint64NestedArray {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.Uint64Array)
pub struct Uint64Array {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Uint64Array.val)
    pub val: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.Uint64Array.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Uint64Array {
    fn default() -> &'a Uint64Array {
        <Uint64Array as ::protobuf::Message>::default_instance()
    }
}

impl Uint64Array {
    pub fn new() -> Uint64Array {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "val",
            |m: &Uint64Array| { &m.val },
            |m: &mut Uint64Array| { &mut m.val },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Uint64Array>(
            "Uint64Array",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Uint64Array {
    const NAME: &'static str = "Uint64Array";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.val)?;
                },
                8 => {
                    self.val.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.val {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.val {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Uint64Array {
        Uint64Array::new()
    }

    fn clear(&mut self) {
        self.val.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Uint64Array {
        static instance: Uint64Array = Uint64Array {
            val: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Uint64Array {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Uint64Array").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Uint64Array {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Uint64Array {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.BigInt)
pub struct BigInt {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BigInt.bytes)
    pub bytes: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.BigInt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BigInt {
    fn default() -> &'a BigInt {
        <BigInt as ::protobuf::Message>::default_instance()
    }
}

impl BigInt {
    pub fn new() -> BigInt {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bytes",
            |m: &BigInt| { &m.bytes },
            |m: &mut BigInt| { &mut m.bytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BigInt>(
            "BigInt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BigInt {
    const NAME: &'static str = "BigInt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bytes = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.bytes.is_empty() {
            os.write_bytes(1, &self.bytes)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BigInt {
        BigInt::new()
    }

    fn clear(&mut self) {
        self.bytes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BigInt {
        static instance: BigInt = BigInt {
            bytes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BigInt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BigInt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BigInt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BigInt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.TransactionTrace)
pub struct TransactionTrace {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.to)
    pub to: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.nonce)
    pub nonce: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.gas_price)
    pub gas_price: ::protobuf::MessageField<BigInt>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.gas_limit)
    pub gas_limit: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.value)
    pub value: ::protobuf::MessageField<BigInt>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.input)
    pub input: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.v)
    pub v: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.r)
    pub r: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.s)
    pub s: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.gas_used)
    pub gas_used: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.type)
    pub type_: ::protobuf::EnumOrUnknown<transaction_trace::Type>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.access_list)
    pub access_list: ::std::vec::Vec<AccessTuple>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.max_fee_per_gas)
    pub max_fee_per_gas: ::protobuf::MessageField<BigInt>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.max_priority_fee_per_gas)
    pub max_priority_fee_per_gas: ::protobuf::MessageField<BigInt>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.index)
    pub index: u32,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.hash)
    pub hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.from)
    pub from: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.return_data)
    pub return_data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.public_key)
    pub public_key: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.begin_ordinal)
    pub begin_ordinal: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.end_ordinal)
    pub end_ordinal: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.status)
    pub status: ::protobuf::EnumOrUnknown<TransactionTraceStatus>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.receipt)
    pub receipt: ::protobuf::MessageField<TransactionReceipt>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.TransactionTrace.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionTrace {
    fn default() -> &'a TransactionTrace {
        <TransactionTrace as ::protobuf::Message>::default_instance()
    }
}

impl TransactionTrace {
    pub fn new() -> TransactionTrace {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(23);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "to",
            |m: &TransactionTrace| { &m.to },
            |m: &mut TransactionTrace| { &mut m.to },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nonce",
            |m: &TransactionTrace| { &m.nonce },
            |m: &mut TransactionTrace| { &mut m.nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "gas_price",
            |m: &TransactionTrace| { &m.gas_price },
            |m: &mut TransactionTrace| { &mut m.gas_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_limit",
            |m: &TransactionTrace| { &m.gas_limit },
            |m: &mut TransactionTrace| { &mut m.gas_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "value",
            |m: &TransactionTrace| { &m.value },
            |m: &mut TransactionTrace| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input",
            |m: &TransactionTrace| { &m.input },
            |m: &mut TransactionTrace| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "v",
            |m: &TransactionTrace| { &m.v },
            |m: &mut TransactionTrace| { &mut m.v },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "r",
            |m: &TransactionTrace| { &m.r },
            |m: &mut TransactionTrace| { &mut m.r },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "s",
            |m: &TransactionTrace| { &m.s },
            |m: &mut TransactionTrace| { &mut m.s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_used",
            |m: &TransactionTrace| { &m.gas_used },
            |m: &mut TransactionTrace| { &mut m.gas_used },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &TransactionTrace| { &m.type_ },
            |m: &mut TransactionTrace| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "access_list",
            |m: &TransactionTrace| { &m.access_list },
            |m: &mut TransactionTrace| { &mut m.access_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "max_fee_per_gas",
            |m: &TransactionTrace| { &m.max_fee_per_gas },
            |m: &mut TransactionTrace| { &mut m.max_fee_per_gas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "max_priority_fee_per_gas",
            |m: &TransactionTrace| { &m.max_priority_fee_per_gas },
            |m: &mut TransactionTrace| { &mut m.max_priority_fee_per_gas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &TransactionTrace| { &m.index },
            |m: &mut TransactionTrace| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &TransactionTrace| { &m.hash },
            |m: &mut TransactionTrace| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "from",
            |m: &TransactionTrace| { &m.from },
            |m: &mut TransactionTrace| { &mut m.from },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "return_data",
            |m: &TransactionTrace| { &m.return_data },
            |m: &mut TransactionTrace| { &mut m.return_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "public_key",
            |m: &TransactionTrace| { &m.public_key },
            |m: &mut TransactionTrace| { &mut m.public_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "begin_ordinal",
            |m: &TransactionTrace| { &m.begin_ordinal },
            |m: &mut TransactionTrace| { &mut m.begin_ordinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end_ordinal",
            |m: &TransactionTrace| { &m.end_ordinal },
            |m: &mut TransactionTrace| { &mut m.end_ordinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &TransactionTrace| { &m.status },
            |m: &mut TransactionTrace| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TransactionReceipt>(
            "receipt",
            |m: &TransactionTrace| { &m.receipt },
            |m: &mut TransactionTrace| { &mut m.receipt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionTrace>(
            "TransactionTrace",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionTrace {
    const NAME: &'static str = "TransactionTrace";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.to = is.read_bytes()?;
                },
                16 => {
                    self.nonce = is.read_uint64()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.gas_price)?;
                },
                32 => {
                    self.gas_limit = is.read_uint64()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                50 => {
                    self.input = is.read_bytes()?;
                },
                58 => {
                    self.v = is.read_bytes()?;
                },
                66 => {
                    self.r = is.read_bytes()?;
                },
                74 => {
                    self.s = is.read_bytes()?;
                },
                80 => {
                    self.gas_used = is.read_uint64()?;
                },
                96 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                114 => {
                    self.access_list.push(is.read_message()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.max_fee_per_gas)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.max_priority_fee_per_gas)?;
                },
                160 => {
                    self.index = is.read_uint32()?;
                },
                170 => {
                    self.hash = is.read_bytes()?;
                },
                178 => {
                    self.from = is.read_bytes()?;
                },
                186 => {
                    self.return_data = is.read_bytes()?;
                },
                194 => {
                    self.public_key = is.read_bytes()?;
                },
                200 => {
                    self.begin_ordinal = is.read_uint64()?;
                },
                208 => {
                    self.end_ordinal = is.read_uint64()?;
                },
                240 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                250 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.receipt)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.to);
        }
        if self.nonce != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.nonce);
        }
        if let Some(v) = self.gas_price.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.gas_limit != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.gas_limit);
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.input.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.input);
        }
        if !self.v.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.v);
        }
        if !self.r.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.r);
        }
        if !self.s.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.s);
        }
        if self.gas_used != 0 {
            my_size += ::protobuf::rt::uint64_size(10, self.gas_used);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(transaction_trace::Type::TRX_TYPE_LEGACY) {
            my_size += ::protobuf::rt::int32_size(12, self.type_.value());
        }
        for value in &self.access_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.max_fee_per_gas.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.max_priority_fee_per_gas.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::uint32_size(20, self.index);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(21, &self.hash);
        }
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(22, &self.from);
        }
        if !self.return_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(23, &self.return_data);
        }
        if !self.public_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(24, &self.public_key);
        }
        if self.begin_ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(25, self.begin_ordinal);
        }
        if self.end_ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(26, self.end_ordinal);
        }
        if self.status != ::protobuf::EnumOrUnknown::new(TransactionTraceStatus::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(30, self.status.value());
        }
        if let Some(v) = self.receipt.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.to.is_empty() {
            os.write_bytes(1, &self.to)?;
        }
        if self.nonce != 0 {
            os.write_uint64(2, self.nonce)?;
        }
        if let Some(v) = self.gas_price.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.gas_limit != 0 {
            os.write_uint64(4, self.gas_limit)?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if !self.input.is_empty() {
            os.write_bytes(6, &self.input)?;
        }
        if !self.v.is_empty() {
            os.write_bytes(7, &self.v)?;
        }
        if !self.r.is_empty() {
            os.write_bytes(8, &self.r)?;
        }
        if !self.s.is_empty() {
            os.write_bytes(9, &self.s)?;
        }
        if self.gas_used != 0 {
            os.write_uint64(10, self.gas_used)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(transaction_trace::Type::TRX_TYPE_LEGACY) {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        for v in &self.access_list {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        if let Some(v) = self.max_fee_per_gas.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.max_priority_fee_per_gas.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if self.index != 0 {
            os.write_uint32(20, self.index)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(21, &self.hash)?;
        }
        if !self.from.is_empty() {
            os.write_bytes(22, &self.from)?;
        }
        if !self.return_data.is_empty() {
            os.write_bytes(23, &self.return_data)?;
        }
        if !self.public_key.is_empty() {
            os.write_bytes(24, &self.public_key)?;
        }
        if self.begin_ordinal != 0 {
            os.write_uint64(25, self.begin_ordinal)?;
        }
        if self.end_ordinal != 0 {
            os.write_uint64(26, self.end_ordinal)?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(TransactionTraceStatus::UNKNOWN) {
            os.write_enum(30, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if let Some(v) = self.receipt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionTrace {
        TransactionTrace::new()
    }

    fn clear(&mut self) {
        self.to.clear();
        self.nonce = 0;
        self.gas_price.clear();
        self.gas_limit = 0;
        self.value.clear();
        self.input.clear();
        self.v.clear();
        self.r.clear();
        self.s.clear();
        self.gas_used = 0;
        self.type_ = ::protobuf::EnumOrUnknown::new(transaction_trace::Type::TRX_TYPE_LEGACY);
        self.access_list.clear();
        self.max_fee_per_gas.clear();
        self.max_priority_fee_per_gas.clear();
        self.index = 0;
        self.hash.clear();
        self.from.clear();
        self.return_data.clear();
        self.public_key.clear();
        self.begin_ordinal = 0;
        self.end_ordinal = 0;
        self.status = ::protobuf::EnumOrUnknown::new(TransactionTraceStatus::UNKNOWN);
        self.receipt.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionTrace {
        static instance: TransactionTrace = TransactionTrace {
            to: ::std::vec::Vec::new(),
            nonce: 0,
            gas_price: ::protobuf::MessageField::none(),
            gas_limit: 0,
            value: ::protobuf::MessageField::none(),
            input: ::std::vec::Vec::new(),
            v: ::std::vec::Vec::new(),
            r: ::std::vec::Vec::new(),
            s: ::std::vec::Vec::new(),
            gas_used: 0,
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            access_list: ::std::vec::Vec::new(),
            max_fee_per_gas: ::protobuf::MessageField::none(),
            max_priority_fee_per_gas: ::protobuf::MessageField::none(),
            index: 0,
            hash: ::std::vec::Vec::new(),
            from: ::std::vec::Vec::new(),
            return_data: ::std::vec::Vec::new(),
            public_key: ::std::vec::Vec::new(),
            begin_ordinal: 0,
            end_ordinal: 0,
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            receipt: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionTrace {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionTrace").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionTrace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionTrace {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TransactionTrace`
pub mod transaction_trace {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:sf.ethereum.type.v2.TransactionTrace.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.TransactionTrace.Type.TRX_TYPE_LEGACY)
        TRX_TYPE_LEGACY = 0,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.TransactionTrace.Type.TRX_TYPE_ACCESS_LIST)
        TRX_TYPE_ACCESS_LIST = 1,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.TransactionTrace.Type.TRX_TYPE_DYNAMIC_FEE)
        TRX_TYPE_DYNAMIC_FEE = 2,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::TRX_TYPE_LEGACY),
                1 => ::std::option::Option::Some(Type::TRX_TYPE_ACCESS_LIST),
                2 => ::std::option::Option::Some(Type::TRX_TYPE_DYNAMIC_FEE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::TRX_TYPE_LEGACY,
            Type::TRX_TYPE_ACCESS_LIST,
            Type::TRX_TYPE_DYNAMIC_FEE,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TransactionTrace.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::TRX_TYPE_LEGACY
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("TransactionTrace.Type")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.AccessTuple)
pub struct AccessTuple {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.AccessTuple.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.AccessTuple.storage_keys)
    pub storage_keys: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.AccessTuple.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccessTuple {
    fn default() -> &'a AccessTuple {
        <AccessTuple as ::protobuf::Message>::default_instance()
    }
}

impl AccessTuple {
    pub fn new() -> AccessTuple {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &AccessTuple| { &m.address },
            |m: &mut AccessTuple| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "storage_keys",
            |m: &AccessTuple| { &m.storage_keys },
            |m: &mut AccessTuple| { &mut m.storage_keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccessTuple>(
            "AccessTuple",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccessTuple {
    const NAME: &'static str = "AccessTuple";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                18 => {
                    self.storage_keys.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        for value in &self.storage_keys {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        for v in &self.storage_keys {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccessTuple {
        AccessTuple::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.storage_keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccessTuple {
        static instance: AccessTuple = AccessTuple {
            address: ::std::vec::Vec::new(),
            storage_keys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccessTuple {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccessTuple").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccessTuple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccessTuple {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.TransactionReceipt)
pub struct TransactionReceipt {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionReceipt.state_root)
    pub state_root: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionReceipt.cumulative_gas_used)
    pub cumulative_gas_used: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionReceipt.logs_bloom)
    pub logs_bloom: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionReceipt.logs)
    pub logs: ::std::vec::Vec<Log>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.TransactionReceipt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionReceipt {
    fn default() -> &'a TransactionReceipt {
        <TransactionReceipt as ::protobuf::Message>::default_instance()
    }
}

impl TransactionReceipt {
    pub fn new() -> TransactionReceipt {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_root",
            |m: &TransactionReceipt| { &m.state_root },
            |m: &mut TransactionReceipt| { &mut m.state_root },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cumulative_gas_used",
            |m: &TransactionReceipt| { &m.cumulative_gas_used },
            |m: &mut TransactionReceipt| { &mut m.cumulative_gas_used },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "logs_bloom",
            |m: &TransactionReceipt| { &m.logs_bloom },
            |m: &mut TransactionReceipt| { &mut m.logs_bloom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "logs",
            |m: &TransactionReceipt| { &m.logs },
            |m: &mut TransactionReceipt| { &mut m.logs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionReceipt>(
            "TransactionReceipt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionReceipt {
    const NAME: &'static str = "TransactionReceipt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.state_root = is.read_bytes()?;
                },
                16 => {
                    self.cumulative_gas_used = is.read_uint64()?;
                },
                26 => {
                    self.logs_bloom = is.read_bytes()?;
                },
                34 => {
                    self.logs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.state_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.state_root);
        }
        if self.cumulative_gas_used != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.cumulative_gas_used);
        }
        if !self.logs_bloom.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.logs_bloom);
        }
        for value in &self.logs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.state_root.is_empty() {
            os.write_bytes(1, &self.state_root)?;
        }
        if self.cumulative_gas_used != 0 {
            os.write_uint64(2, self.cumulative_gas_used)?;
        }
        if !self.logs_bloom.is_empty() {
            os.write_bytes(3, &self.logs_bloom)?;
        }
        for v in &self.logs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionReceipt {
        TransactionReceipt::new()
    }

    fn clear(&mut self) {
        self.state_root.clear();
        self.cumulative_gas_used = 0;
        self.logs_bloom.clear();
        self.logs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionReceipt {
        static instance: TransactionReceipt = TransactionReceipt {
            state_root: ::std::vec::Vec::new(),
            cumulative_gas_used: 0,
            logs_bloom: ::std::vec::Vec::new(),
            logs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionReceipt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionReceipt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionReceipt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionReceipt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.Log)
pub struct Log {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Log.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Log.topics)
    pub topics: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Log.data)
    pub data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Log.index)
    pub index: u32,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Log.blockIndex)
    pub blockIndex: u32,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Log.ordinal)
    pub ordinal: u64,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.Log.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Log {
    fn default() -> &'a Log {
        <Log as ::protobuf::Message>::default_instance()
    }
}

impl Log {
    pub fn new() -> Log {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &Log| { &m.address },
            |m: &mut Log| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "topics",
            |m: &Log| { &m.topics },
            |m: &mut Log| { &mut m.topics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &Log| { &m.data },
            |m: &mut Log| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &Log| { &m.index },
            |m: &mut Log| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "blockIndex",
            |m: &Log| { &m.blockIndex },
            |m: &mut Log| { &mut m.blockIndex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ordinal",
            |m: &Log| { &m.ordinal },
            |m: &mut Log| { &mut m.ordinal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Log>(
            "Log",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Log {
    const NAME: &'static str = "Log";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                18 => {
                    self.topics.push(is.read_bytes()?);
                },
                26 => {
                    self.data = is.read_bytes()?;
                },
                32 => {
                    self.index = is.read_uint32()?;
                },
                48 => {
                    self.blockIndex = is.read_uint32()?;
                },
                56 => {
                    self.ordinal = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        for value in &self.topics {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.index);
        }
        if self.blockIndex != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.blockIndex);
        }
        if self.ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(7, self.ordinal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        for v in &self.topics {
            os.write_bytes(2, &v)?;
        };
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        if self.index != 0 {
            os.write_uint32(4, self.index)?;
        }
        if self.blockIndex != 0 {
            os.write_uint32(6, self.blockIndex)?;
        }
        if self.ordinal != 0 {
            os.write_uint64(7, self.ordinal)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Log {
        Log::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.topics.clear();
        self.data.clear();
        self.index = 0;
        self.blockIndex = 0;
        self.ordinal = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Log {
        static instance: Log = Log {
            address: ::std::vec::Vec::new(),
            topics: ::std::vec::Vec::new(),
            data: ::std::vec::Vec::new(),
            index: 0,
            blockIndex: 0,
            ordinal: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Log {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Log").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Log {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Log {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.Call)
pub struct Call {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.index)
    pub index: u32,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.parent_index)
    pub parent_index: u32,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.depth)
    pub depth: u32,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.call_type)
    pub call_type: ::protobuf::EnumOrUnknown<CallType>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.caller)
    pub caller: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.value)
    pub value: ::protobuf::MessageField<BigInt>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.gas_limit)
    pub gas_limit: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.gas_consumed)
    pub gas_consumed: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.return_data)
    pub return_data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.input)
    pub input: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.executed_code)
    pub executed_code: bool,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.suicide)
    pub suicide: bool,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.keccak_preimages)
    pub keccak_preimages: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.storage_changes)
    pub storage_changes: ::std::vec::Vec<StorageChange>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.balance_changes)
    pub balance_changes: ::std::vec::Vec<BalanceChange>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.nonce_changes)
    pub nonce_changes: ::std::vec::Vec<NonceChange>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.logs)
    pub logs: ::std::vec::Vec<Log>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.code_changes)
    pub code_changes: ::std::vec::Vec<CodeChange>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.gas_changes)
    pub gas_changes: ::std::vec::Vec<GasChange>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.status_failed)
    pub status_failed: bool,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.status_reverted)
    pub status_reverted: bool,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.failure_reason)
    pub failure_reason: ::std::string::String,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.state_reverted)
    pub state_reverted: bool,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.begin_ordinal)
    pub begin_ordinal: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.end_ordinal)
    pub end_ordinal: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.account_creations)
    pub account_creations: ::std::vec::Vec<AccountCreation>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.Call.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Call {
    fn default() -> &'a Call {
        <Call as ::protobuf::Message>::default_instance()
    }
}

impl Call {
    pub fn new() -> Call {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(27);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &Call| { &m.index },
            |m: &mut Call| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parent_index",
            |m: &Call| { &m.parent_index },
            |m: &mut Call| { &mut m.parent_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "depth",
            |m: &Call| { &m.depth },
            |m: &mut Call| { &mut m.depth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "call_type",
            |m: &Call| { &m.call_type },
            |m: &mut Call| { &mut m.call_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "caller",
            |m: &Call| { &m.caller },
            |m: &mut Call| { &mut m.caller },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &Call| { &m.address },
            |m: &mut Call| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "value",
            |m: &Call| { &m.value },
            |m: &mut Call| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_limit",
            |m: &Call| { &m.gas_limit },
            |m: &mut Call| { &mut m.gas_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_consumed",
            |m: &Call| { &m.gas_consumed },
            |m: &mut Call| { &mut m.gas_consumed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "return_data",
            |m: &Call| { &m.return_data },
            |m: &mut Call| { &mut m.return_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input",
            |m: &Call| { &m.input },
            |m: &mut Call| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "executed_code",
            |m: &Call| { &m.executed_code },
            |m: &mut Call| { &mut m.executed_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "suicide",
            |m: &Call| { &m.suicide },
            |m: &mut Call| { &mut m.suicide },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "keccak_preimages",
            |m: &Call| { &m.keccak_preimages },
            |m: &mut Call| { &mut m.keccak_preimages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "storage_changes",
            |m: &Call| { &m.storage_changes },
            |m: &mut Call| { &mut m.storage_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "balance_changes",
            |m: &Call| { &m.balance_changes },
            |m: &mut Call| { &mut m.balance_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nonce_changes",
            |m: &Call| { &m.nonce_changes },
            |m: &mut Call| { &mut m.nonce_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "logs",
            |m: &Call| { &m.logs },
            |m: &mut Call| { &mut m.logs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "code_changes",
            |m: &Call| { &m.code_changes },
            |m: &mut Call| { &mut m.code_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gas_changes",
            |m: &Call| { &m.gas_changes },
            |m: &mut Call| { &mut m.gas_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status_failed",
            |m: &Call| { &m.status_failed },
            |m: &mut Call| { &mut m.status_failed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status_reverted",
            |m: &Call| { &m.status_reverted },
            |m: &mut Call| { &mut m.status_reverted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "failure_reason",
            |m: &Call| { &m.failure_reason },
            |m: &mut Call| { &mut m.failure_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_reverted",
            |m: &Call| { &m.state_reverted },
            |m: &mut Call| { &mut m.state_reverted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "begin_ordinal",
            |m: &Call| { &m.begin_ordinal },
            |m: &mut Call| { &mut m.begin_ordinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end_ordinal",
            |m: &Call| { &m.end_ordinal },
            |m: &mut Call| { &mut m.end_ordinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_creations",
            |m: &Call| { &m.account_creations },
            |m: &mut Call| { &mut m.account_creations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Call>(
            "Call",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Call {
    const NAME: &'static str = "Call";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = is.read_uint32()?;
                },
                16 => {
                    self.parent_index = is.read_uint32()?;
                },
                24 => {
                    self.depth = is.read_uint32()?;
                },
                32 => {
                    self.call_type = is.read_enum_or_unknown()?;
                },
                42 => {
                    self.caller = is.read_bytes()?;
                },
                50 => {
                    self.address = is.read_bytes()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                64 => {
                    self.gas_limit = is.read_uint64()?;
                },
                72 => {
                    self.gas_consumed = is.read_uint64()?;
                },
                106 => {
                    self.return_data = is.read_bytes()?;
                },
                114 => {
                    self.input = is.read_bytes()?;
                },
                120 => {
                    self.executed_code = is.read_bool()?;
                },
                128 => {
                    self.suicide = is.read_bool()?;
                },
                162 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.keccak_preimages.insert(key, value);
                },
                170 => {
                    self.storage_changes.push(is.read_message()?);
                },
                178 => {
                    self.balance_changes.push(is.read_message()?);
                },
                194 => {
                    self.nonce_changes.push(is.read_message()?);
                },
                202 => {
                    self.logs.push(is.read_message()?);
                },
                210 => {
                    self.code_changes.push(is.read_message()?);
                },
                226 => {
                    self.gas_changes.push(is.read_message()?);
                },
                80 => {
                    self.status_failed = is.read_bool()?;
                },
                96 => {
                    self.status_reverted = is.read_bool()?;
                },
                90 => {
                    self.failure_reason = is.read_string()?;
                },
                240 => {
                    self.state_reverted = is.read_bool()?;
                },
                248 => {
                    self.begin_ordinal = is.read_uint64()?;
                },
                256 => {
                    self.end_ordinal = is.read_uint64()?;
                },
                266 => {
                    self.account_creations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.index);
        }
        if self.parent_index != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.parent_index);
        }
        if self.depth != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.depth);
        }
        if self.call_type != ::protobuf::EnumOrUnknown::new(CallType::UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(4, self.call_type.value());
        }
        if !self.caller.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.caller);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.address);
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.gas_limit != 0 {
            my_size += ::protobuf::rt::uint64_size(8, self.gas_limit);
        }
        if self.gas_consumed != 0 {
            my_size += ::protobuf::rt::uint64_size(9, self.gas_consumed);
        }
        if !self.return_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.return_data);
        }
        if !self.input.is_empty() {
            my_size += ::protobuf::rt::bytes_size(14, &self.input);
        }
        if self.executed_code != false {
            my_size += 1 + 1;
        }
        if self.suicide != false {
            my_size += 2 + 1;
        }
        for (k, v) in &self.keccak_preimages {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.storage_changes {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.balance_changes {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.nonce_changes {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.logs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.code_changes {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.gas_changes {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.status_failed != false {
            my_size += 1 + 1;
        }
        if self.status_reverted != false {
            my_size += 1 + 1;
        }
        if !self.failure_reason.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.failure_reason);
        }
        if self.state_reverted != false {
            my_size += 2 + 1;
        }
        if self.begin_ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(31, self.begin_ordinal);
        }
        if self.end_ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(32, self.end_ordinal);
        }
        for value in &self.account_creations {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.index != 0 {
            os.write_uint32(1, self.index)?;
        }
        if self.parent_index != 0 {
            os.write_uint32(2, self.parent_index)?;
        }
        if self.depth != 0 {
            os.write_uint32(3, self.depth)?;
        }
        if self.call_type != ::protobuf::EnumOrUnknown::new(CallType::UNSPECIFIED) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.call_type))?;
        }
        if !self.caller.is_empty() {
            os.write_bytes(5, &self.caller)?;
        }
        if !self.address.is_empty() {
            os.write_bytes(6, &self.address)?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if self.gas_limit != 0 {
            os.write_uint64(8, self.gas_limit)?;
        }
        if self.gas_consumed != 0 {
            os.write_uint64(9, self.gas_consumed)?;
        }
        if !self.return_data.is_empty() {
            os.write_bytes(13, &self.return_data)?;
        }
        if !self.input.is_empty() {
            os.write_bytes(14, &self.input)?;
        }
        if self.executed_code != false {
            os.write_bool(15, self.executed_code)?;
        }
        if self.suicide != false {
            os.write_bool(16, self.suicide)?;
        }
        for (k, v) in &self.keccak_preimages {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(162)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for v in &self.storage_changes {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        };
        for v in &self.balance_changes {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        };
        for v in &self.nonce_changes {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        };
        for v in &self.logs {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        };
        for v in &self.code_changes {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        };
        for v in &self.gas_changes {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        };
        if self.status_failed != false {
            os.write_bool(10, self.status_failed)?;
        }
        if self.status_reverted != false {
            os.write_bool(12, self.status_reverted)?;
        }
        if !self.failure_reason.is_empty() {
            os.write_string(11, &self.failure_reason)?;
        }
        if self.state_reverted != false {
            os.write_bool(30, self.state_reverted)?;
        }
        if self.begin_ordinal != 0 {
            os.write_uint64(31, self.begin_ordinal)?;
        }
        if self.end_ordinal != 0 {
            os.write_uint64(32, self.end_ordinal)?;
        }
        for v in &self.account_creations {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Call {
        Call::new()
    }

    fn clear(&mut self) {
        self.index = 0;
        self.parent_index = 0;
        self.depth = 0;
        self.call_type = ::protobuf::EnumOrUnknown::new(CallType::UNSPECIFIED);
        self.caller.clear();
        self.address.clear();
        self.value.clear();
        self.gas_limit = 0;
        self.gas_consumed = 0;
        self.return_data.clear();
        self.input.clear();
        self.executed_code = false;
        self.suicide = false;
        self.keccak_preimages.clear();
        self.storage_changes.clear();
        self.balance_changes.clear();
        self.nonce_changes.clear();
        self.logs.clear();
        self.code_changes.clear();
        self.gas_changes.clear();
        self.status_failed = false;
        self.status_reverted = false;
        self.failure_reason.clear();
        self.state_reverted = false;
        self.begin_ordinal = 0;
        self.end_ordinal = 0;
        self.account_creations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Call {
        static instance: ::protobuf::rt::Lazy<Call> = ::protobuf::rt::Lazy::new();
        instance.get(Call::new)
    }
}

impl ::protobuf::MessageFull for Call {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Call").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Call {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Call {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.StorageChange)
pub struct StorageChange {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.StorageChange.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.StorageChange.key)
    pub key: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.StorageChange.old_value)
    pub old_value: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.StorageChange.new_value)
    pub new_value: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.StorageChange.ordinal)
    pub ordinal: u64,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.StorageChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StorageChange {
    fn default() -> &'a StorageChange {
        <StorageChange as ::protobuf::Message>::default_instance()
    }
}

impl StorageChange {
    pub fn new() -> StorageChange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &StorageChange| { &m.address },
            |m: &mut StorageChange| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &StorageChange| { &m.key },
            |m: &mut StorageChange| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "old_value",
            |m: &StorageChange| { &m.old_value },
            |m: &mut StorageChange| { &mut m.old_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_value",
            |m: &StorageChange| { &m.new_value },
            |m: &mut StorageChange| { &mut m.new_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ordinal",
            |m: &StorageChange| { &m.ordinal },
            |m: &mut StorageChange| { &mut m.ordinal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StorageChange>(
            "StorageChange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StorageChange {
    const NAME: &'static str = "StorageChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                18 => {
                    self.key = is.read_bytes()?;
                },
                26 => {
                    self.old_value = is.read_bytes()?;
                },
                34 => {
                    self.new_value = is.read_bytes()?;
                },
                40 => {
                    self.ordinal = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.key);
        }
        if !self.old_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.old_value);
        }
        if !self.new_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.new_value);
        }
        if self.ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.ordinal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(2, &self.key)?;
        }
        if !self.old_value.is_empty() {
            os.write_bytes(3, &self.old_value)?;
        }
        if !self.new_value.is_empty() {
            os.write_bytes(4, &self.new_value)?;
        }
        if self.ordinal != 0 {
            os.write_uint64(5, self.ordinal)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StorageChange {
        StorageChange::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.key.clear();
        self.old_value.clear();
        self.new_value.clear();
        self.ordinal = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StorageChange {
        static instance: StorageChange = StorageChange {
            address: ::std::vec::Vec::new(),
            key: ::std::vec::Vec::new(),
            old_value: ::std::vec::Vec::new(),
            new_value: ::std::vec::Vec::new(),
            ordinal: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StorageChange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StorageChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StorageChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageChange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.BalanceChange)
pub struct BalanceChange {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BalanceChange.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BalanceChange.old_value)
    pub old_value: ::protobuf::MessageField<BigInt>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BalanceChange.new_value)
    pub new_value: ::protobuf::MessageField<BigInt>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BalanceChange.reason)
    pub reason: ::protobuf::EnumOrUnknown<balance_change::Reason>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BalanceChange.ordinal)
    pub ordinal: u64,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.BalanceChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BalanceChange {
    fn default() -> &'a BalanceChange {
        <BalanceChange as ::protobuf::Message>::default_instance()
    }
}

impl BalanceChange {
    pub fn new() -> BalanceChange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BalanceChange| { &m.address },
            |m: &mut BalanceChange| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "old_value",
            |m: &BalanceChange| { &m.old_value },
            |m: &mut BalanceChange| { &mut m.old_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "new_value",
            |m: &BalanceChange| { &m.new_value },
            |m: &mut BalanceChange| { &mut m.new_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reason",
            |m: &BalanceChange| { &m.reason },
            |m: &mut BalanceChange| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ordinal",
            |m: &BalanceChange| { &m.ordinal },
            |m: &mut BalanceChange| { &mut m.ordinal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BalanceChange>(
            "BalanceChange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BalanceChange {
    const NAME: &'static str = "BalanceChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.old_value)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.new_value)?;
                },
                32 => {
                    self.reason = is.read_enum_or_unknown()?;
                },
                40 => {
                    self.ordinal = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if let Some(v) = self.old_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.new_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.reason != ::protobuf::EnumOrUnknown::new(balance_change::Reason::REASON_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(4, self.reason.value());
        }
        if self.ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.ordinal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if let Some(v) = self.old_value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.new_value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.reason != ::protobuf::EnumOrUnknown::new(balance_change::Reason::REASON_UNKNOWN) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.reason))?;
        }
        if self.ordinal != 0 {
            os.write_uint64(5, self.ordinal)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BalanceChange {
        BalanceChange::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.old_value.clear();
        self.new_value.clear();
        self.reason = ::protobuf::EnumOrUnknown::new(balance_change::Reason::REASON_UNKNOWN);
        self.ordinal = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BalanceChange {
        static instance: BalanceChange = BalanceChange {
            address: ::std::vec::Vec::new(),
            old_value: ::protobuf::MessageField::none(),
            new_value: ::protobuf::MessageField::none(),
            reason: ::protobuf::EnumOrUnknown::from_i32(0),
            ordinal: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BalanceChange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BalanceChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BalanceChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BalanceChange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BalanceChange`
pub mod balance_change {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:sf.ethereum.type.v2.BalanceChange.Reason)
    pub enum Reason {
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_UNKNOWN)
        REASON_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_REWARD_MINE_UNCLE)
        REASON_REWARD_MINE_UNCLE = 1,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_REWARD_MINE_BLOCK)
        REASON_REWARD_MINE_BLOCK = 2,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_DAO_REFUND_CONTRACT)
        REASON_DAO_REFUND_CONTRACT = 3,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_DAO_ADJUST_BALANCE)
        REASON_DAO_ADJUST_BALANCE = 4,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_TRANSFER)
        REASON_TRANSFER = 5,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_GENESIS_BALANCE)
        REASON_GENESIS_BALANCE = 6,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_GAS_BUY)
        REASON_GAS_BUY = 7,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_REWARD_TRANSACTION_FEE)
        REASON_REWARD_TRANSACTION_FEE = 8,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_REWARD_FEE_RESET)
        REASON_REWARD_FEE_RESET = 14,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_GAS_REFUND)
        REASON_GAS_REFUND = 9,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_TOUCH_ACCOUNT)
        REASON_TOUCH_ACCOUNT = 10,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_SUICIDE_REFUND)
        REASON_SUICIDE_REFUND = 11,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_SUICIDE_WITHDRAW)
        REASON_SUICIDE_WITHDRAW = 13,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_CALL_BALANCE_OVERRIDE)
        REASON_CALL_BALANCE_OVERRIDE = 12,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_BURN)
        REASON_BURN = 15,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_WITHDRAWAL)
        REASON_WITHDRAWAL = 16,
    }

    impl ::protobuf::Enum for Reason {
        const NAME: &'static str = "Reason";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Reason> {
            match value {
                0 => ::std::option::Option::Some(Reason::REASON_UNKNOWN),
                1 => ::std::option::Option::Some(Reason::REASON_REWARD_MINE_UNCLE),
                2 => ::std::option::Option::Some(Reason::REASON_REWARD_MINE_BLOCK),
                3 => ::std::option::Option::Some(Reason::REASON_DAO_REFUND_CONTRACT),
                4 => ::std::option::Option::Some(Reason::REASON_DAO_ADJUST_BALANCE),
                5 => ::std::option::Option::Some(Reason::REASON_TRANSFER),
                6 => ::std::option::Option::Some(Reason::REASON_GENESIS_BALANCE),
                7 => ::std::option::Option::Some(Reason::REASON_GAS_BUY),
                8 => ::std::option::Option::Some(Reason::REASON_REWARD_TRANSACTION_FEE),
                14 => ::std::option::Option::Some(Reason::REASON_REWARD_FEE_RESET),
                9 => ::std::option::Option::Some(Reason::REASON_GAS_REFUND),
                10 => ::std::option::Option::Some(Reason::REASON_TOUCH_ACCOUNT),
                11 => ::std::option::Option::Some(Reason::REASON_SUICIDE_REFUND),
                13 => ::std::option::Option::Some(Reason::REASON_SUICIDE_WITHDRAW),
                12 => ::std::option::Option::Some(Reason::REASON_CALL_BALANCE_OVERRIDE),
                15 => ::std::option::Option::Some(Reason::REASON_BURN),
                16 => ::std::option::Option::Some(Reason::REASON_WITHDRAWAL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Reason] = &[
            Reason::REASON_UNKNOWN,
            Reason::REASON_REWARD_MINE_UNCLE,
            Reason::REASON_REWARD_MINE_BLOCK,
            Reason::REASON_DAO_REFUND_CONTRACT,
            Reason::REASON_DAO_ADJUST_BALANCE,
            Reason::REASON_TRANSFER,
            Reason::REASON_GENESIS_BALANCE,
            Reason::REASON_GAS_BUY,
            Reason::REASON_REWARD_TRANSACTION_FEE,
            Reason::REASON_REWARD_FEE_RESET,
            Reason::REASON_GAS_REFUND,
            Reason::REASON_TOUCH_ACCOUNT,
            Reason::REASON_SUICIDE_REFUND,
            Reason::REASON_SUICIDE_WITHDRAW,
            Reason::REASON_CALL_BALANCE_OVERRIDE,
            Reason::REASON_BURN,
            Reason::REASON_WITHDRAWAL,
        ];
    }

    impl ::protobuf::EnumFull for Reason {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BalanceChange.Reason").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Reason::REASON_UNKNOWN => 0,
                Reason::REASON_REWARD_MINE_UNCLE => 1,
                Reason::REASON_REWARD_MINE_BLOCK => 2,
                Reason::REASON_DAO_REFUND_CONTRACT => 3,
                Reason::REASON_DAO_ADJUST_BALANCE => 4,
                Reason::REASON_TRANSFER => 5,
                Reason::REASON_GENESIS_BALANCE => 6,
                Reason::REASON_GAS_BUY => 7,
                Reason::REASON_REWARD_TRANSACTION_FEE => 8,
                Reason::REASON_REWARD_FEE_RESET => 9,
                Reason::REASON_GAS_REFUND => 10,
                Reason::REASON_TOUCH_ACCOUNT => 11,
                Reason::REASON_SUICIDE_REFUND => 12,
                Reason::REASON_SUICIDE_WITHDRAW => 13,
                Reason::REASON_CALL_BALANCE_OVERRIDE => 14,
                Reason::REASON_BURN => 15,
                Reason::REASON_WITHDRAWAL => 16,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Reason {
        fn default() -> Self {
            Reason::REASON_UNKNOWN
        }
    }

    impl Reason {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Reason>("BalanceChange.Reason")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.NonceChange)
pub struct NonceChange {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.NonceChange.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.NonceChange.old_value)
    pub old_value: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.NonceChange.new_value)
    pub new_value: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.NonceChange.ordinal)
    pub ordinal: u64,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.NonceChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NonceChange {
    fn default() -> &'a NonceChange {
        <NonceChange as ::protobuf::Message>::default_instance()
    }
}

impl NonceChange {
    pub fn new() -> NonceChange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &NonceChange| { &m.address },
            |m: &mut NonceChange| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "old_value",
            |m: &NonceChange| { &m.old_value },
            |m: &mut NonceChange| { &mut m.old_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_value",
            |m: &NonceChange| { &m.new_value },
            |m: &mut NonceChange| { &mut m.new_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ordinal",
            |m: &NonceChange| { &m.ordinal },
            |m: &mut NonceChange| { &mut m.ordinal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NonceChange>(
            "NonceChange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NonceChange {
    const NAME: &'static str = "NonceChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                16 => {
                    self.old_value = is.read_uint64()?;
                },
                24 => {
                    self.new_value = is.read_uint64()?;
                },
                32 => {
                    self.ordinal = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if self.old_value != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.old_value);
        }
        if self.new_value != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.new_value);
        }
        if self.ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.ordinal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if self.old_value != 0 {
            os.write_uint64(2, self.old_value)?;
        }
        if self.new_value != 0 {
            os.write_uint64(3, self.new_value)?;
        }
        if self.ordinal != 0 {
            os.write_uint64(4, self.ordinal)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NonceChange {
        NonceChange::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.old_value = 0;
        self.new_value = 0;
        self.ordinal = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NonceChange {
        static instance: NonceChange = NonceChange {
            address: ::std::vec::Vec::new(),
            old_value: 0,
            new_value: 0,
            ordinal: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NonceChange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NonceChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NonceChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NonceChange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.AccountCreation)
pub struct AccountCreation {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.AccountCreation.account)
    pub account: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.AccountCreation.ordinal)
    pub ordinal: u64,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.AccountCreation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccountCreation {
    fn default() -> &'a AccountCreation {
        <AccountCreation as ::protobuf::Message>::default_instance()
    }
}

impl AccountCreation {
    pub fn new() -> AccountCreation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "account",
            |m: &AccountCreation| { &m.account },
            |m: &mut AccountCreation| { &mut m.account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ordinal",
            |m: &AccountCreation| { &m.ordinal },
            |m: &mut AccountCreation| { &mut m.ordinal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountCreation>(
            "AccountCreation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccountCreation {
    const NAME: &'static str = "AccountCreation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.account = is.read_bytes()?;
                },
                16 => {
                    self.ordinal = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.account);
        }
        if self.ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.ordinal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.account.is_empty() {
            os.write_bytes(1, &self.account)?;
        }
        if self.ordinal != 0 {
            os.write_uint64(2, self.ordinal)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccountCreation {
        AccountCreation::new()
    }

    fn clear(&mut self) {
        self.account.clear();
        self.ordinal = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccountCreation {
        static instance: AccountCreation = AccountCreation {
            account: ::std::vec::Vec::new(),
            ordinal: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccountCreation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccountCreation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccountCreation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountCreation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.CodeChange)
pub struct CodeChange {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.CodeChange.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.CodeChange.old_hash)
    pub old_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.CodeChange.old_code)
    pub old_code: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.CodeChange.new_hash)
    pub new_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.CodeChange.new_code)
    pub new_code: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.CodeChange.ordinal)
    pub ordinal: u64,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.CodeChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CodeChange {
    fn default() -> &'a CodeChange {
        <CodeChange as ::protobuf::Message>::default_instance()
    }
}

impl CodeChange {
    pub fn new() -> CodeChange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &CodeChange| { &m.address },
            |m: &mut CodeChange| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "old_hash",
            |m: &CodeChange| { &m.old_hash },
            |m: &mut CodeChange| { &mut m.old_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "old_code",
            |m: &CodeChange| { &m.old_code },
            |m: &mut CodeChange| { &mut m.old_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_hash",
            |m: &CodeChange| { &m.new_hash },
            |m: &mut CodeChange| { &mut m.new_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_code",
            |m: &CodeChange| { &m.new_code },
            |m: &mut CodeChange| { &mut m.new_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ordinal",
            |m: &CodeChange| { &m.ordinal },
            |m: &mut CodeChange| { &mut m.ordinal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CodeChange>(
            "CodeChange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CodeChange {
    const NAME: &'static str = "CodeChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                18 => {
                    self.old_hash = is.read_bytes()?;
                },
                26 => {
                    self.old_code = is.read_bytes()?;
                },
                34 => {
                    self.new_hash = is.read_bytes()?;
                },
                42 => {
                    self.new_code = is.read_bytes()?;
                },
                48 => {
                    self.ordinal = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if !self.old_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.old_hash);
        }
        if !self.old_code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.old_code);
        }
        if !self.new_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.new_hash);
        }
        if !self.new_code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.new_code);
        }
        if self.ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.ordinal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if !self.old_hash.is_empty() {
            os.write_bytes(2, &self.old_hash)?;
        }
        if !self.old_code.is_empty() {
            os.write_bytes(3, &self.old_code)?;
        }
        if !self.new_hash.is_empty() {
            os.write_bytes(4, &self.new_hash)?;
        }
        if !self.new_code.is_empty() {
            os.write_bytes(5, &self.new_code)?;
        }
        if self.ordinal != 0 {
            os.write_uint64(6, self.ordinal)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CodeChange {
        CodeChange::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.old_hash.clear();
        self.old_code.clear();
        self.new_hash.clear();
        self.new_code.clear();
        self.ordinal = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CodeChange {
        static instance: CodeChange = CodeChange {
            address: ::std::vec::Vec::new(),
            old_hash: ::std::vec::Vec::new(),
            old_code: ::std::vec::Vec::new(),
            new_hash: ::std::vec::Vec::new(),
            new_code: ::std::vec::Vec::new(),
            ordinal: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CodeChange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CodeChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CodeChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodeChange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.GasChange)
pub struct GasChange {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.GasChange.old_value)
    pub old_value: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.GasChange.new_value)
    pub new_value: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.GasChange.reason)
    pub reason: ::protobuf::EnumOrUnknown<gas_change::Reason>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.GasChange.ordinal)
    pub ordinal: u64,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.GasChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GasChange {
    fn default() -> &'a GasChange {
        <GasChange as ::protobuf::Message>::default_instance()
    }
}

impl GasChange {
    pub fn new() -> GasChange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "old_value",
            |m: &GasChange| { &m.old_value },
            |m: &mut GasChange| { &mut m.old_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_value",
            |m: &GasChange| { &m.new_value },
            |m: &mut GasChange| { &mut m.new_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reason",
            |m: &GasChange| { &m.reason },
            |m: &mut GasChange| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ordinal",
            |m: &GasChange| { &m.ordinal },
            |m: &mut GasChange| { &mut m.ordinal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GasChange>(
            "GasChange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GasChange {
    const NAME: &'static str = "GasChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.old_value = is.read_uint64()?;
                },
                16 => {
                    self.new_value = is.read_uint64()?;
                },
                24 => {
                    self.reason = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.ordinal = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.old_value != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.old_value);
        }
        if self.new_value != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.new_value);
        }
        if self.reason != ::protobuf::EnumOrUnknown::new(gas_change::Reason::REASON_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(3, self.reason.value());
        }
        if self.ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.ordinal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.old_value != 0 {
            os.write_uint64(1, self.old_value)?;
        }
        if self.new_value != 0 {
            os.write_uint64(2, self.new_value)?;
        }
        if self.reason != ::protobuf::EnumOrUnknown::new(gas_change::Reason::REASON_UNKNOWN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.reason))?;
        }
        if self.ordinal != 0 {
            os.write_uint64(4, self.ordinal)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GasChange {
        GasChange::new()
    }

    fn clear(&mut self) {
        self.old_value = 0;
        self.new_value = 0;
        self.reason = ::protobuf::EnumOrUnknown::new(gas_change::Reason::REASON_UNKNOWN);
        self.ordinal = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GasChange {
        static instance: GasChange = GasChange {
            old_value: 0,
            new_value: 0,
            reason: ::protobuf::EnumOrUnknown::from_i32(0),
            ordinal: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GasChange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GasChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GasChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GasChange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GasChange`
pub mod gas_change {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:sf.ethereum.type.v2.GasChange.Reason)
    pub enum Reason {
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_UNKNOWN)
        REASON_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_CALL)
        REASON_CALL = 1,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_CALL_CODE)
        REASON_CALL_CODE = 2,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_CALL_DATA_COPY)
        REASON_CALL_DATA_COPY = 3,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_CODE_COPY)
        REASON_CODE_COPY = 4,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_CODE_STORAGE)
        REASON_CODE_STORAGE = 5,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_CONTRACT_CREATION)
        REASON_CONTRACT_CREATION = 6,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_CONTRACT_CREATION2)
        REASON_CONTRACT_CREATION2 = 7,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_DELEGATE_CALL)
        REASON_DELEGATE_CALL = 8,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_EVENT_LOG)
        REASON_EVENT_LOG = 9,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_EXT_CODE_COPY)
        REASON_EXT_CODE_COPY = 10,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_FAILED_EXECUTION)
        REASON_FAILED_EXECUTION = 11,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_INTRINSIC_GAS)
        REASON_INTRINSIC_GAS = 12,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_PRECOMPILED_CONTRACT)
        REASON_PRECOMPILED_CONTRACT = 13,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_REFUND_AFTER_EXECUTION)
        REASON_REFUND_AFTER_EXECUTION = 14,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_RETURN)
        REASON_RETURN = 15,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_RETURN_DATA_COPY)
        REASON_RETURN_DATA_COPY = 16,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_REVERT)
        REASON_REVERT = 17,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_SELF_DESTRUCT)
        REASON_SELF_DESTRUCT = 18,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_STATIC_CALL)
        REASON_STATIC_CALL = 19,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_STATE_COLD_ACCESS)
        REASON_STATE_COLD_ACCESS = 20,
    }

    impl ::protobuf::Enum for Reason {
        const NAME: &'static str = "Reason";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Reason> {
            match value {
                0 => ::std::option::Option::Some(Reason::REASON_UNKNOWN),
                1 => ::std::option::Option::Some(Reason::REASON_CALL),
                2 => ::std::option::Option::Some(Reason::REASON_CALL_CODE),
                3 => ::std::option::Option::Some(Reason::REASON_CALL_DATA_COPY),
                4 => ::std::option::Option::Some(Reason::REASON_CODE_COPY),
                5 => ::std::option::Option::Some(Reason::REASON_CODE_STORAGE),
                6 => ::std::option::Option::Some(Reason::REASON_CONTRACT_CREATION),
                7 => ::std::option::Option::Some(Reason::REASON_CONTRACT_CREATION2),
                8 => ::std::option::Option::Some(Reason::REASON_DELEGATE_CALL),
                9 => ::std::option::Option::Some(Reason::REASON_EVENT_LOG),
                10 => ::std::option::Option::Some(Reason::REASON_EXT_CODE_COPY),
                11 => ::std::option::Option::Some(Reason::REASON_FAILED_EXECUTION),
                12 => ::std::option::Option::Some(Reason::REASON_INTRINSIC_GAS),
                13 => ::std::option::Option::Some(Reason::REASON_PRECOMPILED_CONTRACT),
                14 => ::std::option::Option::Some(Reason::REASON_REFUND_AFTER_EXECUTION),
                15 => ::std::option::Option::Some(Reason::REASON_RETURN),
                16 => ::std::option::Option::Some(Reason::REASON_RETURN_DATA_COPY),
                17 => ::std::option::Option::Some(Reason::REASON_REVERT),
                18 => ::std::option::Option::Some(Reason::REASON_SELF_DESTRUCT),
                19 => ::std::option::Option::Some(Reason::REASON_STATIC_CALL),
                20 => ::std::option::Option::Some(Reason::REASON_STATE_COLD_ACCESS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Reason] = &[
            Reason::REASON_UNKNOWN,
            Reason::REASON_CALL,
            Reason::REASON_CALL_CODE,
            Reason::REASON_CALL_DATA_COPY,
            Reason::REASON_CODE_COPY,
            Reason::REASON_CODE_STORAGE,
            Reason::REASON_CONTRACT_CREATION,
            Reason::REASON_CONTRACT_CREATION2,
            Reason::REASON_DELEGATE_CALL,
            Reason::REASON_EVENT_LOG,
            Reason::REASON_EXT_CODE_COPY,
            Reason::REASON_FAILED_EXECUTION,
            Reason::REASON_INTRINSIC_GAS,
            Reason::REASON_PRECOMPILED_CONTRACT,
            Reason::REASON_REFUND_AFTER_EXECUTION,
            Reason::REASON_RETURN,
            Reason::REASON_RETURN_DATA_COPY,
            Reason::REASON_REVERT,
            Reason::REASON_SELF_DESTRUCT,
            Reason::REASON_STATIC_CALL,
            Reason::REASON_STATE_COLD_ACCESS,
        ];
    }

    impl ::protobuf::EnumFull for Reason {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("GasChange.Reason").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Reason {
        fn default() -> Self {
            Reason::REASON_UNKNOWN
        }
    }

    impl Reason {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Reason>("GasChange.Reason")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.HeaderOnlyBlock)
pub struct HeaderOnlyBlock {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.HeaderOnlyBlock.header)
    pub header: ::protobuf::MessageField<BlockHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.HeaderOnlyBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HeaderOnlyBlock {
    fn default() -> &'a HeaderOnlyBlock {
        <HeaderOnlyBlock as ::protobuf::Message>::default_instance()
    }
}

impl HeaderOnlyBlock {
    pub fn new() -> HeaderOnlyBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockHeader>(
            "header",
            |m: &HeaderOnlyBlock| { &m.header },
            |m: &mut HeaderOnlyBlock| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeaderOnlyBlock>(
            "HeaderOnlyBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HeaderOnlyBlock {
    const NAME: &'static str = "HeaderOnlyBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HeaderOnlyBlock {
        HeaderOnlyBlock::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HeaderOnlyBlock {
        static instance: HeaderOnlyBlock = HeaderOnlyBlock {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HeaderOnlyBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HeaderOnlyBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HeaderOnlyBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeaderOnlyBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.BlockWithRefs)
pub struct BlockWithRefs {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockWithRefs.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockWithRefs.block)
    pub block: ::protobuf::MessageField<Block>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockWithRefs.transaction_trace_refs)
    pub transaction_trace_refs: ::protobuf::MessageField<TransactionRefs>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockWithRefs.irreversible)
    pub irreversible: bool,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.BlockWithRefs.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockWithRefs {
    fn default() -> &'a BlockWithRefs {
        <BlockWithRefs as ::protobuf::Message>::default_instance()
    }
}

impl BlockWithRefs {
    pub fn new() -> BlockWithRefs {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &BlockWithRefs| { &m.id },
            |m: &mut BlockWithRefs| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Block>(
            "block",
            |m: &BlockWithRefs| { &m.block },
            |m: &mut BlockWithRefs| { &mut m.block },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TransactionRefs>(
            "transaction_trace_refs",
            |m: &BlockWithRefs| { &m.transaction_trace_refs },
            |m: &mut BlockWithRefs| { &mut m.transaction_trace_refs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "irreversible",
            |m: &BlockWithRefs| { &m.irreversible },
            |m: &mut BlockWithRefs| { &mut m.irreversible },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockWithRefs>(
            "BlockWithRefs",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockWithRefs {
    const NAME: &'static str = "BlockWithRefs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transaction_trace_refs)?;
                },
                32 => {
                    self.irreversible = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transaction_trace_refs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.irreversible != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.block.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transaction_trace_refs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.irreversible != false {
            os.write_bool(4, self.irreversible)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockWithRefs {
        BlockWithRefs::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.block.clear();
        self.transaction_trace_refs.clear();
        self.irreversible = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockWithRefs {
        static instance: BlockWithRefs = BlockWithRefs {
            id: ::std::string::String::new(),
            block: ::protobuf::MessageField::none(),
            transaction_trace_refs: ::protobuf::MessageField::none(),
            irreversible: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockWithRefs {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockWithRefs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockWithRefs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockWithRefs {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.TransactionTraceWithBlockRef)
pub struct TransactionTraceWithBlockRef {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTraceWithBlockRef.trace)
    pub trace: ::protobuf::MessageField<TransactionTrace>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTraceWithBlockRef.block_ref)
    pub block_ref: ::protobuf::MessageField<BlockRef>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.TransactionTraceWithBlockRef.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionTraceWithBlockRef {
    fn default() -> &'a TransactionTraceWithBlockRef {
        <TransactionTraceWithBlockRef as ::protobuf::Message>::default_instance()
    }
}

impl TransactionTraceWithBlockRef {
    pub fn new() -> TransactionTraceWithBlockRef {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TransactionTrace>(
            "trace",
            |m: &TransactionTraceWithBlockRef| { &m.trace },
            |m: &mut TransactionTraceWithBlockRef| { &mut m.trace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockRef>(
            "block_ref",
            |m: &TransactionTraceWithBlockRef| { &m.block_ref },
            |m: &mut TransactionTraceWithBlockRef| { &mut m.block_ref },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionTraceWithBlockRef>(
            "TransactionTraceWithBlockRef",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionTraceWithBlockRef {
    const NAME: &'static str = "TransactionTraceWithBlockRef";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trace)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block_ref)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.trace.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.block_ref.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.trace.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.block_ref.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionTraceWithBlockRef {
        TransactionTraceWithBlockRef::new()
    }

    fn clear(&mut self) {
        self.trace.clear();
        self.block_ref.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionTraceWithBlockRef {
        static instance: TransactionTraceWithBlockRef = TransactionTraceWithBlockRef {
            trace: ::protobuf::MessageField::none(),
            block_ref: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionTraceWithBlockRef {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionTraceWithBlockRef").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionTraceWithBlockRef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionTraceWithBlockRef {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.TransactionRefs)
pub struct TransactionRefs {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionRefs.hashes)
    pub hashes: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.TransactionRefs.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionRefs {
    fn default() -> &'a TransactionRefs {
        <TransactionRefs as ::protobuf::Message>::default_instance()
    }
}

impl TransactionRefs {
    pub fn new() -> TransactionRefs {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hashes",
            |m: &TransactionRefs| { &m.hashes },
            |m: &mut TransactionRefs| { &mut m.hashes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionRefs>(
            "TransactionRefs",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionRefs {
    const NAME: &'static str = "TransactionRefs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hashes.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hashes {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.hashes {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionRefs {
        TransactionRefs::new()
    }

    fn clear(&mut self) {
        self.hashes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionRefs {
        static instance: TransactionRefs = TransactionRefs {
            hashes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionRefs {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionRefs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionRefs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionRefs {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.BlockRef)
pub struct BlockRef {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockRef.hash)
    pub hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockRef.number)
    pub number: u64,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.BlockRef.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockRef {
    fn default() -> &'a BlockRef {
        <BlockRef as ::protobuf::Message>::default_instance()
    }
}

impl BlockRef {
    pub fn new() -> BlockRef {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &BlockRef| { &m.hash },
            |m: &mut BlockRef| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "number",
            |m: &BlockRef| { &m.number },
            |m: &mut BlockRef| { &mut m.number },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockRef>(
            "BlockRef",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockRef {
    const NAME: &'static str = "BlockRef";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hash = is.read_bytes()?;
                },
                16 => {
                    self.number = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if self.number != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.number);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if self.number != 0 {
            os.write_uint64(2, self.number)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockRef {
        BlockRef::new()
    }

    fn clear(&mut self) {
        self.hash.clear();
        self.number = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockRef {
        static instance: BlockRef = BlockRef {
            hash: ::std::vec::Vec::new(),
            number: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockRef {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockRef").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockRef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockRef {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:sf.ethereum.type.v2.TransactionTraceStatus)
pub enum TransactionTraceStatus {
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.TransactionTraceStatus.UNKNOWN)
    UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.TransactionTraceStatus.SUCCEEDED)
    SUCCEEDED = 1,
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.TransactionTraceStatus.FAILED)
    FAILED = 2,
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.TransactionTraceStatus.REVERTED)
    REVERTED = 3,
}

impl ::protobuf::Enum for TransactionTraceStatus {
    const NAME: &'static str = "TransactionTraceStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TransactionTraceStatus> {
        match value {
            0 => ::std::option::Option::Some(TransactionTraceStatus::UNKNOWN),
            1 => ::std::option::Option::Some(TransactionTraceStatus::SUCCEEDED),
            2 => ::std::option::Option::Some(TransactionTraceStatus::FAILED),
            3 => ::std::option::Option::Some(TransactionTraceStatus::REVERTED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TransactionTraceStatus] = &[
        TransactionTraceStatus::UNKNOWN,
        TransactionTraceStatus::SUCCEEDED,
        TransactionTraceStatus::FAILED,
        TransactionTraceStatus::REVERTED,
    ];
}

impl ::protobuf::EnumFull for TransactionTraceStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TransactionTraceStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TransactionTraceStatus {
    fn default() -> Self {
        TransactionTraceStatus::UNKNOWN
    }
}

impl TransactionTraceStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TransactionTraceStatus>("TransactionTraceStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:sf.ethereum.type.v2.CallType)
pub enum CallType {
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.CallType.UNSPECIFIED)
    UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.CallType.CALL)
    CALL = 1,
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.CallType.CALLCODE)
    CALLCODE = 2,
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.CallType.DELEGATE)
    DELEGATE = 3,
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.CallType.STATIC)
    STATIC = 4,
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.CallType.CREATE)
    CREATE = 5,
}

impl ::protobuf::Enum for CallType {
    const NAME: &'static str = "CallType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CallType> {
        match value {
            0 => ::std::option::Option::Some(CallType::UNSPECIFIED),
            1 => ::std::option::Option::Some(CallType::CALL),
            2 => ::std::option::Option::Some(CallType::CALLCODE),
            3 => ::std::option::Option::Some(CallType::DELEGATE),
            4 => ::std::option::Option::Some(CallType::STATIC),
            5 => ::std::option::Option::Some(CallType::CREATE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CallType] = &[
        CallType::UNSPECIFIED,
        CallType::CALL,
        CallType::CALLCODE,
        CallType::DELEGATE,
        CallType::STATIC,
        CallType::CREATE,
    ];
}

impl ::protobuf::EnumFull for CallType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CallType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CallType {
    fn default() -> Self {
        CallType::UNSPECIFIED
    }
}

impl CallType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CallType>("CallType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bblock.proto\x12\x13sf.ethereum.type.v2\x1a\x1fgoogle/protobuf/time\
    stamp.proto\"\xc6\x03\n\x05Block\x12\x12\n\x04hash\x18\x02\x20\x01(\x0cR\
    \x04hash\x12\x16\n\x06number\x18\x03\x20\x01(\x04R\x06number\x12\x12\n\
    \x04size\x18\x04\x20\x01(\x04R\x04size\x128\n\x06header\x18\x05\x20\x01(\
    \x0b2\x20.sf.ethereum.type.v2.BlockHeaderR\x06header\x128\n\x06uncles\
    \x18\x06\x20\x03(\x0b2\x20.sf.ethereum.type.v2.BlockHeaderR\x06uncles\
    \x12T\n\x12transaction_traces\x18\n\x20\x03(\x0b2%.sf.ethereum.type.v2.T\
    ransactionTraceR\x11transactionTraces\x12K\n\x0fbalance_changes\x18\x0b\
    \x20\x03(\x0b2\".sf.ethereum.type.v2.BalanceChangeR\x0ebalanceChanges\
    \x12B\n\x0ccode_changes\x18\x14\x20\x03(\x0b2\x1f.sf.ethereum.type.v2.Co\
    deChangeR\x0bcodeChanges\x12\x10\n\x03ver\x18\x01\x20\x01(\x05R\x03verJ\
    \x04\x08(\x10)J\x04\x08)\x10*J\x04\x08*\x10+\"\xa8\x06\n\x0bBlockHeader\
    \x12\x1f\n\x0bparent_hash\x18\x01\x20\x01(\x0cR\nparentHash\x12\x1d\n\nu\
    ncle_hash\x18\x02\x20\x01(\x0cR\tuncleHash\x12\x1a\n\x08coinbase\x18\x03\
    \x20\x01(\x0cR\x08coinbase\x12\x1d\n\nstate_root\x18\x04\x20\x01(\x0cR\t\
    stateRoot\x12+\n\x11transactions_root\x18\x05\x20\x01(\x0cR\x10transacti\
    onsRoot\x12!\n\x0creceipt_root\x18\x06\x20\x01(\x0cR\x0breceiptRoot\x12\
    \x1d\n\nlogs_bloom\x18\x07\x20\x01(\x0cR\tlogsBloom\x12;\n\ndifficulty\
    \x18\x08\x20\x01(\x0b2\x1b.sf.ethereum.type.v2.BigIntR\ndifficulty\x12F\
    \n\x10total_difficulty\x18\x11\x20\x01(\x0b2\x1b.sf.ethereum.type.v2.Big\
    IntR\x0ftotalDifficulty\x12\x16\n\x06number\x18\t\x20\x01(\x04R\x06numbe\
    r\x12\x1b\n\tgas_limit\x18\n\x20\x01(\x04R\x08gasLimit\x12\x19\n\x08gas_\
    used\x18\x0b\x20\x01(\x04R\x07gasUsed\x128\n\ttimestamp\x18\x0c\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\ttimestamp\x12\x1d\n\nextra_data\
    \x18\r\x20\x01(\x0cR\textraData\x12\x19\n\x08mix_hash\x18\x0e\x20\x01(\
    \x0cR\x07mixHash\x12\x14\n\x05nonce\x18\x0f\x20\x01(\x04R\x05nonce\x12\
    \x12\n\x04hash\x18\x10\x20\x01(\x0cR\x04hash\x12D\n\x10base_fee_per_gas\
    \x18\x12\x20\x01(\x0b2\x1b.sf.ethereum.type.v2.BigIntR\rbaseFeePerGas\
    \x12)\n\x10withdrawals_root\x18\x13\x20\x01(\x0cR\x0fwithdrawalsRoot\x12\
    K\n\rtx_dependency\x18\x14\x20\x01(\x0b2&.sf.ethereum.type.v2.Uint64Nest\
    edArrayR\x0ctxDependency\"G\n\x11Uint64NestedArray\x122\n\x03val\x18\x01\
    \x20\x03(\x0b2\x20.sf.ethereum.type.v2.Uint64ArrayR\x03val\"\x1f\n\x0bUi\
    nt64Array\x12\x10\n\x03val\x18\x01\x20\x03(\x04R\x03val\"\x1e\n\x06BigIn\
    t\x12\x14\n\x05bytes\x18\x01\x20\x01(\x0cR\x05bytes\"\xd6\x07\n\x10Trans\
    actionTrace\x12\x0e\n\x02to\x18\x01\x20\x01(\x0cR\x02to\x12\x14\n\x05non\
    ce\x18\x02\x20\x01(\x04R\x05nonce\x128\n\tgas_price\x18\x03\x20\x01(\x0b\
    2\x1b.sf.ethereum.type.v2.BigIntR\x08gasPrice\x12\x1b\n\tgas_limit\x18\
    \x04\x20\x01(\x04R\x08gasLimit\x121\n\x05value\x18\x05\x20\x01(\x0b2\x1b\
    .sf.ethereum.type.v2.BigIntR\x05value\x12\x14\n\x05input\x18\x06\x20\x01\
    (\x0cR\x05input\x12\x0c\n\x01v\x18\x07\x20\x01(\x0cR\x01v\x12\x0c\n\x01r\
    \x18\x08\x20\x01(\x0cR\x01r\x12\x0c\n\x01s\x18\t\x20\x01(\x0cR\x01s\x12\
    \x19\n\x08gas_used\x18\n\x20\x01(\x04R\x07gasUsed\x12>\n\x04type\x18\x0c\
    \x20\x01(\x0e2*.sf.ethereum.type.v2.TransactionTrace.TypeR\x04type\x12A\
    \n\x0baccess_list\x18\x0e\x20\x03(\x0b2\x20.sf.ethereum.type.v2.AccessTu\
    pleR\naccessList\x12B\n\x0fmax_fee_per_gas\x18\x0b\x20\x01(\x0b2\x1b.sf.\
    ethereum.type.v2.BigIntR\x0cmaxFeePerGas\x12S\n\x18max_priority_fee_per_\
    gas\x18\r\x20\x01(\x0b2\x1b.sf.ethereum.type.v2.BigIntR\x14maxPriorityFe\
    ePerGas\x12\x14\n\x05index\x18\x14\x20\x01(\rR\x05index\x12\x12\n\x04has\
    h\x18\x15\x20\x01(\x0cR\x04hash\x12\x12\n\x04from\x18\x16\x20\x01(\x0cR\
    \x04from\x12\x1f\n\x0breturn_data\x18\x17\x20\x01(\x0cR\nreturnData\x12\
    \x1d\n\npublic_key\x18\x18\x20\x01(\x0cR\tpublicKey\x12#\n\rbegin_ordina\
    l\x18\x19\x20\x01(\x04R\x0cbeginOrdinal\x12\x1f\n\x0bend_ordinal\x18\x1a\
    \x20\x01(\x04R\nendOrdinal\x12C\n\x06status\x18\x1e\x20\x01(\x0e2+.sf.et\
    hereum.type.v2.TransactionTraceStatusR\x06status\x12A\n\x07receipt\x18\
    \x1f\x20\x01(\x0b2'.sf.ethereum.type.v2.TransactionReceiptR\x07receipt\"\
    O\n\x04Type\x12\x13\n\x0fTRX_TYPE_LEGACY\x10\0\x12\x18\n\x14TRX_TYPE_ACC\
    ESS_LIST\x10\x01\x12\x18\n\x14TRX_TYPE_DYNAMIC_FEE\x10\x02\"J\n\x0bAcces\
    sTuple\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\x12!\n\x0cs\
    torage_keys\x18\x02\x20\x03(\x0cR\x0bstorageKeys\"\xb0\x01\n\x12Transact\
    ionReceipt\x12\x1d\n\nstate_root\x18\x01\x20\x01(\x0cR\tstateRoot\x12.\n\
    \x13cumulative_gas_used\x18\x02\x20\x01(\x04R\x11cumulativeGasUsed\x12\
    \x1d\n\nlogs_bloom\x18\x03\x20\x01(\x0cR\tlogsBloom\x12,\n\x04logs\x18\
    \x04\x20\x03(\x0b2\x18.sf.ethereum.type.v2.LogR\x04logs\"\x9b\x01\n\x03L\
    og\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\x12\x16\n\x06to\
    pics\x18\x02\x20\x03(\x0cR\x06topics\x12\x12\n\x04data\x18\x03\x20\x01(\
    \x0cR\x04data\x12\x14\n\x05index\x18\x04\x20\x01(\rR\x05index\x12\x1e\n\
    \nblockIndex\x18\x06\x20\x01(\rR\nblockIndex\x12\x18\n\x07ordinal\x18\
    \x07\x20\x01(\x04R\x07ordinal\"\xb2\n\n\x04Call\x12\x14\n\x05index\x18\
    \x01\x20\x01(\rR\x05index\x12!\n\x0cparent_index\x18\x02\x20\x01(\rR\x0b\
    parentIndex\x12\x14\n\x05depth\x18\x03\x20\x01(\rR\x05depth\x12:\n\tcall\
    _type\x18\x04\x20\x01(\x0e2\x1d.sf.ethereum.type.v2.CallTypeR\x08callTyp\
    e\x12\x16\n\x06caller\x18\x05\x20\x01(\x0cR\x06caller\x12\x18\n\x07addre\
    ss\x18\x06\x20\x01(\x0cR\x07address\x121\n\x05value\x18\x07\x20\x01(\x0b\
    2\x1b.sf.ethereum.type.v2.BigIntR\x05value\x12\x1b\n\tgas_limit\x18\x08\
    \x20\x01(\x04R\x08gasLimit\x12!\n\x0cgas_consumed\x18\t\x20\x01(\x04R\
    \x0bgasConsumed\x12\x1f\n\x0breturn_data\x18\r\x20\x01(\x0cR\nreturnData\
    \x12\x14\n\x05input\x18\x0e\x20\x01(\x0cR\x05input\x12#\n\rexecuted_code\
    \x18\x0f\x20\x01(\x08R\x0cexecutedCode\x12\x18\n\x07suicide\x18\x10\x20\
    \x01(\x08R\x07suicide\x12Y\n\x10keccak_preimages\x18\x14\x20\x03(\x0b2..\
    sf.ethereum.type.v2.Call.KeccakPreimagesEntryR\x0fkeccakPreimages\x12K\n\
    \x0fstorage_changes\x18\x15\x20\x03(\x0b2\".sf.ethereum.type.v2.StorageC\
    hangeR\x0estorageChanges\x12K\n\x0fbalance_changes\x18\x16\x20\x03(\x0b2\
    \".sf.ethereum.type.v2.BalanceChangeR\x0ebalanceChanges\x12E\n\rnonce_ch\
    anges\x18\x18\x20\x03(\x0b2\x20.sf.ethereum.type.v2.NonceChangeR\x0cnonc\
    eChanges\x12,\n\x04logs\x18\x19\x20\x03(\x0b2\x18.sf.ethereum.type.v2.Lo\
    gR\x04logs\x12B\n\x0ccode_changes\x18\x1a\x20\x03(\x0b2\x1f.sf.ethereum.\
    type.v2.CodeChangeR\x0bcodeChanges\x12?\n\x0bgas_changes\x18\x1c\x20\x03\
    (\x0b2\x1e.sf.ethereum.type.v2.GasChangeR\ngasChanges\x12#\n\rstatus_fai\
    led\x18\n\x20\x01(\x08R\x0cstatusFailed\x12'\n\x0fstatus_reverted\x18\
    \x0c\x20\x01(\x08R\x0estatusReverted\x12%\n\x0efailure_reason\x18\x0b\
    \x20\x01(\tR\rfailureReason\x12%\n\x0estate_reverted\x18\x1e\x20\x01(\
    \x08R\rstateReverted\x12#\n\rbegin_ordinal\x18\x1f\x20\x01(\x04R\x0cbegi\
    nOrdinal\x12\x1f\n\x0bend_ordinal\x18\x20\x20\x01(\x04R\nendOrdinal\x12Q\
    \n\x11account_creations\x18!\x20\x03(\x0b2$.sf.ethereum.type.v2.AccountC\
    reationR\x10accountCreations\x1aB\n\x14KeccakPreimagesEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01J\x04\x08\x1b\x10\x1cJ\x04\x08\x1d\x10\x1eJ\x04\x082\
    \x103J\x04\x083\x104J\x04\x08<\x10=\"\x8f\x01\n\rStorageChange\x12\x18\n\
    \x07address\x18\x01\x20\x01(\x0cR\x07address\x12\x10\n\x03key\x18\x02\
    \x20\x01(\x0cR\x03key\x12\x1b\n\told_value\x18\x03\x20\x01(\x0cR\x08oldV\
    alue\x12\x1b\n\tnew_value\x18\x04\x20\x01(\x0cR\x08newValue\x12\x18\n\
    \x07ordinal\x18\x05\x20\x01(\x04R\x07ordinal\"\xcc\x05\n\rBalanceChange\
    \x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\x128\n\told_value\
    \x18\x02\x20\x01(\x0b2\x1b.sf.ethereum.type.v2.BigIntR\x08oldValue\x128\
    \n\tnew_value\x18\x03\x20\x01(\x0b2\x1b.sf.ethereum.type.v2.BigIntR\x08n\
    ewValue\x12A\n\x06reason\x18\x04\x20\x01(\x0e2).sf.ethereum.type.v2.Bala\
    nceChange.ReasonR\x06reason\x12\x18\n\x07ordinal\x18\x05\x20\x01(\x04R\
    \x07ordinal\"\xcf\x03\n\x06Reason\x12\x12\n\x0eREASON_UNKNOWN\x10\0\x12\
    \x1c\n\x18REASON_REWARD_MINE_UNCLE\x10\x01\x12\x1c\n\x18REASON_REWARD_MI\
    NE_BLOCK\x10\x02\x12\x1e\n\x1aREASON_DAO_REFUND_CONTRACT\x10\x03\x12\x1d\
    \n\x19REASON_DAO_ADJUST_BALANCE\x10\x04\x12\x13\n\x0fREASON_TRANSFER\x10\
    \x05\x12\x1a\n\x16REASON_GENESIS_BALANCE\x10\x06\x12\x12\n\x0eREASON_GAS\
    _BUY\x10\x07\x12!\n\x1dREASON_REWARD_TRANSACTION_FEE\x10\x08\x12\x1b\n\
    \x17REASON_REWARD_FEE_RESET\x10\x0e\x12\x15\n\x11REASON_GAS_REFUND\x10\t\
    \x12\x18\n\x14REASON_TOUCH_ACCOUNT\x10\n\x12\x19\n\x15REASON_SUICIDE_REF\
    UND\x10\x0b\x12\x1b\n\x17REASON_SUICIDE_WITHDRAW\x10\r\x12\x20\n\x1cREAS\
    ON_CALL_BALANCE_OVERRIDE\x10\x0c\x12\x0f\n\x0bREASON_BURN\x10\x0f\x12\
    \x15\n\x11REASON_WITHDRAWAL\x10\x10\"{\n\x0bNonceChange\x12\x18\n\x07add\
    ress\x18\x01\x20\x01(\x0cR\x07address\x12\x1b\n\told_value\x18\x02\x20\
    \x01(\x04R\x08oldValue\x12\x1b\n\tnew_value\x18\x03\x20\x01(\x04R\x08new\
    Value\x12\x18\n\x07ordinal\x18\x04\x20\x01(\x04R\x07ordinal\"E\n\x0fAcco\
    untCreation\x12\x18\n\x07account\x18\x01\x20\x01(\x0cR\x07account\x12\
    \x18\n\x07ordinal\x18\x02\x20\x01(\x04R\x07ordinal\"\xac\x01\n\nCodeChan\
    ge\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\x12\x19\n\x08ol\
    d_hash\x18\x02\x20\x01(\x0cR\x07oldHash\x12\x19\n\x08old_code\x18\x03\
    \x20\x01(\x0cR\x07oldCode\x12\x19\n\x08new_hash\x18\x04\x20\x01(\x0cR\
    \x07newHash\x12\x19\n\x08new_code\x18\x05\x20\x01(\x0cR\x07newCode\x12\
    \x18\n\x07ordinal\x18\x06\x20\x01(\x04R\x07ordinal\"\xc3\x05\n\tGasChang\
    e\x12\x1b\n\told_value\x18\x01\x20\x01(\x04R\x08oldValue\x12\x1b\n\tnew_\
    value\x18\x02\x20\x01(\x04R\x08newValue\x12=\n\x06reason\x18\x03\x20\x01\
    (\x0e2%.sf.ethereum.type.v2.GasChange.ReasonR\x06reason\x12\x18\n\x07ord\
    inal\x18\x04\x20\x01(\x04R\x07ordinal\"\xa2\x04\n\x06Reason\x12\x12\n\
    \x0eREASON_UNKNOWN\x10\0\x12\x0f\n\x0bREASON_CALL\x10\x01\x12\x14\n\x10R\
    EASON_CALL_CODE\x10\x02\x12\x19\n\x15REASON_CALL_DATA_COPY\x10\x03\x12\
    \x14\n\x10REASON_CODE_COPY\x10\x04\x12\x17\n\x13REASON_CODE_STORAGE\x10\
    \x05\x12\x1c\n\x18REASON_CONTRACT_CREATION\x10\x06\x12\x1d\n\x19REASON_C\
    ONTRACT_CREATION2\x10\x07\x12\x18\n\x14REASON_DELEGATE_CALL\x10\x08\x12\
    \x14\n\x10REASON_EVENT_LOG\x10\t\x12\x18\n\x14REASON_EXT_CODE_COPY\x10\n\
    \x12\x1b\n\x17REASON_FAILED_EXECUTION\x10\x0b\x12\x18\n\x14REASON_INTRIN\
    SIC_GAS\x10\x0c\x12\x1f\n\x1bREASON_PRECOMPILED_CONTRACT\x10\r\x12!\n\
    \x1dREASON_REFUND_AFTER_EXECUTION\x10\x0e\x12\x11\n\rREASON_RETURN\x10\
    \x0f\x12\x1b\n\x17REASON_RETURN_DATA_COPY\x10\x10\x12\x11\n\rREASON_REVE\
    RT\x10\x11\x12\x18\n\x14REASON_SELF_DESTRUCT\x10\x12\x12\x16\n\x12REASON\
    _STATIC_CALL\x10\x13\x12\x1c\n\x18REASON_STATE_COLD_ACCESS\x10\x14\"K\n\
    \x0fHeaderOnlyBlock\x128\n\x06header\x18\x05\x20\x01(\x0b2\x20.sf.ethere\
    um.type.v2.BlockHeaderR\x06header\"\xd1\x01\n\rBlockWithRefs\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\tR\x02id\x120\n\x05block\x18\x02\x20\x01(\x0b2\
    \x1a.sf.ethereum.type.v2.BlockR\x05block\x12Z\n\x16transaction_trace_ref\
    s\x18\x03\x20\x01(\x0b2$.sf.ethereum.type.v2.TransactionRefsR\x14transac\
    tionTraceRefs\x12\"\n\x0cirreversible\x18\x04\x20\x01(\x08R\x0cirreversi\
    ble\"\x97\x01\n\x1cTransactionTraceWithBlockRef\x12;\n\x05trace\x18\x01\
    \x20\x01(\x0b2%.sf.ethereum.type.v2.TransactionTraceR\x05trace\x12:\n\tb\
    lock_ref\x18\x02\x20\x01(\x0b2\x1d.sf.ethereum.type.v2.BlockRefR\x08bloc\
    kRef\")\n\x0fTransactionRefs\x12\x16\n\x06hashes\x18\x01\x20\x03(\x0cR\
    \x06hashes\"6\n\x08BlockRef\x12\x12\n\x04hash\x18\x01\x20\x01(\x0cR\x04h\
    ash\x12\x16\n\x06number\x18\x02\x20\x01(\x04R\x06number*N\n\x16Transacti\
    onTraceStatus\x12\x0b\n\x07UNKNOWN\x10\0\x12\r\n\tSUCCEEDED\x10\x01\x12\
    \n\n\x06FAILED\x10\x02\x12\x0c\n\x08REVERTED\x10\x03*Y\n\x08CallType\x12\
    \x0f\n\x0bUNSPECIFIED\x10\0\x12\x08\n\x04CALL\x10\x01\x12\x0c\n\x08CALLC\
    ODE\x10\x02\x12\x0c\n\x08DELEGATE\x10\x03\x12\n\n\x06STATIC\x10\x04\x12\
    \n\n\x06CREATE\x10\x05BOZMgithub.com/streamingfast/firehose-ethereum/typ\
    es/pb/sf/ethereum/type/v2;pbethb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(21);
            messages.push(Block::generated_message_descriptor_data());
            messages.push(BlockHeader::generated_message_descriptor_data());
            messages.push(Uint64NestedArray::generated_message_descriptor_data());
            messages.push(Uint64Array::generated_message_descriptor_data());
            messages.push(BigInt::generated_message_descriptor_data());
            messages.push(TransactionTrace::generated_message_descriptor_data());
            messages.push(AccessTuple::generated_message_descriptor_data());
            messages.push(TransactionReceipt::generated_message_descriptor_data());
            messages.push(Log::generated_message_descriptor_data());
            messages.push(Call::generated_message_descriptor_data());
            messages.push(StorageChange::generated_message_descriptor_data());
            messages.push(BalanceChange::generated_message_descriptor_data());
            messages.push(NonceChange::generated_message_descriptor_data());
            messages.push(AccountCreation::generated_message_descriptor_data());
            messages.push(CodeChange::generated_message_descriptor_data());
            messages.push(GasChange::generated_message_descriptor_data());
            messages.push(HeaderOnlyBlock::generated_message_descriptor_data());
            messages.push(BlockWithRefs::generated_message_descriptor_data());
            messages.push(TransactionTraceWithBlockRef::generated_message_descriptor_data());
            messages.push(TransactionRefs::generated_message_descriptor_data());
            messages.push(BlockRef::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(TransactionTraceStatus::generated_enum_descriptor_data());
            enums.push(CallType::generated_enum_descriptor_data());
            enums.push(transaction_trace::Type::generated_enum_descriptor_data());
            enums.push(balance_change::Reason::generated_enum_descriptor_data());
            enums.push(gas_change::Reason::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
