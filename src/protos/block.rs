// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `src/protos/block.proto`


/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.Block)
pub struct Block {
    // message fields
    ///  Hash is the block's hash.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.hash)
    pub hash: ::std::vec::Vec<u8>,
    ///  Number is the block's height at which this block was mined.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.number)
    pub number: u64,
    ///  Size is the size in bytes of the RLP encoding of the block according to Ethereum
    ///  rules.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.size)
    pub size: u64,
    ///  Header contain's the block's header information like its parent hash, the merkel root hash
    ///  and all other information the form a block.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.header)
    pub header: ::protobuf::MessageField<BlockHeader>,
    ///  Uncles represents block produced with a valid solution but were not actually choosen
    ///  as the canonical block for the given height so they are mostly "forked" blocks.
    ///
    ///  If the Block has been produced using the Proof of Stake consensus algorithm, this
    ///  field will actually be always empty.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.uncles)
    pub uncles: ::std::vec::Vec<BlockHeader>,
    ///  TransactionTraces hold the execute trace of all the transactions that were executed
    ///  in this block. In in there that you will find most of the Ethereum data model.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.transaction_traces)
    pub transaction_traces: ::std::vec::Vec<TransactionTrace>,
    ///  BalanceChanges here is the array of ETH transfer that happened at the block level
    ///  outside of the normal transaction flow of a block. The best example of this is mining
    ///  reward for the block mined, the transfer of ETH to the miner happens outside the normal
    ///  transaction flow of the chain and is recorded as a `BalanceChange` here since we cannot
    ///  attached it to any transaction.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.balance_changes)
    pub balance_changes: ::std::vec::Vec<BalanceChange>,
    ///  CodeChanges here is the array of smart code change that happened that happened at the block level
    ///  outside of the normal transaction flow of a block. Some Ethereum's fork like BSC and Polygon
    ///  has some capabilities to upgrade internal smart contracts used usually to track the validator
    ///  list.
    ///
    ///  On hard fork, some procedure runs to upgrade the smart contract code to a new version. In those
    ///  network, a `CodeChange` for each modified smart contract on upgrade would be present here. Note
    ///  that this happen rarely, so the vast majority of block will have an empty list here.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.code_changes)
    pub code_changes: ::std::vec::Vec<CodeChange>,
    ///  Ver represents that data model version of the block, it is used internally by Firehose on Ethereum
    ///  as a validation that we are reading the correct version.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Block.ver)
    pub ver: i32,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.Block.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &Block| { &m.hash },
            |m: &mut Block| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "number",
            |m: &Block| { &m.number },
            |m: &mut Block| { &mut m.number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "size",
            |m: &Block| { &m.size },
            |m: &mut Block| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockHeader>(
            "header",
            |m: &Block| { &m.header },
            |m: &mut Block| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uncles",
            |m: &Block| { &m.uncles },
            |m: &mut Block| { &mut m.uncles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "transaction_traces",
            |m: &Block| { &m.transaction_traces },
            |m: &mut Block| { &mut m.transaction_traces },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "balance_changes",
            |m: &Block| { &m.balance_changes },
            |m: &mut Block| { &mut m.balance_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "code_changes",
            |m: &Block| { &m.code_changes },
            |m: &mut Block| { &mut m.code_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ver",
            |m: &Block| { &m.ver },
            |m: &mut Block| { &mut m.ver },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Block>(
            "Block",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Block {
    const NAME: &'static str = "Block";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.hash = is.read_bytes()?;
                },
                24 => {
                    self.number = is.read_uint64()?;
                },
                32 => {
                    self.size = is.read_uint64()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                50 => {
                    self.uncles.push(is.read_message()?);
                },
                82 => {
                    self.transaction_traces.push(is.read_message()?);
                },
                90 => {
                    self.balance_changes.push(is.read_message()?);
                },
                162 => {
                    self.code_changes.push(is.read_message()?);
                },
                8 => {
                    self.ver = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        if self.number != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.number);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.size);
        }
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.uncles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.transaction_traces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.balance_changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.code_changes {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.ver != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ver);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        if self.number != 0 {
            os.write_uint64(3, self.number)?;
        }
        if self.size != 0 {
            os.write_uint64(4, self.size)?;
        }
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.uncles {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.transaction_traces {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.balance_changes {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.code_changes {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        if self.ver != 0 {
            os.write_int32(1, self.ver)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Block {
        Block::new()
    }

    fn clear(&mut self) {
        self.hash.clear();
        self.number = 0;
        self.size = 0;
        self.header.clear();
        self.uncles.clear();
        self.transaction_traces.clear();
        self.balance_changes.clear();
        self.code_changes.clear();
        self.ver = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Block {
        static instance: Block = Block {
            hash: ::std::vec::Vec::new(),
            number: 0,
            size: 0,
            header: ::protobuf::MessageField::none(),
            uncles: ::std::vec::Vec::new(),
            transaction_traces: ::std::vec::Vec::new(),
            balance_changes: ::std::vec::Vec::new(),
            code_changes: ::std::vec::Vec::new(),
            ver: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Block {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Block").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.BlockHeader)
pub struct BlockHeader {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.parent_hash)
    pub parent_hash: ::std::vec::Vec<u8>,
    ///  Uncle hash of the block, some reference it as `sha3Uncles`, but `sha3`` is badly worded, so we prefer `uncle_hash`, also
    ///  referred as `ommers` in EIP specification.
    ///
    ///  If the Block containing this `BlockHeader` has been produced using the Proof of Stake
    ///  consensus algorithm, this field will actually be constant and set to `0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347`.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.uncle_hash)
    pub uncle_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.coinbase)
    pub coinbase: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.state_root)
    pub state_root: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.transactions_root)
    pub transactions_root: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.receipt_root)
    pub receipt_root: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.logs_bloom)
    pub logs_bloom: ::std::vec::Vec<u8>,
    ///  Difficulty is the difficulty of the Proof of Work algorithm that was required to compute a solution.
    ///
    ///  If the Block containing this `BlockHeader` has been produced using the Proof of Stake
    ///  consensus algorithm, this field will actually be constant and set to `0x00`.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.difficulty)
    pub difficulty: ::protobuf::MessageField<BigInt>,
    ///  TotalDifficulty is the sum of all previous blocks difficulty including this block difficulty.
    ///
    ///  If the Block containing this `BlockHeader` has been produced using the Proof of Stake
    ///  consensus algorithm, this field will actually be constant and set to the terminal total difficulty
    ///  that was required to transition to Proof of Stake algorithm, which varies per network. It is set to
    ///  58 750 000 000 000 000 000 000 on Ethereum Mainnet and to 10 790 000 on Ethereum Testnet Goerli.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.total_difficulty)
    pub total_difficulty: ::protobuf::MessageField<BigInt>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.number)
    pub number: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.gas_limit)
    pub gas_limit: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.gas_used)
    pub gas_used: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.timestamp)
    pub timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  ExtraData is free-form bytes included in the block by the "miner". While on Yellow paper of
    ///  Ethereum this value is maxed to 32 bytes, other consensus algorithm like Clique and some other
    ///  forks are using bigger values to carry special consensus data.
    ///
    ///  If the Block containing this `BlockHeader` has been produced using the Proof of Stake
    ///  consensus algorithm, this field is strictly enforced to be <= 32 bytes.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.extra_data)
    pub extra_data: ::std::vec::Vec<u8>,
    ///  MixHash is used to prove, when combined with the `nonce` that sufficient amount of computation has been
    ///  achieved and that the solution found is valid.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.mix_hash)
    pub mix_hash: ::std::vec::Vec<u8>,
    ///  Nonce is used to prove, when combined with the `mix_hash` that sufficient amount of computation has been
    ///  achieved and that the solution found is valid.
    ///
    ///  If the Block containing this `BlockHeader` has been produced using the Proof of Stake
    ///  consensus algorithm, this field will actually be constant and set to `0`.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.nonce)
    pub nonce: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.hash)
    pub hash: ::std::vec::Vec<u8>,
    ///  Base fee per gas according to EIP-1559 (e.g. London Fork) rules, only set if London is present/active on the chain.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.base_fee_per_gas)
    pub base_fee_per_gas: ::protobuf::MessageField<BigInt>,
    ///  Withdrawals root hash according to EIP-4895 (e.g. Shangai Fork) rules, only set if Shangai is present/active on the chain.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.withdrawals_root)
    pub withdrawals_root: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockHeader.tx_dependency)
    pub tx_dependency: ::protobuf::MessageField<Uint64NestedArray>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.BlockHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockHeader {
    fn default() -> &'a BlockHeader {
        <BlockHeader as ::protobuf::Message>::default_instance()
    }
}

impl BlockHeader {
    pub fn new() -> BlockHeader {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parent_hash",
            |m: &BlockHeader| { &m.parent_hash },
            |m: &mut BlockHeader| { &mut m.parent_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uncle_hash",
            |m: &BlockHeader| { &m.uncle_hash },
            |m: &mut BlockHeader| { &mut m.uncle_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "coinbase",
            |m: &BlockHeader| { &m.coinbase },
            |m: &mut BlockHeader| { &mut m.coinbase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_root",
            |m: &BlockHeader| { &m.state_root },
            |m: &mut BlockHeader| { &mut m.state_root },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transactions_root",
            |m: &BlockHeader| { &m.transactions_root },
            |m: &mut BlockHeader| { &mut m.transactions_root },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "receipt_root",
            |m: &BlockHeader| { &m.receipt_root },
            |m: &mut BlockHeader| { &mut m.receipt_root },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "logs_bloom",
            |m: &BlockHeader| { &m.logs_bloom },
            |m: &mut BlockHeader| { &mut m.logs_bloom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "difficulty",
            |m: &BlockHeader| { &m.difficulty },
            |m: &mut BlockHeader| { &mut m.difficulty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "total_difficulty",
            |m: &BlockHeader| { &m.total_difficulty },
            |m: &mut BlockHeader| { &mut m.total_difficulty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "number",
            |m: &BlockHeader| { &m.number },
            |m: &mut BlockHeader| { &mut m.number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_limit",
            |m: &BlockHeader| { &m.gas_limit },
            |m: &mut BlockHeader| { &mut m.gas_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_used",
            |m: &BlockHeader| { &m.gas_used },
            |m: &mut BlockHeader| { &mut m.gas_used },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "timestamp",
            |m: &BlockHeader| { &m.timestamp },
            |m: &mut BlockHeader| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "extra_data",
            |m: &BlockHeader| { &m.extra_data },
            |m: &mut BlockHeader| { &mut m.extra_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mix_hash",
            |m: &BlockHeader| { &m.mix_hash },
            |m: &mut BlockHeader| { &mut m.mix_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nonce",
            |m: &BlockHeader| { &m.nonce },
            |m: &mut BlockHeader| { &mut m.nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &BlockHeader| { &m.hash },
            |m: &mut BlockHeader| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "base_fee_per_gas",
            |m: &BlockHeader| { &m.base_fee_per_gas },
            |m: &mut BlockHeader| { &mut m.base_fee_per_gas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "withdrawals_root",
            |m: &BlockHeader| { &m.withdrawals_root },
            |m: &mut BlockHeader| { &mut m.withdrawals_root },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Uint64NestedArray>(
            "tx_dependency",
            |m: &BlockHeader| { &m.tx_dependency },
            |m: &mut BlockHeader| { &mut m.tx_dependency },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockHeader>(
            "BlockHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockHeader {
    const NAME: &'static str = "BlockHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.parent_hash = is.read_bytes()?;
                },
                18 => {
                    self.uncle_hash = is.read_bytes()?;
                },
                26 => {
                    self.coinbase = is.read_bytes()?;
                },
                34 => {
                    self.state_root = is.read_bytes()?;
                },
                42 => {
                    self.transactions_root = is.read_bytes()?;
                },
                50 => {
                    self.receipt_root = is.read_bytes()?;
                },
                58 => {
                    self.logs_bloom = is.read_bytes()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.difficulty)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.total_difficulty)?;
                },
                72 => {
                    self.number = is.read_uint64()?;
                },
                80 => {
                    self.gas_limit = is.read_uint64()?;
                },
                88 => {
                    self.gas_used = is.read_uint64()?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestamp)?;
                },
                106 => {
                    self.extra_data = is.read_bytes()?;
                },
                114 => {
                    self.mix_hash = is.read_bytes()?;
                },
                120 => {
                    self.nonce = is.read_uint64()?;
                },
                130 => {
                    self.hash = is.read_bytes()?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base_fee_per_gas)?;
                },
                154 => {
                    self.withdrawals_root = is.read_bytes()?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tx_dependency)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.parent_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.parent_hash);
        }
        if !self.uncle_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.uncle_hash);
        }
        if !self.coinbase.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.coinbase);
        }
        if !self.state_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.state_root);
        }
        if !self.transactions_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.transactions_root);
        }
        if !self.receipt_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.receipt_root);
        }
        if !self.logs_bloom.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.logs_bloom);
        }
        if let Some(v) = self.difficulty.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.total_difficulty.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.number != 0 {
            my_size += ::protobuf::rt::uint64_size(9, self.number);
        }
        if self.gas_limit != 0 {
            my_size += ::protobuf::rt::uint64_size(10, self.gas_limit);
        }
        if self.gas_used != 0 {
            my_size += ::protobuf::rt::uint64_size(11, self.gas_used);
        }
        if let Some(v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.extra_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.extra_data);
        }
        if !self.mix_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(14, &self.mix_hash);
        }
        if self.nonce != 0 {
            my_size += ::protobuf::rt::uint64_size(15, self.nonce);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(16, &self.hash);
        }
        if let Some(v) = self.base_fee_per_gas.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.withdrawals_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(19, &self.withdrawals_root);
        }
        if let Some(v) = self.tx_dependency.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.parent_hash.is_empty() {
            os.write_bytes(1, &self.parent_hash)?;
        }
        if !self.uncle_hash.is_empty() {
            os.write_bytes(2, &self.uncle_hash)?;
        }
        if !self.coinbase.is_empty() {
            os.write_bytes(3, &self.coinbase)?;
        }
        if !self.state_root.is_empty() {
            os.write_bytes(4, &self.state_root)?;
        }
        if !self.transactions_root.is_empty() {
            os.write_bytes(5, &self.transactions_root)?;
        }
        if !self.receipt_root.is_empty() {
            os.write_bytes(6, &self.receipt_root)?;
        }
        if !self.logs_bloom.is_empty() {
            os.write_bytes(7, &self.logs_bloom)?;
        }
        if let Some(v) = self.difficulty.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.total_difficulty.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if self.number != 0 {
            os.write_uint64(9, self.number)?;
        }
        if self.gas_limit != 0 {
            os.write_uint64(10, self.gas_limit)?;
        }
        if self.gas_used != 0 {
            os.write_uint64(11, self.gas_used)?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if !self.extra_data.is_empty() {
            os.write_bytes(13, &self.extra_data)?;
        }
        if !self.mix_hash.is_empty() {
            os.write_bytes(14, &self.mix_hash)?;
        }
        if self.nonce != 0 {
            os.write_uint64(15, self.nonce)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(16, &self.hash)?;
        }
        if let Some(v) = self.base_fee_per_gas.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if !self.withdrawals_root.is_empty() {
            os.write_bytes(19, &self.withdrawals_root)?;
        }
        if let Some(v) = self.tx_dependency.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockHeader {
        BlockHeader::new()
    }

    fn clear(&mut self) {
        self.parent_hash.clear();
        self.uncle_hash.clear();
        self.coinbase.clear();
        self.state_root.clear();
        self.transactions_root.clear();
        self.receipt_root.clear();
        self.logs_bloom.clear();
        self.difficulty.clear();
        self.total_difficulty.clear();
        self.number = 0;
        self.gas_limit = 0;
        self.gas_used = 0;
        self.timestamp.clear();
        self.extra_data.clear();
        self.mix_hash.clear();
        self.nonce = 0;
        self.hash.clear();
        self.base_fee_per_gas.clear();
        self.withdrawals_root.clear();
        self.tx_dependency.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockHeader {
        static instance: BlockHeader = BlockHeader {
            parent_hash: ::std::vec::Vec::new(),
            uncle_hash: ::std::vec::Vec::new(),
            coinbase: ::std::vec::Vec::new(),
            state_root: ::std::vec::Vec::new(),
            transactions_root: ::std::vec::Vec::new(),
            receipt_root: ::std::vec::Vec::new(),
            logs_bloom: ::std::vec::Vec::new(),
            difficulty: ::protobuf::MessageField::none(),
            total_difficulty: ::protobuf::MessageField::none(),
            number: 0,
            gas_limit: 0,
            gas_used: 0,
            timestamp: ::protobuf::MessageField::none(),
            extra_data: ::std::vec::Vec::new(),
            mix_hash: ::std::vec::Vec::new(),
            nonce: 0,
            hash: ::std::vec::Vec::new(),
            base_fee_per_gas: ::protobuf::MessageField::none(),
            withdrawals_root: ::std::vec::Vec::new(),
            tx_dependency: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.Uint64NestedArray)
pub struct Uint64NestedArray {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Uint64NestedArray.val)
    pub val: ::std::vec::Vec<Uint64Array>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.Uint64NestedArray.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Uint64NestedArray {
    fn default() -> &'a Uint64NestedArray {
        <Uint64NestedArray as ::protobuf::Message>::default_instance()
    }
}

impl Uint64NestedArray {
    pub fn new() -> Uint64NestedArray {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "val",
            |m: &Uint64NestedArray| { &m.val },
            |m: &mut Uint64NestedArray| { &mut m.val },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Uint64NestedArray>(
            "Uint64NestedArray",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Uint64NestedArray {
    const NAME: &'static str = "Uint64NestedArray";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.val.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.val {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.val {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Uint64NestedArray {
        Uint64NestedArray::new()
    }

    fn clear(&mut self) {
        self.val.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Uint64NestedArray {
        static instance: Uint64NestedArray = Uint64NestedArray {
            val: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Uint64NestedArray {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Uint64NestedArray").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Uint64NestedArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Uint64NestedArray {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.Uint64Array)
pub struct Uint64Array {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Uint64Array.val)
    pub val: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.Uint64Array.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Uint64Array {
    fn default() -> &'a Uint64Array {
        <Uint64Array as ::protobuf::Message>::default_instance()
    }
}

impl Uint64Array {
    pub fn new() -> Uint64Array {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "val",
            |m: &Uint64Array| { &m.val },
            |m: &mut Uint64Array| { &mut m.val },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Uint64Array>(
            "Uint64Array",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Uint64Array {
    const NAME: &'static str = "Uint64Array";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.val)?;
                },
                8 => {
                    self.val.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.val {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.val {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Uint64Array {
        Uint64Array::new()
    }

    fn clear(&mut self) {
        self.val.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Uint64Array {
        static instance: Uint64Array = Uint64Array {
            val: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Uint64Array {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Uint64Array").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Uint64Array {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Uint64Array {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.BigInt)
pub struct BigInt {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BigInt.bytes)
    pub bytes: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.BigInt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BigInt {
    fn default() -> &'a BigInt {
        <BigInt as ::protobuf::Message>::default_instance()
    }
}

impl BigInt {
    pub fn new() -> BigInt {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bytes",
            |m: &BigInt| { &m.bytes },
            |m: &mut BigInt| { &mut m.bytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BigInt>(
            "BigInt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BigInt {
    const NAME: &'static str = "BigInt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bytes = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.bytes.is_empty() {
            os.write_bytes(1, &self.bytes)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BigInt {
        BigInt::new()
    }

    fn clear(&mut self) {
        self.bytes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BigInt {
        static instance: BigInt = BigInt {
            bytes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BigInt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BigInt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BigInt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BigInt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.TransactionTrace)
pub struct TransactionTrace {
    // message fields
    ///  consensus
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.to)
    pub to: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.nonce)
    pub nonce: u64,
    ///  GasPrice represents the effective price that has been paid for each gas unit of this transaction. Over time, the
    ///  Ethereum rules changes regarding GasPrice field here. Before London fork, the GasPrice was always set to the
    ///  fixed gas price. After London fork, this value has different meaning depending on the transaction type (see `Type` field).
    ///
    ///  In cases where `TransactionTrace.Type == TRX_TYPE_LEGACY || TRX_TYPE_ACCESS_LIST`, then GasPrice has the same meaning
    ///  as before the London fork.
    ///
    ///  In cases where `TransactionTrace.Type == TRX_TYPE_DYNAMIC_FEE`, then GasPrice is the effective gas price paid
    ///  for the transaction which is equals to `BlockHeader.BaseFeePerGas + TransactionTrace.`
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.gas_price)
    pub gas_price: ::protobuf::MessageField<BigInt>,
    ///  GasLimit is the maximum of gas unit the sender of the transaction is willing to consume when perform the EVM
    ///  execution of the whole transaction
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.gas_limit)
    pub gas_limit: u64,
    ///  Value is the amount of Ether transferred as part of this transaction.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.value)
    pub value: ::protobuf::MessageField<BigInt>,
    ///  Input data the transaction will receive for execution of EVM.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.input)
    pub input: ::std::vec::Vec<u8>,
    ///  V is the recovery ID value for the signature Y point.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.v)
    pub v: ::std::vec::Vec<u8>,
    ///  R is the signature's X point on the elliptic curve (32 bytes).
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.r)
    pub r: ::std::vec::Vec<u8>,
    ///  S is the signature's Y point on the elliptic curve (32 bytes).
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.s)
    pub s: ::std::vec::Vec<u8>,
    ///  GasUsed is the total amount of gas unit used for the whole execution of the transaction.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.gas_used)
    pub gas_used: u64,
    ///  Type represents the Ethereum transaction type, available only since EIP-2718 & EIP-2930 activation which happened on Berlin fork.
    ///  The value is always set even for transaction before Berlin fork because those before the fork are still legacy transactions.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.type)
    pub type_: ::protobuf::EnumOrUnknown<transaction_trace::Type>,
    ///  AcccessList represents the storage access this transaction has agreed to do in which case those storage
    ///  access cost less gas unit per access.
    ///
    ///  This will is populated only if `TransactionTrace.Type == TRX_TYPE_ACCESS_LIST || TRX_TYPE_DYNAMIC_FEE` which
    ///  is possible only if Berlin (TRX_TYPE_ACCESS_LIST) nor London (TRX_TYPE_DYNAMIC_FEE) fork are active on the chain.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.access_list)
    pub access_list: ::std::vec::Vec<AccessTuple>,
    ///  MaxFeePerGas is the maximum fee per gas the user is willing to pay for the transaction gas used.
    ///
    ///  This will is populated only if `TransactionTrace.Type == TRX_TYPE_DYNAMIC_FEE` which is possible only
    ///  if Londong fork is active on the chain.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.max_fee_per_gas)
    pub max_fee_per_gas: ::protobuf::MessageField<BigInt>,
    ///  MaxPriorityFeePerGas is priority fee per gas the user to pay in extra to the miner on top of the block's
    ///  base fee.
    ///
    ///  This will is populated only if `TransactionTrace.Type == TRX_TYPE_DYNAMIC_FEE` which is possible only
    ///  if Londong fork is active on the chain.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.max_priority_fee_per_gas)
    pub max_priority_fee_per_gas: ::protobuf::MessageField<BigInt>,
    ///  meta
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.index)
    pub index: u32,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.hash)
    pub hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.from)
    pub from: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.return_data)
    pub return_data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.public_key)
    pub public_key: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.begin_ordinal)
    pub begin_ordinal: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.end_ordinal)
    pub end_ordinal: u64,
    ///  TransactionTraceStatus is the status of the transaction execution and will let you know if the transaction
    ///  was successful or not.
    ///
    ///  A successful transaction has been recorded to the blockchain's state for calls in it that were successful.
    ///  This means it's possible only a subset of the calls were properly recorded, refer to [calls[].state_reverted] field
    ///  to determine which calls were reverted.
    ///
    ///  A quirks of the Ethereum protocol is that a transaction `FAILED` or `REVERTED` still affects the blockchain's
    ///  state for **some** of the state changes. Indeed, in those cases, the transactions fees are still paid to the miner
    ///  which means there is a balance change for the transaction's emitter (e.g. `from`) to pay the gas fees, an optional
    ///  balance change for gas refunded to the transaction's emitter (e.g. `from`) and a balance change for the miner who
    ///  received the transaction fees. There is also a nonce change for the transaction's emitter (e.g. `from`).
    ///
    ///  This means that to properly record the state changes for a transaction, you need to conditionally procees the
    ///  transaction's status.
    ///
    ///  For a `SUCCEEDED` transaction, you iterate over the `calls` array and record the state changes for each call for
    ///  which `state_reverted == false` (if a transaction succeeded, the call at #0 will always `state_reverted == false`
    ///  because it aligns with the transaction).
    ///
    ///  For a `FAILED` or `REVERTED` transaction, you iterate over the root call (e.g. at #0, will always exist) for
    ///  balance changes you process those where `reason` is either `REASON_GAS_BUY`, `REASON_GAS_REFUND` or
    ///  `REASON_REWARD_TRANSACTION_FEE` and for nonce change, still on the root call, you pick the nonce change which the
    ///  smallest ordinal (if more than one).
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.status)
    pub status: ::protobuf::EnumOrUnknown<TransactionTraceStatus>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.receipt)
    pub receipt: ::protobuf::MessageField<TransactionReceipt>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTrace.calls)
    pub calls: ::std::vec::Vec<Call>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.TransactionTrace.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionTrace {
    fn default() -> &'a TransactionTrace {
        <TransactionTrace as ::protobuf::Message>::default_instance()
    }
}

impl TransactionTrace {
    pub fn new() -> TransactionTrace {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(24);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "to",
            |m: &TransactionTrace| { &m.to },
            |m: &mut TransactionTrace| { &mut m.to },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nonce",
            |m: &TransactionTrace| { &m.nonce },
            |m: &mut TransactionTrace| { &mut m.nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "gas_price",
            |m: &TransactionTrace| { &m.gas_price },
            |m: &mut TransactionTrace| { &mut m.gas_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_limit",
            |m: &TransactionTrace| { &m.gas_limit },
            |m: &mut TransactionTrace| { &mut m.gas_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "value",
            |m: &TransactionTrace| { &m.value },
            |m: &mut TransactionTrace| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input",
            |m: &TransactionTrace| { &m.input },
            |m: &mut TransactionTrace| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "v",
            |m: &TransactionTrace| { &m.v },
            |m: &mut TransactionTrace| { &mut m.v },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "r",
            |m: &TransactionTrace| { &m.r },
            |m: &mut TransactionTrace| { &mut m.r },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "s",
            |m: &TransactionTrace| { &m.s },
            |m: &mut TransactionTrace| { &mut m.s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_used",
            |m: &TransactionTrace| { &m.gas_used },
            |m: &mut TransactionTrace| { &mut m.gas_used },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &TransactionTrace| { &m.type_ },
            |m: &mut TransactionTrace| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "access_list",
            |m: &TransactionTrace| { &m.access_list },
            |m: &mut TransactionTrace| { &mut m.access_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "max_fee_per_gas",
            |m: &TransactionTrace| { &m.max_fee_per_gas },
            |m: &mut TransactionTrace| { &mut m.max_fee_per_gas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "max_priority_fee_per_gas",
            |m: &TransactionTrace| { &m.max_priority_fee_per_gas },
            |m: &mut TransactionTrace| { &mut m.max_priority_fee_per_gas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &TransactionTrace| { &m.index },
            |m: &mut TransactionTrace| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &TransactionTrace| { &m.hash },
            |m: &mut TransactionTrace| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "from",
            |m: &TransactionTrace| { &m.from },
            |m: &mut TransactionTrace| { &mut m.from },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "return_data",
            |m: &TransactionTrace| { &m.return_data },
            |m: &mut TransactionTrace| { &mut m.return_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "public_key",
            |m: &TransactionTrace| { &m.public_key },
            |m: &mut TransactionTrace| { &mut m.public_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "begin_ordinal",
            |m: &TransactionTrace| { &m.begin_ordinal },
            |m: &mut TransactionTrace| { &mut m.begin_ordinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end_ordinal",
            |m: &TransactionTrace| { &m.end_ordinal },
            |m: &mut TransactionTrace| { &mut m.end_ordinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &TransactionTrace| { &m.status },
            |m: &mut TransactionTrace| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TransactionReceipt>(
            "receipt",
            |m: &TransactionTrace| { &m.receipt },
            |m: &mut TransactionTrace| { &mut m.receipt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "calls",
            |m: &TransactionTrace| { &m.calls },
            |m: &mut TransactionTrace| { &mut m.calls },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionTrace>(
            "TransactionTrace",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionTrace {
    const NAME: &'static str = "TransactionTrace";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.to = is.read_bytes()?;
                },
                16 => {
                    self.nonce = is.read_uint64()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.gas_price)?;
                },
                32 => {
                    self.gas_limit = is.read_uint64()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                50 => {
                    self.input = is.read_bytes()?;
                },
                58 => {
                    self.v = is.read_bytes()?;
                },
                66 => {
                    self.r = is.read_bytes()?;
                },
                74 => {
                    self.s = is.read_bytes()?;
                },
                80 => {
                    self.gas_used = is.read_uint64()?;
                },
                96 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                114 => {
                    self.access_list.push(is.read_message()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.max_fee_per_gas)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.max_priority_fee_per_gas)?;
                },
                160 => {
                    self.index = is.read_uint32()?;
                },
                170 => {
                    self.hash = is.read_bytes()?;
                },
                178 => {
                    self.from = is.read_bytes()?;
                },
                186 => {
                    self.return_data = is.read_bytes()?;
                },
                194 => {
                    self.public_key = is.read_bytes()?;
                },
                200 => {
                    self.begin_ordinal = is.read_uint64()?;
                },
                208 => {
                    self.end_ordinal = is.read_uint64()?;
                },
                240 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                250 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.receipt)?;
                },
                258 => {
                    self.calls.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.to);
        }
        if self.nonce != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.nonce);
        }
        if let Some(v) = self.gas_price.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.gas_limit != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.gas_limit);
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.input.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.input);
        }
        if !self.v.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.v);
        }
        if !self.r.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.r);
        }
        if !self.s.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.s);
        }
        if self.gas_used != 0 {
            my_size += ::protobuf::rt::uint64_size(10, self.gas_used);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(transaction_trace::Type::TRX_TYPE_LEGACY) {
            my_size += ::protobuf::rt::int32_size(12, self.type_.value());
        }
        for value in &self.access_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.max_fee_per_gas.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.max_priority_fee_per_gas.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::uint32_size(20, self.index);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(21, &self.hash);
        }
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(22, &self.from);
        }
        if !self.return_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(23, &self.return_data);
        }
        if !self.public_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(24, &self.public_key);
        }
        if self.begin_ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(25, self.begin_ordinal);
        }
        if self.end_ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(26, self.end_ordinal);
        }
        if self.status != ::protobuf::EnumOrUnknown::new(TransactionTraceStatus::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(30, self.status.value());
        }
        if let Some(v) = self.receipt.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.calls {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.to.is_empty() {
            os.write_bytes(1, &self.to)?;
        }
        if self.nonce != 0 {
            os.write_uint64(2, self.nonce)?;
        }
        if let Some(v) = self.gas_price.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.gas_limit != 0 {
            os.write_uint64(4, self.gas_limit)?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if !self.input.is_empty() {
            os.write_bytes(6, &self.input)?;
        }
        if !self.v.is_empty() {
            os.write_bytes(7, &self.v)?;
        }
        if !self.r.is_empty() {
            os.write_bytes(8, &self.r)?;
        }
        if !self.s.is_empty() {
            os.write_bytes(9, &self.s)?;
        }
        if self.gas_used != 0 {
            os.write_uint64(10, self.gas_used)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(transaction_trace::Type::TRX_TYPE_LEGACY) {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        for v in &self.access_list {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        if let Some(v) = self.max_fee_per_gas.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.max_priority_fee_per_gas.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if self.index != 0 {
            os.write_uint32(20, self.index)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(21, &self.hash)?;
        }
        if !self.from.is_empty() {
            os.write_bytes(22, &self.from)?;
        }
        if !self.return_data.is_empty() {
            os.write_bytes(23, &self.return_data)?;
        }
        if !self.public_key.is_empty() {
            os.write_bytes(24, &self.public_key)?;
        }
        if self.begin_ordinal != 0 {
            os.write_uint64(25, self.begin_ordinal)?;
        }
        if self.end_ordinal != 0 {
            os.write_uint64(26, self.end_ordinal)?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(TransactionTraceStatus::UNKNOWN) {
            os.write_enum(30, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if let Some(v) = self.receipt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        for v in &self.calls {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionTrace {
        TransactionTrace::new()
    }

    fn clear(&mut self) {
        self.to.clear();
        self.nonce = 0;
        self.gas_price.clear();
        self.gas_limit = 0;
        self.value.clear();
        self.input.clear();
        self.v.clear();
        self.r.clear();
        self.s.clear();
        self.gas_used = 0;
        self.type_ = ::protobuf::EnumOrUnknown::new(transaction_trace::Type::TRX_TYPE_LEGACY);
        self.access_list.clear();
        self.max_fee_per_gas.clear();
        self.max_priority_fee_per_gas.clear();
        self.index = 0;
        self.hash.clear();
        self.from.clear();
        self.return_data.clear();
        self.public_key.clear();
        self.begin_ordinal = 0;
        self.end_ordinal = 0;
        self.status = ::protobuf::EnumOrUnknown::new(TransactionTraceStatus::UNKNOWN);
        self.receipt.clear();
        self.calls.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionTrace {
        static instance: TransactionTrace = TransactionTrace {
            to: ::std::vec::Vec::new(),
            nonce: 0,
            gas_price: ::protobuf::MessageField::none(),
            gas_limit: 0,
            value: ::protobuf::MessageField::none(),
            input: ::std::vec::Vec::new(),
            v: ::std::vec::Vec::new(),
            r: ::std::vec::Vec::new(),
            s: ::std::vec::Vec::new(),
            gas_used: 0,
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            access_list: ::std::vec::Vec::new(),
            max_fee_per_gas: ::protobuf::MessageField::none(),
            max_priority_fee_per_gas: ::protobuf::MessageField::none(),
            index: 0,
            hash: ::std::vec::Vec::new(),
            from: ::std::vec::Vec::new(),
            return_data: ::std::vec::Vec::new(),
            public_key: ::std::vec::Vec::new(),
            begin_ordinal: 0,
            end_ordinal: 0,
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            receipt: ::protobuf::MessageField::none(),
            calls: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionTrace {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionTrace").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionTrace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionTrace {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TransactionTrace`
pub mod transaction_trace {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:sf.ethereum.type.v2.TransactionTrace.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.TransactionTrace.Type.TRX_TYPE_LEGACY)
        TRX_TYPE_LEGACY = 0,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.TransactionTrace.Type.TRX_TYPE_ACCESS_LIST)
        TRX_TYPE_ACCESS_LIST = 1,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.TransactionTrace.Type.TRX_TYPE_DYNAMIC_FEE)
        TRX_TYPE_DYNAMIC_FEE = 2,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::TRX_TYPE_LEGACY),
                1 => ::std::option::Option::Some(Type::TRX_TYPE_ACCESS_LIST),
                2 => ::std::option::Option::Some(Type::TRX_TYPE_DYNAMIC_FEE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::TRX_TYPE_LEGACY,
            Type::TRX_TYPE_ACCESS_LIST,
            Type::TRX_TYPE_DYNAMIC_FEE,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TransactionTrace.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::TRX_TYPE_LEGACY
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("TransactionTrace.Type")
        }
    }
}

///  AccessTuple represents a list of storage keys for a given contract's address and is used
///  for AccessList construction.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.AccessTuple)
pub struct AccessTuple {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.AccessTuple.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.AccessTuple.storage_keys)
    pub storage_keys: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.AccessTuple.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccessTuple {
    fn default() -> &'a AccessTuple {
        <AccessTuple as ::protobuf::Message>::default_instance()
    }
}

impl AccessTuple {
    pub fn new() -> AccessTuple {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &AccessTuple| { &m.address },
            |m: &mut AccessTuple| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "storage_keys",
            |m: &AccessTuple| { &m.storage_keys },
            |m: &mut AccessTuple| { &mut m.storage_keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccessTuple>(
            "AccessTuple",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccessTuple {
    const NAME: &'static str = "AccessTuple";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                18 => {
                    self.storage_keys.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        for value in &self.storage_keys {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        for v in &self.storage_keys {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccessTuple {
        AccessTuple::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.storage_keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccessTuple {
        static instance: AccessTuple = AccessTuple {
            address: ::std::vec::Vec::new(),
            storage_keys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccessTuple {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccessTuple").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccessTuple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccessTuple {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.TransactionReceipt)
pub struct TransactionReceipt {
    // message fields
    ///  State root is an intermediate state_root hash, computed in-between transactions to make
    ///  **sure** you could build a proof and point to state in the middle of a block. Geth client
    ///  uses `PostState + root + PostStateOrStatus`` while Parity used `status_code, root...`` this piles
    ///  hardforks, see (read the EIPs first):
    ///  - https://github.com/ethereum/EIPs/blob/master/EIPS/eip-658.md
    ///
    ///  Moreover, the notion of `Outcome`` in parity, which segregates the two concepts, which are
    ///  stored in the same field `status_code`` can be computed based on such a hack of the `state_root`
    ///  field, following `EIP-658`.
    ///
    ///  Before Byzantinium hard fork, this field is always empty.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionReceipt.state_root)
    pub state_root: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionReceipt.cumulative_gas_used)
    pub cumulative_gas_used: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionReceipt.logs_bloom)
    pub logs_bloom: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionReceipt.logs)
    pub logs: ::std::vec::Vec<Log>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.TransactionReceipt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionReceipt {
    fn default() -> &'a TransactionReceipt {
        <TransactionReceipt as ::protobuf::Message>::default_instance()
    }
}

impl TransactionReceipt {
    pub fn new() -> TransactionReceipt {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_root",
            |m: &TransactionReceipt| { &m.state_root },
            |m: &mut TransactionReceipt| { &mut m.state_root },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cumulative_gas_used",
            |m: &TransactionReceipt| { &m.cumulative_gas_used },
            |m: &mut TransactionReceipt| { &mut m.cumulative_gas_used },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "logs_bloom",
            |m: &TransactionReceipt| { &m.logs_bloom },
            |m: &mut TransactionReceipt| { &mut m.logs_bloom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "logs",
            |m: &TransactionReceipt| { &m.logs },
            |m: &mut TransactionReceipt| { &mut m.logs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionReceipt>(
            "TransactionReceipt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionReceipt {
    const NAME: &'static str = "TransactionReceipt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.state_root = is.read_bytes()?;
                },
                16 => {
                    self.cumulative_gas_used = is.read_uint64()?;
                },
                26 => {
                    self.logs_bloom = is.read_bytes()?;
                },
                34 => {
                    self.logs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.state_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.state_root);
        }
        if self.cumulative_gas_used != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.cumulative_gas_used);
        }
        if !self.logs_bloom.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.logs_bloom);
        }
        for value in &self.logs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.state_root.is_empty() {
            os.write_bytes(1, &self.state_root)?;
        }
        if self.cumulative_gas_used != 0 {
            os.write_uint64(2, self.cumulative_gas_used)?;
        }
        if !self.logs_bloom.is_empty() {
            os.write_bytes(3, &self.logs_bloom)?;
        }
        for v in &self.logs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionReceipt {
        TransactionReceipt::new()
    }

    fn clear(&mut self) {
        self.state_root.clear();
        self.cumulative_gas_used = 0;
        self.logs_bloom.clear();
        self.logs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionReceipt {
        static instance: TransactionReceipt = TransactionReceipt {
            state_root: ::std::vec::Vec::new(),
            cumulative_gas_used: 0,
            logs_bloom: ::std::vec::Vec::new(),
            logs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionReceipt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionReceipt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionReceipt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionReceipt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.Log)
pub struct Log {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Log.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Log.topics)
    pub topics: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Log.data)
    pub data: ::std::vec::Vec<u8>,
    ///  Index is the index of the log relative to the transaction. This index
    ///  is always populated regardless of the state revertion of the the call
    ///  that emitted this log.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Log.index)
    pub index: u32,
    ///  BlockIndex represents the index of the log relative to the Block.
    ///
    ///  An **important** notice is that this field will be 0 when the call
    ///  that emitted the log has been reverted by the chain.
    ///
    ///  Currently, there is two locations where a Log can be obtained:
    ///  - block.transaction_traces[].receipt.logs[]
    ///  - block.transaction_traces[].calls[].logs[]
    ///
    ///  In the `receipt` case, the logs will be populated only when the call
    ///  that emitted them has not been reverted by the chain and when in this
    ///  position, the `blockIndex` is always populated correctly.
    ///
    ///  In the case of `calls` case, for `call` where `stateReverted == true`,
    ///  the `blockIndex` value will always be 0.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Log.blockIndex)
    pub blockIndex: u32,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Log.ordinal)
    pub ordinal: u64,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.Log.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Log {
    fn default() -> &'a Log {
        <Log as ::protobuf::Message>::default_instance()
    }
}

impl Log {
    pub fn new() -> Log {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &Log| { &m.address },
            |m: &mut Log| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "topics",
            |m: &Log| { &m.topics },
            |m: &mut Log| { &mut m.topics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &Log| { &m.data },
            |m: &mut Log| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &Log| { &m.index },
            |m: &mut Log| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "blockIndex",
            |m: &Log| { &m.blockIndex },
            |m: &mut Log| { &mut m.blockIndex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ordinal",
            |m: &Log| { &m.ordinal },
            |m: &mut Log| { &mut m.ordinal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Log>(
            "Log",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Log {
    const NAME: &'static str = "Log";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                18 => {
                    self.topics.push(is.read_bytes()?);
                },
                26 => {
                    self.data = is.read_bytes()?;
                },
                32 => {
                    self.index = is.read_uint32()?;
                },
                48 => {
                    self.blockIndex = is.read_uint32()?;
                },
                56 => {
                    self.ordinal = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        for value in &self.topics {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.index);
        }
        if self.blockIndex != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.blockIndex);
        }
        if self.ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(7, self.ordinal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        for v in &self.topics {
            os.write_bytes(2, &v)?;
        };
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        if self.index != 0 {
            os.write_uint32(4, self.index)?;
        }
        if self.blockIndex != 0 {
            os.write_uint32(6, self.blockIndex)?;
        }
        if self.ordinal != 0 {
            os.write_uint64(7, self.ordinal)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Log {
        Log::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.topics.clear();
        self.data.clear();
        self.index = 0;
        self.blockIndex = 0;
        self.ordinal = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Log {
        static instance: Log = Log {
            address: ::std::vec::Vec::new(),
            topics: ::std::vec::Vec::new(),
            data: ::std::vec::Vec::new(),
            index: 0,
            blockIndex: 0,
            ordinal: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Log {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Log").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Log {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Log {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.Call)
pub struct Call {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.index)
    pub index: u32,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.parent_index)
    pub parent_index: u32,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.depth)
    pub depth: u32,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.call_type)
    pub call_type: ::protobuf::EnumOrUnknown<CallType>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.caller)
    pub caller: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.value)
    pub value: ::protobuf::MessageField<BigInt>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.gas_limit)
    pub gas_limit: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.gas_consumed)
    pub gas_consumed: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.return_data)
    pub return_data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.input)
    pub input: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.executed_code)
    pub executed_code: bool,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.suicide)
    pub suicide: bool,
    ///  hex representation of the hash -> preimage 
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.keccak_preimages)
    pub keccak_preimages: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.storage_changes)
    pub storage_changes: ::std::vec::Vec<StorageChange>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.balance_changes)
    pub balance_changes: ::std::vec::Vec<BalanceChange>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.nonce_changes)
    pub nonce_changes: ::std::vec::Vec<NonceChange>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.logs)
    pub logs: ::std::vec::Vec<Log>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.code_changes)
    pub code_changes: ::std::vec::Vec<CodeChange>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.gas_changes)
    pub gas_changes: ::std::vec::Vec<GasChange>,
    ///  In Ethereum, a call can be either:
    ///  - Successfull, execution passes without any problem encountered
    ///  - Failed, execution failed, and remaining gas should be consumed
    ///  - Reverted, execution failed, but only gas consumed so far is billed, remaining gas is refunded
    ///
    ///  When a call is either `failed` or `reverted`, the `status_failed` field
    ///  below is set to `true`. If the status is `reverted`, then both `status_failed`
    ///  and `status_reverted` are going to be set to `true`.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.status_failed)
    pub status_failed: bool,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.status_reverted)
    pub status_reverted: bool,
    ///  Populated when a call either failed or reverted, so when `status_failed == true`,
    ///  see above for details about those flags.
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.failure_reason)
    pub failure_reason: ::std::string::String,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.state_reverted)
    pub state_reverted: bool,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.begin_ordinal)
    pub begin_ordinal: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.end_ordinal)
    pub end_ordinal: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.Call.account_creations)
    pub account_creations: ::std::vec::Vec<AccountCreation>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.Call.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Call {
    fn default() -> &'a Call {
        <Call as ::protobuf::Message>::default_instance()
    }
}

impl Call {
    pub fn new() -> Call {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(27);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &Call| { &m.index },
            |m: &mut Call| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parent_index",
            |m: &Call| { &m.parent_index },
            |m: &mut Call| { &mut m.parent_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "depth",
            |m: &Call| { &m.depth },
            |m: &mut Call| { &mut m.depth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "call_type",
            |m: &Call| { &m.call_type },
            |m: &mut Call| { &mut m.call_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "caller",
            |m: &Call| { &m.caller },
            |m: &mut Call| { &mut m.caller },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &Call| { &m.address },
            |m: &mut Call| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "value",
            |m: &Call| { &m.value },
            |m: &mut Call| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_limit",
            |m: &Call| { &m.gas_limit },
            |m: &mut Call| { &mut m.gas_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_consumed",
            |m: &Call| { &m.gas_consumed },
            |m: &mut Call| { &mut m.gas_consumed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "return_data",
            |m: &Call| { &m.return_data },
            |m: &mut Call| { &mut m.return_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input",
            |m: &Call| { &m.input },
            |m: &mut Call| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "executed_code",
            |m: &Call| { &m.executed_code },
            |m: &mut Call| { &mut m.executed_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "suicide",
            |m: &Call| { &m.suicide },
            |m: &mut Call| { &mut m.suicide },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "keccak_preimages",
            |m: &Call| { &m.keccak_preimages },
            |m: &mut Call| { &mut m.keccak_preimages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "storage_changes",
            |m: &Call| { &m.storage_changes },
            |m: &mut Call| { &mut m.storage_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "balance_changes",
            |m: &Call| { &m.balance_changes },
            |m: &mut Call| { &mut m.balance_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nonce_changes",
            |m: &Call| { &m.nonce_changes },
            |m: &mut Call| { &mut m.nonce_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "logs",
            |m: &Call| { &m.logs },
            |m: &mut Call| { &mut m.logs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "code_changes",
            |m: &Call| { &m.code_changes },
            |m: &mut Call| { &mut m.code_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gas_changes",
            |m: &Call| { &m.gas_changes },
            |m: &mut Call| { &mut m.gas_changes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status_failed",
            |m: &Call| { &m.status_failed },
            |m: &mut Call| { &mut m.status_failed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status_reverted",
            |m: &Call| { &m.status_reverted },
            |m: &mut Call| { &mut m.status_reverted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "failure_reason",
            |m: &Call| { &m.failure_reason },
            |m: &mut Call| { &mut m.failure_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_reverted",
            |m: &Call| { &m.state_reverted },
            |m: &mut Call| { &mut m.state_reverted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "begin_ordinal",
            |m: &Call| { &m.begin_ordinal },
            |m: &mut Call| { &mut m.begin_ordinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end_ordinal",
            |m: &Call| { &m.end_ordinal },
            |m: &mut Call| { &mut m.end_ordinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_creations",
            |m: &Call| { &m.account_creations },
            |m: &mut Call| { &mut m.account_creations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Call>(
            "Call",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Call {
    const NAME: &'static str = "Call";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = is.read_uint32()?;
                },
                16 => {
                    self.parent_index = is.read_uint32()?;
                },
                24 => {
                    self.depth = is.read_uint32()?;
                },
                32 => {
                    self.call_type = is.read_enum_or_unknown()?;
                },
                42 => {
                    self.caller = is.read_bytes()?;
                },
                50 => {
                    self.address = is.read_bytes()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                64 => {
                    self.gas_limit = is.read_uint64()?;
                },
                72 => {
                    self.gas_consumed = is.read_uint64()?;
                },
                106 => {
                    self.return_data = is.read_bytes()?;
                },
                114 => {
                    self.input = is.read_bytes()?;
                },
                120 => {
                    self.executed_code = is.read_bool()?;
                },
                128 => {
                    self.suicide = is.read_bool()?;
                },
                162 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.keccak_preimages.insert(key, value);
                },
                170 => {
                    self.storage_changes.push(is.read_message()?);
                },
                178 => {
                    self.balance_changes.push(is.read_message()?);
                },
                194 => {
                    self.nonce_changes.push(is.read_message()?);
                },
                202 => {
                    self.logs.push(is.read_message()?);
                },
                210 => {
                    self.code_changes.push(is.read_message()?);
                },
                226 => {
                    self.gas_changes.push(is.read_message()?);
                },
                80 => {
                    self.status_failed = is.read_bool()?;
                },
                96 => {
                    self.status_reverted = is.read_bool()?;
                },
                90 => {
                    self.failure_reason = is.read_string()?;
                },
                240 => {
                    self.state_reverted = is.read_bool()?;
                },
                248 => {
                    self.begin_ordinal = is.read_uint64()?;
                },
                256 => {
                    self.end_ordinal = is.read_uint64()?;
                },
                266 => {
                    self.account_creations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.index);
        }
        if self.parent_index != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.parent_index);
        }
        if self.depth != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.depth);
        }
        if self.call_type != ::protobuf::EnumOrUnknown::new(CallType::UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(4, self.call_type.value());
        }
        if !self.caller.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.caller);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.address);
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.gas_limit != 0 {
            my_size += ::protobuf::rt::uint64_size(8, self.gas_limit);
        }
        if self.gas_consumed != 0 {
            my_size += ::protobuf::rt::uint64_size(9, self.gas_consumed);
        }
        if !self.return_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.return_data);
        }
        if !self.input.is_empty() {
            my_size += ::protobuf::rt::bytes_size(14, &self.input);
        }
        if self.executed_code != false {
            my_size += 1 + 1;
        }
        if self.suicide != false {
            my_size += 2 + 1;
        }
        for (k, v) in &self.keccak_preimages {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.storage_changes {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.balance_changes {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.nonce_changes {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.logs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.code_changes {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.gas_changes {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.status_failed != false {
            my_size += 1 + 1;
        }
        if self.status_reverted != false {
            my_size += 1 + 1;
        }
        if !self.failure_reason.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.failure_reason);
        }
        if self.state_reverted != false {
            my_size += 2 + 1;
        }
        if self.begin_ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(31, self.begin_ordinal);
        }
        if self.end_ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(32, self.end_ordinal);
        }
        for value in &self.account_creations {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.index != 0 {
            os.write_uint32(1, self.index)?;
        }
        if self.parent_index != 0 {
            os.write_uint32(2, self.parent_index)?;
        }
        if self.depth != 0 {
            os.write_uint32(3, self.depth)?;
        }
        if self.call_type != ::protobuf::EnumOrUnknown::new(CallType::UNSPECIFIED) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.call_type))?;
        }
        if !self.caller.is_empty() {
            os.write_bytes(5, &self.caller)?;
        }
        if !self.address.is_empty() {
            os.write_bytes(6, &self.address)?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if self.gas_limit != 0 {
            os.write_uint64(8, self.gas_limit)?;
        }
        if self.gas_consumed != 0 {
            os.write_uint64(9, self.gas_consumed)?;
        }
        if !self.return_data.is_empty() {
            os.write_bytes(13, &self.return_data)?;
        }
        if !self.input.is_empty() {
            os.write_bytes(14, &self.input)?;
        }
        if self.executed_code != false {
            os.write_bool(15, self.executed_code)?;
        }
        if self.suicide != false {
            os.write_bool(16, self.suicide)?;
        }
        for (k, v) in &self.keccak_preimages {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(162)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for v in &self.storage_changes {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        };
        for v in &self.balance_changes {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        };
        for v in &self.nonce_changes {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        };
        for v in &self.logs {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        };
        for v in &self.code_changes {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        };
        for v in &self.gas_changes {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        };
        if self.status_failed != false {
            os.write_bool(10, self.status_failed)?;
        }
        if self.status_reverted != false {
            os.write_bool(12, self.status_reverted)?;
        }
        if !self.failure_reason.is_empty() {
            os.write_string(11, &self.failure_reason)?;
        }
        if self.state_reverted != false {
            os.write_bool(30, self.state_reverted)?;
        }
        if self.begin_ordinal != 0 {
            os.write_uint64(31, self.begin_ordinal)?;
        }
        if self.end_ordinal != 0 {
            os.write_uint64(32, self.end_ordinal)?;
        }
        for v in &self.account_creations {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Call {
        Call::new()
    }

    fn clear(&mut self) {
        self.index = 0;
        self.parent_index = 0;
        self.depth = 0;
        self.call_type = ::protobuf::EnumOrUnknown::new(CallType::UNSPECIFIED);
        self.caller.clear();
        self.address.clear();
        self.value.clear();
        self.gas_limit = 0;
        self.gas_consumed = 0;
        self.return_data.clear();
        self.input.clear();
        self.executed_code = false;
        self.suicide = false;
        self.keccak_preimages.clear();
        self.storage_changes.clear();
        self.balance_changes.clear();
        self.nonce_changes.clear();
        self.logs.clear();
        self.code_changes.clear();
        self.gas_changes.clear();
        self.status_failed = false;
        self.status_reverted = false;
        self.failure_reason.clear();
        self.state_reverted = false;
        self.begin_ordinal = 0;
        self.end_ordinal = 0;
        self.account_creations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Call {
        static instance: ::protobuf::rt::Lazy<Call> = ::protobuf::rt::Lazy::new();
        instance.get(Call::new)
    }
}

impl ::protobuf::MessageFull for Call {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Call").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Call {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Call {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.StorageChange)
pub struct StorageChange {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.StorageChange.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.StorageChange.key)
    pub key: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.StorageChange.old_value)
    pub old_value: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.StorageChange.new_value)
    pub new_value: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.StorageChange.ordinal)
    pub ordinal: u64,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.StorageChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StorageChange {
    fn default() -> &'a StorageChange {
        <StorageChange as ::protobuf::Message>::default_instance()
    }
}

impl StorageChange {
    pub fn new() -> StorageChange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &StorageChange| { &m.address },
            |m: &mut StorageChange| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &StorageChange| { &m.key },
            |m: &mut StorageChange| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "old_value",
            |m: &StorageChange| { &m.old_value },
            |m: &mut StorageChange| { &mut m.old_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_value",
            |m: &StorageChange| { &m.new_value },
            |m: &mut StorageChange| { &mut m.new_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ordinal",
            |m: &StorageChange| { &m.ordinal },
            |m: &mut StorageChange| { &mut m.ordinal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StorageChange>(
            "StorageChange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StorageChange {
    const NAME: &'static str = "StorageChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                18 => {
                    self.key = is.read_bytes()?;
                },
                26 => {
                    self.old_value = is.read_bytes()?;
                },
                34 => {
                    self.new_value = is.read_bytes()?;
                },
                40 => {
                    self.ordinal = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.key);
        }
        if !self.old_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.old_value);
        }
        if !self.new_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.new_value);
        }
        if self.ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.ordinal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(2, &self.key)?;
        }
        if !self.old_value.is_empty() {
            os.write_bytes(3, &self.old_value)?;
        }
        if !self.new_value.is_empty() {
            os.write_bytes(4, &self.new_value)?;
        }
        if self.ordinal != 0 {
            os.write_uint64(5, self.ordinal)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StorageChange {
        StorageChange::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.key.clear();
        self.old_value.clear();
        self.new_value.clear();
        self.ordinal = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StorageChange {
        static instance: StorageChange = StorageChange {
            address: ::std::vec::Vec::new(),
            key: ::std::vec::Vec::new(),
            old_value: ::std::vec::Vec::new(),
            new_value: ::std::vec::Vec::new(),
            ordinal: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StorageChange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StorageChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StorageChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageChange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.BalanceChange)
pub struct BalanceChange {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BalanceChange.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BalanceChange.old_value)
    pub old_value: ::protobuf::MessageField<BigInt>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BalanceChange.new_value)
    pub new_value: ::protobuf::MessageField<BigInt>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BalanceChange.reason)
    pub reason: ::protobuf::EnumOrUnknown<balance_change::Reason>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BalanceChange.ordinal)
    pub ordinal: u64,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.BalanceChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BalanceChange {
    fn default() -> &'a BalanceChange {
        <BalanceChange as ::protobuf::Message>::default_instance()
    }
}

impl BalanceChange {
    pub fn new() -> BalanceChange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BalanceChange| { &m.address },
            |m: &mut BalanceChange| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "old_value",
            |m: &BalanceChange| { &m.old_value },
            |m: &mut BalanceChange| { &mut m.old_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BigInt>(
            "new_value",
            |m: &BalanceChange| { &m.new_value },
            |m: &mut BalanceChange| { &mut m.new_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reason",
            |m: &BalanceChange| { &m.reason },
            |m: &mut BalanceChange| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ordinal",
            |m: &BalanceChange| { &m.ordinal },
            |m: &mut BalanceChange| { &mut m.ordinal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BalanceChange>(
            "BalanceChange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BalanceChange {
    const NAME: &'static str = "BalanceChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.old_value)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.new_value)?;
                },
                32 => {
                    self.reason = is.read_enum_or_unknown()?;
                },
                40 => {
                    self.ordinal = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if let Some(v) = self.old_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.new_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.reason != ::protobuf::EnumOrUnknown::new(balance_change::Reason::REASON_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(4, self.reason.value());
        }
        if self.ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.ordinal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if let Some(v) = self.old_value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.new_value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.reason != ::protobuf::EnumOrUnknown::new(balance_change::Reason::REASON_UNKNOWN) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.reason))?;
        }
        if self.ordinal != 0 {
            os.write_uint64(5, self.ordinal)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BalanceChange {
        BalanceChange::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.old_value.clear();
        self.new_value.clear();
        self.reason = ::protobuf::EnumOrUnknown::new(balance_change::Reason::REASON_UNKNOWN);
        self.ordinal = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BalanceChange {
        static instance: BalanceChange = BalanceChange {
            address: ::std::vec::Vec::new(),
            old_value: ::protobuf::MessageField::none(),
            new_value: ::protobuf::MessageField::none(),
            reason: ::protobuf::EnumOrUnknown::from_i32(0),
            ordinal: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BalanceChange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BalanceChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BalanceChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BalanceChange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BalanceChange`
pub mod balance_change {
    ///  Obtain all balanche change reasons under deep mind repository:
    ///
    ///  ```shell
    ///  ack -ho 'BalanceChangeReason\(".*"\)' | grep -Eo '".*"' | sort | uniq
    ///  ```
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:sf.ethereum.type.v2.BalanceChange.Reason)
    pub enum Reason {
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_UNKNOWN)
        REASON_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_REWARD_MINE_UNCLE)
        REASON_REWARD_MINE_UNCLE = 1,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_REWARD_MINE_BLOCK)
        REASON_REWARD_MINE_BLOCK = 2,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_DAO_REFUND_CONTRACT)
        REASON_DAO_REFUND_CONTRACT = 3,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_DAO_ADJUST_BALANCE)
        REASON_DAO_ADJUST_BALANCE = 4,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_TRANSFER)
        REASON_TRANSFER = 5,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_GENESIS_BALANCE)
        REASON_GENESIS_BALANCE = 6,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_GAS_BUY)
        REASON_GAS_BUY = 7,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_REWARD_TRANSACTION_FEE)
        REASON_REWARD_TRANSACTION_FEE = 8,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_REWARD_FEE_RESET)
        REASON_REWARD_FEE_RESET = 14,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_GAS_REFUND)
        REASON_GAS_REFUND = 9,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_TOUCH_ACCOUNT)
        REASON_TOUCH_ACCOUNT = 10,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_SUICIDE_REFUND)
        REASON_SUICIDE_REFUND = 11,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_SUICIDE_WITHDRAW)
        REASON_SUICIDE_WITHDRAW = 13,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_CALL_BALANCE_OVERRIDE)
        REASON_CALL_BALANCE_OVERRIDE = 12,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_BURN)
        REASON_BURN = 15,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.BalanceChange.Reason.REASON_WITHDRAWAL)
        REASON_WITHDRAWAL = 16,
    }

    impl ::protobuf::Enum for Reason {
        const NAME: &'static str = "Reason";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Reason> {
            match value {
                0 => ::std::option::Option::Some(Reason::REASON_UNKNOWN),
                1 => ::std::option::Option::Some(Reason::REASON_REWARD_MINE_UNCLE),
                2 => ::std::option::Option::Some(Reason::REASON_REWARD_MINE_BLOCK),
                3 => ::std::option::Option::Some(Reason::REASON_DAO_REFUND_CONTRACT),
                4 => ::std::option::Option::Some(Reason::REASON_DAO_ADJUST_BALANCE),
                5 => ::std::option::Option::Some(Reason::REASON_TRANSFER),
                6 => ::std::option::Option::Some(Reason::REASON_GENESIS_BALANCE),
                7 => ::std::option::Option::Some(Reason::REASON_GAS_BUY),
                8 => ::std::option::Option::Some(Reason::REASON_REWARD_TRANSACTION_FEE),
                14 => ::std::option::Option::Some(Reason::REASON_REWARD_FEE_RESET),
                9 => ::std::option::Option::Some(Reason::REASON_GAS_REFUND),
                10 => ::std::option::Option::Some(Reason::REASON_TOUCH_ACCOUNT),
                11 => ::std::option::Option::Some(Reason::REASON_SUICIDE_REFUND),
                13 => ::std::option::Option::Some(Reason::REASON_SUICIDE_WITHDRAW),
                12 => ::std::option::Option::Some(Reason::REASON_CALL_BALANCE_OVERRIDE),
                15 => ::std::option::Option::Some(Reason::REASON_BURN),
                16 => ::std::option::Option::Some(Reason::REASON_WITHDRAWAL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Reason] = &[
            Reason::REASON_UNKNOWN,
            Reason::REASON_REWARD_MINE_UNCLE,
            Reason::REASON_REWARD_MINE_BLOCK,
            Reason::REASON_DAO_REFUND_CONTRACT,
            Reason::REASON_DAO_ADJUST_BALANCE,
            Reason::REASON_TRANSFER,
            Reason::REASON_GENESIS_BALANCE,
            Reason::REASON_GAS_BUY,
            Reason::REASON_REWARD_TRANSACTION_FEE,
            Reason::REASON_REWARD_FEE_RESET,
            Reason::REASON_GAS_REFUND,
            Reason::REASON_TOUCH_ACCOUNT,
            Reason::REASON_SUICIDE_REFUND,
            Reason::REASON_SUICIDE_WITHDRAW,
            Reason::REASON_CALL_BALANCE_OVERRIDE,
            Reason::REASON_BURN,
            Reason::REASON_WITHDRAWAL,
        ];
    }

    impl ::protobuf::EnumFull for Reason {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BalanceChange.Reason").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Reason::REASON_UNKNOWN => 0,
                Reason::REASON_REWARD_MINE_UNCLE => 1,
                Reason::REASON_REWARD_MINE_BLOCK => 2,
                Reason::REASON_DAO_REFUND_CONTRACT => 3,
                Reason::REASON_DAO_ADJUST_BALANCE => 4,
                Reason::REASON_TRANSFER => 5,
                Reason::REASON_GENESIS_BALANCE => 6,
                Reason::REASON_GAS_BUY => 7,
                Reason::REASON_REWARD_TRANSACTION_FEE => 8,
                Reason::REASON_REWARD_FEE_RESET => 9,
                Reason::REASON_GAS_REFUND => 10,
                Reason::REASON_TOUCH_ACCOUNT => 11,
                Reason::REASON_SUICIDE_REFUND => 12,
                Reason::REASON_SUICIDE_WITHDRAW => 13,
                Reason::REASON_CALL_BALANCE_OVERRIDE => 14,
                Reason::REASON_BURN => 15,
                Reason::REASON_WITHDRAWAL => 16,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Reason {
        fn default() -> Self {
            Reason::REASON_UNKNOWN
        }
    }

    impl Reason {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Reason>("BalanceChange.Reason")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.NonceChange)
pub struct NonceChange {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.NonceChange.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.NonceChange.old_value)
    pub old_value: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.NonceChange.new_value)
    pub new_value: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.NonceChange.ordinal)
    pub ordinal: u64,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.NonceChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NonceChange {
    fn default() -> &'a NonceChange {
        <NonceChange as ::protobuf::Message>::default_instance()
    }
}

impl NonceChange {
    pub fn new() -> NonceChange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &NonceChange| { &m.address },
            |m: &mut NonceChange| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "old_value",
            |m: &NonceChange| { &m.old_value },
            |m: &mut NonceChange| { &mut m.old_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_value",
            |m: &NonceChange| { &m.new_value },
            |m: &mut NonceChange| { &mut m.new_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ordinal",
            |m: &NonceChange| { &m.ordinal },
            |m: &mut NonceChange| { &mut m.ordinal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NonceChange>(
            "NonceChange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NonceChange {
    const NAME: &'static str = "NonceChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                16 => {
                    self.old_value = is.read_uint64()?;
                },
                24 => {
                    self.new_value = is.read_uint64()?;
                },
                32 => {
                    self.ordinal = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if self.old_value != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.old_value);
        }
        if self.new_value != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.new_value);
        }
        if self.ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.ordinal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if self.old_value != 0 {
            os.write_uint64(2, self.old_value)?;
        }
        if self.new_value != 0 {
            os.write_uint64(3, self.new_value)?;
        }
        if self.ordinal != 0 {
            os.write_uint64(4, self.ordinal)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NonceChange {
        NonceChange::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.old_value = 0;
        self.new_value = 0;
        self.ordinal = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NonceChange {
        static instance: NonceChange = NonceChange {
            address: ::std::vec::Vec::new(),
            old_value: 0,
            new_value: 0,
            ordinal: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NonceChange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NonceChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NonceChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NonceChange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.AccountCreation)
pub struct AccountCreation {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.AccountCreation.account)
    pub account: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.AccountCreation.ordinal)
    pub ordinal: u64,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.AccountCreation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccountCreation {
    fn default() -> &'a AccountCreation {
        <AccountCreation as ::protobuf::Message>::default_instance()
    }
}

impl AccountCreation {
    pub fn new() -> AccountCreation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "account",
            |m: &AccountCreation| { &m.account },
            |m: &mut AccountCreation| { &mut m.account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ordinal",
            |m: &AccountCreation| { &m.ordinal },
            |m: &mut AccountCreation| { &mut m.ordinal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountCreation>(
            "AccountCreation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccountCreation {
    const NAME: &'static str = "AccountCreation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.account = is.read_bytes()?;
                },
                16 => {
                    self.ordinal = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.account);
        }
        if self.ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.ordinal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.account.is_empty() {
            os.write_bytes(1, &self.account)?;
        }
        if self.ordinal != 0 {
            os.write_uint64(2, self.ordinal)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccountCreation {
        AccountCreation::new()
    }

    fn clear(&mut self) {
        self.account.clear();
        self.ordinal = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccountCreation {
        static instance: AccountCreation = AccountCreation {
            account: ::std::vec::Vec::new(),
            ordinal: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccountCreation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccountCreation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccountCreation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountCreation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.CodeChange)
pub struct CodeChange {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.CodeChange.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.CodeChange.old_hash)
    pub old_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.CodeChange.old_code)
    pub old_code: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.CodeChange.new_hash)
    pub new_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.CodeChange.new_code)
    pub new_code: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.CodeChange.ordinal)
    pub ordinal: u64,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.CodeChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CodeChange {
    fn default() -> &'a CodeChange {
        <CodeChange as ::protobuf::Message>::default_instance()
    }
}

impl CodeChange {
    pub fn new() -> CodeChange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &CodeChange| { &m.address },
            |m: &mut CodeChange| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "old_hash",
            |m: &CodeChange| { &m.old_hash },
            |m: &mut CodeChange| { &mut m.old_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "old_code",
            |m: &CodeChange| { &m.old_code },
            |m: &mut CodeChange| { &mut m.old_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_hash",
            |m: &CodeChange| { &m.new_hash },
            |m: &mut CodeChange| { &mut m.new_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_code",
            |m: &CodeChange| { &m.new_code },
            |m: &mut CodeChange| { &mut m.new_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ordinal",
            |m: &CodeChange| { &m.ordinal },
            |m: &mut CodeChange| { &mut m.ordinal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CodeChange>(
            "CodeChange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CodeChange {
    const NAME: &'static str = "CodeChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                18 => {
                    self.old_hash = is.read_bytes()?;
                },
                26 => {
                    self.old_code = is.read_bytes()?;
                },
                34 => {
                    self.new_hash = is.read_bytes()?;
                },
                42 => {
                    self.new_code = is.read_bytes()?;
                },
                48 => {
                    self.ordinal = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if !self.old_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.old_hash);
        }
        if !self.old_code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.old_code);
        }
        if !self.new_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.new_hash);
        }
        if !self.new_code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.new_code);
        }
        if self.ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.ordinal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if !self.old_hash.is_empty() {
            os.write_bytes(2, &self.old_hash)?;
        }
        if !self.old_code.is_empty() {
            os.write_bytes(3, &self.old_code)?;
        }
        if !self.new_hash.is_empty() {
            os.write_bytes(4, &self.new_hash)?;
        }
        if !self.new_code.is_empty() {
            os.write_bytes(5, &self.new_code)?;
        }
        if self.ordinal != 0 {
            os.write_uint64(6, self.ordinal)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CodeChange {
        CodeChange::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.old_hash.clear();
        self.old_code.clear();
        self.new_hash.clear();
        self.new_code.clear();
        self.ordinal = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CodeChange {
        static instance: CodeChange = CodeChange {
            address: ::std::vec::Vec::new(),
            old_hash: ::std::vec::Vec::new(),
            old_code: ::std::vec::Vec::new(),
            new_hash: ::std::vec::Vec::new(),
            new_code: ::std::vec::Vec::new(),
            ordinal: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CodeChange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CodeChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CodeChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodeChange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The gas change model represents the reason why some gas cost has occurred.
///  The gas is computed per actual op codes. Doing them completely might prove
///  overwhelming in most cases.
///
///  Hence, we only index some of them, those that are costy like all the calls
///  one, log events, return data, etc.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.GasChange)
pub struct GasChange {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.GasChange.old_value)
    pub old_value: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.GasChange.new_value)
    pub new_value: u64,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.GasChange.reason)
    pub reason: ::protobuf::EnumOrUnknown<gas_change::Reason>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.GasChange.ordinal)
    pub ordinal: u64,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.GasChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GasChange {
    fn default() -> &'a GasChange {
        <GasChange as ::protobuf::Message>::default_instance()
    }
}

impl GasChange {
    pub fn new() -> GasChange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "old_value",
            |m: &GasChange| { &m.old_value },
            |m: &mut GasChange| { &mut m.old_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_value",
            |m: &GasChange| { &m.new_value },
            |m: &mut GasChange| { &mut m.new_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reason",
            |m: &GasChange| { &m.reason },
            |m: &mut GasChange| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ordinal",
            |m: &GasChange| { &m.ordinal },
            |m: &mut GasChange| { &mut m.ordinal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GasChange>(
            "GasChange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GasChange {
    const NAME: &'static str = "GasChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.old_value = is.read_uint64()?;
                },
                16 => {
                    self.new_value = is.read_uint64()?;
                },
                24 => {
                    self.reason = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.ordinal = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.old_value != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.old_value);
        }
        if self.new_value != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.new_value);
        }
        if self.reason != ::protobuf::EnumOrUnknown::new(gas_change::Reason::REASON_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(3, self.reason.value());
        }
        if self.ordinal != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.ordinal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.old_value != 0 {
            os.write_uint64(1, self.old_value)?;
        }
        if self.new_value != 0 {
            os.write_uint64(2, self.new_value)?;
        }
        if self.reason != ::protobuf::EnumOrUnknown::new(gas_change::Reason::REASON_UNKNOWN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.reason))?;
        }
        if self.ordinal != 0 {
            os.write_uint64(4, self.ordinal)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GasChange {
        GasChange::new()
    }

    fn clear(&mut self) {
        self.old_value = 0;
        self.new_value = 0;
        self.reason = ::protobuf::EnumOrUnknown::new(gas_change::Reason::REASON_UNKNOWN);
        self.ordinal = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GasChange {
        static instance: GasChange = GasChange {
            old_value: 0,
            new_value: 0,
            reason: ::protobuf::EnumOrUnknown::from_i32(0),
            ordinal: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GasChange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GasChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GasChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GasChange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GasChange`
pub mod gas_change {
    ///  Obtain all gas change reasons under deep mind repository:
    ///
    ///  ```shell
    ///  ack -ho 'GasChangeReason\(".*"\)' | grep -Eo '".*"' | sort | uniq
    ///  ```
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:sf.ethereum.type.v2.GasChange.Reason)
    pub enum Reason {
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_UNKNOWN)
        REASON_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_CALL)
        REASON_CALL = 1,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_CALL_CODE)
        REASON_CALL_CODE = 2,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_CALL_DATA_COPY)
        REASON_CALL_DATA_COPY = 3,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_CODE_COPY)
        REASON_CODE_COPY = 4,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_CODE_STORAGE)
        REASON_CODE_STORAGE = 5,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_CONTRACT_CREATION)
        REASON_CONTRACT_CREATION = 6,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_CONTRACT_CREATION2)
        REASON_CONTRACT_CREATION2 = 7,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_DELEGATE_CALL)
        REASON_DELEGATE_CALL = 8,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_EVENT_LOG)
        REASON_EVENT_LOG = 9,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_EXT_CODE_COPY)
        REASON_EXT_CODE_COPY = 10,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_FAILED_EXECUTION)
        REASON_FAILED_EXECUTION = 11,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_INTRINSIC_GAS)
        REASON_INTRINSIC_GAS = 12,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_PRECOMPILED_CONTRACT)
        REASON_PRECOMPILED_CONTRACT = 13,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_REFUND_AFTER_EXECUTION)
        REASON_REFUND_AFTER_EXECUTION = 14,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_RETURN)
        REASON_RETURN = 15,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_RETURN_DATA_COPY)
        REASON_RETURN_DATA_COPY = 16,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_REVERT)
        REASON_REVERT = 17,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_SELF_DESTRUCT)
        REASON_SELF_DESTRUCT = 18,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_STATIC_CALL)
        REASON_STATIC_CALL = 19,
        // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.GasChange.Reason.REASON_STATE_COLD_ACCESS)
        REASON_STATE_COLD_ACCESS = 20,
    }

    impl ::protobuf::Enum for Reason {
        const NAME: &'static str = "Reason";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Reason> {
            match value {
                0 => ::std::option::Option::Some(Reason::REASON_UNKNOWN),
                1 => ::std::option::Option::Some(Reason::REASON_CALL),
                2 => ::std::option::Option::Some(Reason::REASON_CALL_CODE),
                3 => ::std::option::Option::Some(Reason::REASON_CALL_DATA_COPY),
                4 => ::std::option::Option::Some(Reason::REASON_CODE_COPY),
                5 => ::std::option::Option::Some(Reason::REASON_CODE_STORAGE),
                6 => ::std::option::Option::Some(Reason::REASON_CONTRACT_CREATION),
                7 => ::std::option::Option::Some(Reason::REASON_CONTRACT_CREATION2),
                8 => ::std::option::Option::Some(Reason::REASON_DELEGATE_CALL),
                9 => ::std::option::Option::Some(Reason::REASON_EVENT_LOG),
                10 => ::std::option::Option::Some(Reason::REASON_EXT_CODE_COPY),
                11 => ::std::option::Option::Some(Reason::REASON_FAILED_EXECUTION),
                12 => ::std::option::Option::Some(Reason::REASON_INTRINSIC_GAS),
                13 => ::std::option::Option::Some(Reason::REASON_PRECOMPILED_CONTRACT),
                14 => ::std::option::Option::Some(Reason::REASON_REFUND_AFTER_EXECUTION),
                15 => ::std::option::Option::Some(Reason::REASON_RETURN),
                16 => ::std::option::Option::Some(Reason::REASON_RETURN_DATA_COPY),
                17 => ::std::option::Option::Some(Reason::REASON_REVERT),
                18 => ::std::option::Option::Some(Reason::REASON_SELF_DESTRUCT),
                19 => ::std::option::Option::Some(Reason::REASON_STATIC_CALL),
                20 => ::std::option::Option::Some(Reason::REASON_STATE_COLD_ACCESS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Reason] = &[
            Reason::REASON_UNKNOWN,
            Reason::REASON_CALL,
            Reason::REASON_CALL_CODE,
            Reason::REASON_CALL_DATA_COPY,
            Reason::REASON_CODE_COPY,
            Reason::REASON_CODE_STORAGE,
            Reason::REASON_CONTRACT_CREATION,
            Reason::REASON_CONTRACT_CREATION2,
            Reason::REASON_DELEGATE_CALL,
            Reason::REASON_EVENT_LOG,
            Reason::REASON_EXT_CODE_COPY,
            Reason::REASON_FAILED_EXECUTION,
            Reason::REASON_INTRINSIC_GAS,
            Reason::REASON_PRECOMPILED_CONTRACT,
            Reason::REASON_REFUND_AFTER_EXECUTION,
            Reason::REASON_RETURN,
            Reason::REASON_RETURN_DATA_COPY,
            Reason::REASON_REVERT,
            Reason::REASON_SELF_DESTRUCT,
            Reason::REASON_STATIC_CALL,
            Reason::REASON_STATE_COLD_ACCESS,
        ];
    }

    impl ::protobuf::EnumFull for Reason {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("GasChange.Reason").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Reason {
        fn default() -> Self {
            Reason::REASON_UNKNOWN
        }
    }

    impl Reason {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Reason>("GasChange.Reason")
        }
    }
}

///  HeaderOnlyBlock is used to optimally unpack the [Block] structure (note the
///  corresponding message number for the `header` field) while consuming less
///  memory, when only the `header` is desired.
///
///  WARN: this is a client-side optimization pattern and should be moved in the
///  consuming code.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.HeaderOnlyBlock)
pub struct HeaderOnlyBlock {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.HeaderOnlyBlock.header)
    pub header: ::protobuf::MessageField<BlockHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.HeaderOnlyBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HeaderOnlyBlock {
    fn default() -> &'a HeaderOnlyBlock {
        <HeaderOnlyBlock as ::protobuf::Message>::default_instance()
    }
}

impl HeaderOnlyBlock {
    pub fn new() -> HeaderOnlyBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockHeader>(
            "header",
            |m: &HeaderOnlyBlock| { &m.header },
            |m: &mut HeaderOnlyBlock| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeaderOnlyBlock>(
            "HeaderOnlyBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HeaderOnlyBlock {
    const NAME: &'static str = "HeaderOnlyBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HeaderOnlyBlock {
        HeaderOnlyBlock::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HeaderOnlyBlock {
        static instance: HeaderOnlyBlock = HeaderOnlyBlock {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HeaderOnlyBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HeaderOnlyBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HeaderOnlyBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeaderOnlyBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  BlockWithRefs is a lightweight block, with traces and transactions
///  purged from the `block` within, and only.  It is used in transports
///  to pass block data around.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.BlockWithRefs)
pub struct BlockWithRefs {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockWithRefs.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockWithRefs.block)
    pub block: ::protobuf::MessageField<Block>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockWithRefs.transaction_trace_refs)
    pub transaction_trace_refs: ::protobuf::MessageField<TransactionRefs>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockWithRefs.irreversible)
    pub irreversible: bool,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.BlockWithRefs.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockWithRefs {
    fn default() -> &'a BlockWithRefs {
        <BlockWithRefs as ::protobuf::Message>::default_instance()
    }
}

impl BlockWithRefs {
    pub fn new() -> BlockWithRefs {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &BlockWithRefs| { &m.id },
            |m: &mut BlockWithRefs| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Block>(
            "block",
            |m: &BlockWithRefs| { &m.block },
            |m: &mut BlockWithRefs| { &mut m.block },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TransactionRefs>(
            "transaction_trace_refs",
            |m: &BlockWithRefs| { &m.transaction_trace_refs },
            |m: &mut BlockWithRefs| { &mut m.transaction_trace_refs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "irreversible",
            |m: &BlockWithRefs| { &m.irreversible },
            |m: &mut BlockWithRefs| { &mut m.irreversible },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockWithRefs>(
            "BlockWithRefs",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockWithRefs {
    const NAME: &'static str = "BlockWithRefs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.transaction_trace_refs)?;
                },
                32 => {
                    self.irreversible = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.transaction_trace_refs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.irreversible != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.block.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.transaction_trace_refs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.irreversible != false {
            os.write_bool(4, self.irreversible)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockWithRefs {
        BlockWithRefs::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.block.clear();
        self.transaction_trace_refs.clear();
        self.irreversible = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockWithRefs {
        static instance: BlockWithRefs = BlockWithRefs {
            id: ::std::string::String::new(),
            block: ::protobuf::MessageField::none(),
            transaction_trace_refs: ::protobuf::MessageField::none(),
            irreversible: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockWithRefs {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockWithRefs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockWithRefs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockWithRefs {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.TransactionTraceWithBlockRef)
pub struct TransactionTraceWithBlockRef {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTraceWithBlockRef.trace)
    pub trace: ::protobuf::MessageField<TransactionTrace>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionTraceWithBlockRef.block_ref)
    pub block_ref: ::protobuf::MessageField<BlockRef>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.TransactionTraceWithBlockRef.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionTraceWithBlockRef {
    fn default() -> &'a TransactionTraceWithBlockRef {
        <TransactionTraceWithBlockRef as ::protobuf::Message>::default_instance()
    }
}

impl TransactionTraceWithBlockRef {
    pub fn new() -> TransactionTraceWithBlockRef {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TransactionTrace>(
            "trace",
            |m: &TransactionTraceWithBlockRef| { &m.trace },
            |m: &mut TransactionTraceWithBlockRef| { &mut m.trace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BlockRef>(
            "block_ref",
            |m: &TransactionTraceWithBlockRef| { &m.block_ref },
            |m: &mut TransactionTraceWithBlockRef| { &mut m.block_ref },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionTraceWithBlockRef>(
            "TransactionTraceWithBlockRef",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionTraceWithBlockRef {
    const NAME: &'static str = "TransactionTraceWithBlockRef";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trace)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block_ref)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.trace.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.block_ref.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.trace.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.block_ref.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionTraceWithBlockRef {
        TransactionTraceWithBlockRef::new()
    }

    fn clear(&mut self) {
        self.trace.clear();
        self.block_ref.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionTraceWithBlockRef {
        static instance: TransactionTraceWithBlockRef = TransactionTraceWithBlockRef {
            trace: ::protobuf::MessageField::none(),
            block_ref: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionTraceWithBlockRef {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionTraceWithBlockRef").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionTraceWithBlockRef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionTraceWithBlockRef {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.TransactionRefs)
pub struct TransactionRefs {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.TransactionRefs.hashes)
    pub hashes: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.TransactionRefs.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionRefs {
    fn default() -> &'a TransactionRefs {
        <TransactionRefs as ::protobuf::Message>::default_instance()
    }
}

impl TransactionRefs {
    pub fn new() -> TransactionRefs {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hashes",
            |m: &TransactionRefs| { &m.hashes },
            |m: &mut TransactionRefs| { &mut m.hashes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionRefs>(
            "TransactionRefs",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionRefs {
    const NAME: &'static str = "TransactionRefs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hashes.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hashes {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.hashes {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionRefs {
        TransactionRefs::new()
    }

    fn clear(&mut self) {
        self.hashes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionRefs {
        static instance: TransactionRefs = TransactionRefs {
            hashes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionRefs {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionRefs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionRefs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionRefs {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:sf.ethereum.type.v2.BlockRef)
pub struct BlockRef {
    // message fields
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockRef.hash)
    pub hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:sf.ethereum.type.v2.BlockRef.number)
    pub number: u64,
    // special fields
    // @@protoc_insertion_point(special_field:sf.ethereum.type.v2.BlockRef.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockRef {
    fn default() -> &'a BlockRef {
        <BlockRef as ::protobuf::Message>::default_instance()
    }
}

impl BlockRef {
    pub fn new() -> BlockRef {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &BlockRef| { &m.hash },
            |m: &mut BlockRef| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "number",
            |m: &BlockRef| { &m.number },
            |m: &mut BlockRef| { &mut m.number },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockRef>(
            "BlockRef",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockRef {
    const NAME: &'static str = "BlockRef";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hash = is.read_bytes()?;
                },
                16 => {
                    self.number = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if self.number != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.number);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if self.number != 0 {
            os.write_uint64(2, self.number)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockRef {
        BlockRef::new()
    }

    fn clear(&mut self) {
        self.hash.clear();
        self.number = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockRef {
        static instance: BlockRef = BlockRef {
            hash: ::std::vec::Vec::new(),
            number: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockRef {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockRef").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockRef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockRef {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:sf.ethereum.type.v2.TransactionTraceStatus)
pub enum TransactionTraceStatus {
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.TransactionTraceStatus.UNKNOWN)
    UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.TransactionTraceStatus.SUCCEEDED)
    SUCCEEDED = 1,
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.TransactionTraceStatus.FAILED)
    FAILED = 2,
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.TransactionTraceStatus.REVERTED)
    REVERTED = 3,
}

impl ::protobuf::Enum for TransactionTraceStatus {
    const NAME: &'static str = "TransactionTraceStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TransactionTraceStatus> {
        match value {
            0 => ::std::option::Option::Some(TransactionTraceStatus::UNKNOWN),
            1 => ::std::option::Option::Some(TransactionTraceStatus::SUCCEEDED),
            2 => ::std::option::Option::Some(TransactionTraceStatus::FAILED),
            3 => ::std::option::Option::Some(TransactionTraceStatus::REVERTED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TransactionTraceStatus] = &[
        TransactionTraceStatus::UNKNOWN,
        TransactionTraceStatus::SUCCEEDED,
        TransactionTraceStatus::FAILED,
        TransactionTraceStatus::REVERTED,
    ];
}

impl ::protobuf::EnumFull for TransactionTraceStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TransactionTraceStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TransactionTraceStatus {
    fn default() -> Self {
        TransactionTraceStatus::UNKNOWN
    }
}

impl TransactionTraceStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TransactionTraceStatus>("TransactionTraceStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:sf.ethereum.type.v2.CallType)
pub enum CallType {
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.CallType.UNSPECIFIED)
    UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.CallType.CALL)
    CALL = 1,
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.CallType.CALLCODE)
    CALLCODE = 2,
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.CallType.DELEGATE)
    DELEGATE = 3,
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.CallType.STATIC)
    STATIC = 4,
    // @@protoc_insertion_point(enum_value:sf.ethereum.type.v2.CallType.CREATE)
    CREATE = 5,
}

impl ::protobuf::Enum for CallType {
    const NAME: &'static str = "CallType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CallType> {
        match value {
            0 => ::std::option::Option::Some(CallType::UNSPECIFIED),
            1 => ::std::option::Option::Some(CallType::CALL),
            2 => ::std::option::Option::Some(CallType::CALLCODE),
            3 => ::std::option::Option::Some(CallType::DELEGATE),
            4 => ::std::option::Option::Some(CallType::STATIC),
            5 => ::std::option::Option::Some(CallType::CREATE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CallType] = &[
        CallType::UNSPECIFIED,
        CallType::CALL,
        CallType::CALLCODE,
        CallType::DELEGATE,
        CallType::STATIC,
        CallType::CREATE,
    ];
}

impl ::protobuf::EnumFull for CallType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CallType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CallType {
    fn default() -> Self {
        CallType::UNSPECIFIED
    }
}

impl CallType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CallType>("CallType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16src/protos/block.proto\x12\x13sf.ethereum.type.v2\x1a\x1fgoogle/pr\
    otobuf/timestamp.proto\"\xc6\x03\n\x05Block\x12\x12\n\x04hash\x18\x02\
    \x20\x01(\x0cR\x04hash\x12\x16\n\x06number\x18\x03\x20\x01(\x04R\x06numb\
    er\x12\x12\n\x04size\x18\x04\x20\x01(\x04R\x04size\x128\n\x06header\x18\
    \x05\x20\x01(\x0b2\x20.sf.ethereum.type.v2.BlockHeaderR\x06header\x128\n\
    \x06uncles\x18\x06\x20\x03(\x0b2\x20.sf.ethereum.type.v2.BlockHeaderR\
    \x06uncles\x12T\n\x12transaction_traces\x18\n\x20\x03(\x0b2%.sf.ethereum\
    .type.v2.TransactionTraceR\x11transactionTraces\x12K\n\x0fbalance_change\
    s\x18\x0b\x20\x03(\x0b2\".sf.ethereum.type.v2.BalanceChangeR\x0ebalanceC\
    hanges\x12B\n\x0ccode_changes\x18\x14\x20\x03(\x0b2\x1f.sf.ethereum.type\
    .v2.CodeChangeR\x0bcodeChanges\x12\x10\n\x03ver\x18\x01\x20\x01(\x05R\
    \x03verJ\x04\x08(\x10)J\x04\x08)\x10*J\x04\x08*\x10+\"\xa8\x06\n\x0bBloc\
    kHeader\x12\x1f\n\x0bparent_hash\x18\x01\x20\x01(\x0cR\nparentHash\x12\
    \x1d\n\nuncle_hash\x18\x02\x20\x01(\x0cR\tuncleHash\x12\x1a\n\x08coinbas\
    e\x18\x03\x20\x01(\x0cR\x08coinbase\x12\x1d\n\nstate_root\x18\x04\x20\
    \x01(\x0cR\tstateRoot\x12+\n\x11transactions_root\x18\x05\x20\x01(\x0cR\
    \x10transactionsRoot\x12!\n\x0creceipt_root\x18\x06\x20\x01(\x0cR\x0brec\
    eiptRoot\x12\x1d\n\nlogs_bloom\x18\x07\x20\x01(\x0cR\tlogsBloom\x12;\n\n\
    difficulty\x18\x08\x20\x01(\x0b2\x1b.sf.ethereum.type.v2.BigIntR\ndiffic\
    ulty\x12F\n\x10total_difficulty\x18\x11\x20\x01(\x0b2\x1b.sf.ethereum.ty\
    pe.v2.BigIntR\x0ftotalDifficulty\x12\x16\n\x06number\x18\t\x20\x01(\x04R\
    \x06number\x12\x1b\n\tgas_limit\x18\n\x20\x01(\x04R\x08gasLimit\x12\x19\
    \n\x08gas_used\x18\x0b\x20\x01(\x04R\x07gasUsed\x128\n\ttimestamp\x18\
    \x0c\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ttimestamp\x12\x1d\n\n\
    extra_data\x18\r\x20\x01(\x0cR\textraData\x12\x19\n\x08mix_hash\x18\x0e\
    \x20\x01(\x0cR\x07mixHash\x12\x14\n\x05nonce\x18\x0f\x20\x01(\x04R\x05no\
    nce\x12\x12\n\x04hash\x18\x10\x20\x01(\x0cR\x04hash\x12D\n\x10base_fee_p\
    er_gas\x18\x12\x20\x01(\x0b2\x1b.sf.ethereum.type.v2.BigIntR\rbaseFeePer\
    Gas\x12)\n\x10withdrawals_root\x18\x13\x20\x01(\x0cR\x0fwithdrawalsRoot\
    \x12K\n\rtx_dependency\x18\x14\x20\x01(\x0b2&.sf.ethereum.type.v2.Uint64\
    NestedArrayR\x0ctxDependency\"G\n\x11Uint64NestedArray\x122\n\x03val\x18\
    \x01\x20\x03(\x0b2\x20.sf.ethereum.type.v2.Uint64ArrayR\x03val\"\x1f\n\
    \x0bUint64Array\x12\x10\n\x03val\x18\x01\x20\x03(\x04R\x03val\"\x1e\n\
    \x06BigInt\x12\x14\n\x05bytes\x18\x01\x20\x01(\x0cR\x05bytes\"\x87\x08\n\
    \x10TransactionTrace\x12\x0e\n\x02to\x18\x01\x20\x01(\x0cR\x02to\x12\x14\
    \n\x05nonce\x18\x02\x20\x01(\x04R\x05nonce\x128\n\tgas_price\x18\x03\x20\
    \x01(\x0b2\x1b.sf.ethereum.type.v2.BigIntR\x08gasPrice\x12\x1b\n\tgas_li\
    mit\x18\x04\x20\x01(\x04R\x08gasLimit\x121\n\x05value\x18\x05\x20\x01(\
    \x0b2\x1b.sf.ethereum.type.v2.BigIntR\x05value\x12\x14\n\x05input\x18\
    \x06\x20\x01(\x0cR\x05input\x12\x0c\n\x01v\x18\x07\x20\x01(\x0cR\x01v\
    \x12\x0c\n\x01r\x18\x08\x20\x01(\x0cR\x01r\x12\x0c\n\x01s\x18\t\x20\x01(\
    \x0cR\x01s\x12\x19\n\x08gas_used\x18\n\x20\x01(\x04R\x07gasUsed\x12>\n\
    \x04type\x18\x0c\x20\x01(\x0e2*.sf.ethereum.type.v2.TransactionTrace.Typ\
    eR\x04type\x12A\n\x0baccess_list\x18\x0e\x20\x03(\x0b2\x20.sf.ethereum.t\
    ype.v2.AccessTupleR\naccessList\x12B\n\x0fmax_fee_per_gas\x18\x0b\x20\
    \x01(\x0b2\x1b.sf.ethereum.type.v2.BigIntR\x0cmaxFeePerGas\x12S\n\x18max\
    _priority_fee_per_gas\x18\r\x20\x01(\x0b2\x1b.sf.ethereum.type.v2.BigInt\
    R\x14maxPriorityFeePerGas\x12\x14\n\x05index\x18\x14\x20\x01(\rR\x05inde\
    x\x12\x12\n\x04hash\x18\x15\x20\x01(\x0cR\x04hash\x12\x12\n\x04from\x18\
    \x16\x20\x01(\x0cR\x04from\x12\x1f\n\x0breturn_data\x18\x17\x20\x01(\x0c\
    R\nreturnData\x12\x1d\n\npublic_key\x18\x18\x20\x01(\x0cR\tpublicKey\x12\
    #\n\rbegin_ordinal\x18\x19\x20\x01(\x04R\x0cbeginOrdinal\x12\x1f\n\x0ben\
    d_ordinal\x18\x1a\x20\x01(\x04R\nendOrdinal\x12C\n\x06status\x18\x1e\x20\
    \x01(\x0e2+.sf.ethereum.type.v2.TransactionTraceStatusR\x06status\x12A\n\
    \x07receipt\x18\x1f\x20\x01(\x0b2'.sf.ethereum.type.v2.TransactionReceip\
    tR\x07receipt\x12/\n\x05calls\x18\x20\x20\x03(\x0b2\x19.sf.ethereum.type\
    .v2.CallR\x05calls\"O\n\x04Type\x12\x13\n\x0fTRX_TYPE_LEGACY\x10\0\x12\
    \x18\n\x14TRX_TYPE_ACCESS_LIST\x10\x01\x12\x18\n\x14TRX_TYPE_DYNAMIC_FEE\
    \x10\x02\"J\n\x0bAccessTuple\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\
    \x07address\x12!\n\x0cstorage_keys\x18\x02\x20\x03(\x0cR\x0bstorageKeys\
    \"\xb0\x01\n\x12TransactionReceipt\x12\x1d\n\nstate_root\x18\x01\x20\x01\
    (\x0cR\tstateRoot\x12.\n\x13cumulative_gas_used\x18\x02\x20\x01(\x04R\
    \x11cumulativeGasUsed\x12\x1d\n\nlogs_bloom\x18\x03\x20\x01(\x0cR\tlogsB\
    loom\x12,\n\x04logs\x18\x04\x20\x03(\x0b2\x18.sf.ethereum.type.v2.LogR\
    \x04logs\"\x9b\x01\n\x03Log\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\
    \x07address\x12\x16\n\x06topics\x18\x02\x20\x03(\x0cR\x06topics\x12\x12\
    \n\x04data\x18\x03\x20\x01(\x0cR\x04data\x12\x14\n\x05index\x18\x04\x20\
    \x01(\rR\x05index\x12\x1e\n\nblockIndex\x18\x06\x20\x01(\rR\nblockIndex\
    \x12\x18\n\x07ordinal\x18\x07\x20\x01(\x04R\x07ordinal\"\xb2\n\n\x04Call\
    \x12\x14\n\x05index\x18\x01\x20\x01(\rR\x05index\x12!\n\x0cparent_index\
    \x18\x02\x20\x01(\rR\x0bparentIndex\x12\x14\n\x05depth\x18\x03\x20\x01(\
    \rR\x05depth\x12:\n\tcall_type\x18\x04\x20\x01(\x0e2\x1d.sf.ethereum.typ\
    e.v2.CallTypeR\x08callType\x12\x16\n\x06caller\x18\x05\x20\x01(\x0cR\x06\
    caller\x12\x18\n\x07address\x18\x06\x20\x01(\x0cR\x07address\x121\n\x05v\
    alue\x18\x07\x20\x01(\x0b2\x1b.sf.ethereum.type.v2.BigIntR\x05value\x12\
    \x1b\n\tgas_limit\x18\x08\x20\x01(\x04R\x08gasLimit\x12!\n\x0cgas_consum\
    ed\x18\t\x20\x01(\x04R\x0bgasConsumed\x12\x1f\n\x0breturn_data\x18\r\x20\
    \x01(\x0cR\nreturnData\x12\x14\n\x05input\x18\x0e\x20\x01(\x0cR\x05input\
    \x12#\n\rexecuted_code\x18\x0f\x20\x01(\x08R\x0cexecutedCode\x12\x18\n\
    \x07suicide\x18\x10\x20\x01(\x08R\x07suicide\x12Y\n\x10keccak_preimages\
    \x18\x14\x20\x03(\x0b2..sf.ethereum.type.v2.Call.KeccakPreimagesEntryR\
    \x0fkeccakPreimages\x12K\n\x0fstorage_changes\x18\x15\x20\x03(\x0b2\".sf\
    .ethereum.type.v2.StorageChangeR\x0estorageChanges\x12K\n\x0fbalance_cha\
    nges\x18\x16\x20\x03(\x0b2\".sf.ethereum.type.v2.BalanceChangeR\x0ebalan\
    ceChanges\x12E\n\rnonce_changes\x18\x18\x20\x03(\x0b2\x20.sf.ethereum.ty\
    pe.v2.NonceChangeR\x0cnonceChanges\x12,\n\x04logs\x18\x19\x20\x03(\x0b2\
    \x18.sf.ethereum.type.v2.LogR\x04logs\x12B\n\x0ccode_changes\x18\x1a\x20\
    \x03(\x0b2\x1f.sf.ethereum.type.v2.CodeChangeR\x0bcodeChanges\x12?\n\x0b\
    gas_changes\x18\x1c\x20\x03(\x0b2\x1e.sf.ethereum.type.v2.GasChangeR\nga\
    sChanges\x12#\n\rstatus_failed\x18\n\x20\x01(\x08R\x0cstatusFailed\x12'\
    \n\x0fstatus_reverted\x18\x0c\x20\x01(\x08R\x0estatusReverted\x12%\n\x0e\
    failure_reason\x18\x0b\x20\x01(\tR\rfailureReason\x12%\n\x0estate_revert\
    ed\x18\x1e\x20\x01(\x08R\rstateReverted\x12#\n\rbegin_ordinal\x18\x1f\
    \x20\x01(\x04R\x0cbeginOrdinal\x12\x1f\n\x0bend_ordinal\x18\x20\x20\x01(\
    \x04R\nendOrdinal\x12Q\n\x11account_creations\x18!\x20\x03(\x0b2$.sf.eth\
    ereum.type.v2.AccountCreationR\x10accountCreations\x1aB\n\x14KeccakPreim\
    agesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01J\x04\x08\x1b\x10\x1cJ\x04\x08\
    \x1d\x10\x1eJ\x04\x082\x103J\x04\x083\x104J\x04\x08<\x10=\"\x8f\x01\n\rS\
    torageChange\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\x12\
    \x10\n\x03key\x18\x02\x20\x01(\x0cR\x03key\x12\x1b\n\told_value\x18\x03\
    \x20\x01(\x0cR\x08oldValue\x12\x1b\n\tnew_value\x18\x04\x20\x01(\x0cR\
    \x08newValue\x12\x18\n\x07ordinal\x18\x05\x20\x01(\x04R\x07ordinal\"\xcc\
    \x05\n\rBalanceChange\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07addr\
    ess\x128\n\told_value\x18\x02\x20\x01(\x0b2\x1b.sf.ethereum.type.v2.BigI\
    ntR\x08oldValue\x128\n\tnew_value\x18\x03\x20\x01(\x0b2\x1b.sf.ethereum.\
    type.v2.BigIntR\x08newValue\x12A\n\x06reason\x18\x04\x20\x01(\x0e2).sf.e\
    thereum.type.v2.BalanceChange.ReasonR\x06reason\x12\x18\n\x07ordinal\x18\
    \x05\x20\x01(\x04R\x07ordinal\"\xcf\x03\n\x06Reason\x12\x12\n\x0eREASON_\
    UNKNOWN\x10\0\x12\x1c\n\x18REASON_REWARD_MINE_UNCLE\x10\x01\x12\x1c\n\
    \x18REASON_REWARD_MINE_BLOCK\x10\x02\x12\x1e\n\x1aREASON_DAO_REFUND_CONT\
    RACT\x10\x03\x12\x1d\n\x19REASON_DAO_ADJUST_BALANCE\x10\x04\x12\x13\n\
    \x0fREASON_TRANSFER\x10\x05\x12\x1a\n\x16REASON_GENESIS_BALANCE\x10\x06\
    \x12\x12\n\x0eREASON_GAS_BUY\x10\x07\x12!\n\x1dREASON_REWARD_TRANSACTION\
    _FEE\x10\x08\x12\x1b\n\x17REASON_REWARD_FEE_RESET\x10\x0e\x12\x15\n\x11R\
    EASON_GAS_REFUND\x10\t\x12\x18\n\x14REASON_TOUCH_ACCOUNT\x10\n\x12\x19\n\
    \x15REASON_SUICIDE_REFUND\x10\x0b\x12\x1b\n\x17REASON_SUICIDE_WITHDRAW\
    \x10\r\x12\x20\n\x1cREASON_CALL_BALANCE_OVERRIDE\x10\x0c\x12\x0f\n\x0bRE\
    ASON_BURN\x10\x0f\x12\x15\n\x11REASON_WITHDRAWAL\x10\x10\"{\n\x0bNonceCh\
    ange\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\x12\x1b\n\tol\
    d_value\x18\x02\x20\x01(\x04R\x08oldValue\x12\x1b\n\tnew_value\x18\x03\
    \x20\x01(\x04R\x08newValue\x12\x18\n\x07ordinal\x18\x04\x20\x01(\x04R\
    \x07ordinal\"E\n\x0fAccountCreation\x12\x18\n\x07account\x18\x01\x20\x01\
    (\x0cR\x07account\x12\x18\n\x07ordinal\x18\x02\x20\x01(\x04R\x07ordinal\
    \"\xac\x01\n\nCodeChange\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07a\
    ddress\x12\x19\n\x08old_hash\x18\x02\x20\x01(\x0cR\x07oldHash\x12\x19\n\
    \x08old_code\x18\x03\x20\x01(\x0cR\x07oldCode\x12\x19\n\x08new_hash\x18\
    \x04\x20\x01(\x0cR\x07newHash\x12\x19\n\x08new_code\x18\x05\x20\x01(\x0c\
    R\x07newCode\x12\x18\n\x07ordinal\x18\x06\x20\x01(\x04R\x07ordinal\"\xc3\
    \x05\n\tGasChange\x12\x1b\n\told_value\x18\x01\x20\x01(\x04R\x08oldValue\
    \x12\x1b\n\tnew_value\x18\x02\x20\x01(\x04R\x08newValue\x12=\n\x06reason\
    \x18\x03\x20\x01(\x0e2%.sf.ethereum.type.v2.GasChange.ReasonR\x06reason\
    \x12\x18\n\x07ordinal\x18\x04\x20\x01(\x04R\x07ordinal\"\xa2\x04\n\x06Re\
    ason\x12\x12\n\x0eREASON_UNKNOWN\x10\0\x12\x0f\n\x0bREASON_CALL\x10\x01\
    \x12\x14\n\x10REASON_CALL_CODE\x10\x02\x12\x19\n\x15REASON_CALL_DATA_COP\
    Y\x10\x03\x12\x14\n\x10REASON_CODE_COPY\x10\x04\x12\x17\n\x13REASON_CODE\
    _STORAGE\x10\x05\x12\x1c\n\x18REASON_CONTRACT_CREATION\x10\x06\x12\x1d\n\
    \x19REASON_CONTRACT_CREATION2\x10\x07\x12\x18\n\x14REASON_DELEGATE_CALL\
    \x10\x08\x12\x14\n\x10REASON_EVENT_LOG\x10\t\x12\x18\n\x14REASON_EXT_COD\
    E_COPY\x10\n\x12\x1b\n\x17REASON_FAILED_EXECUTION\x10\x0b\x12\x18\n\x14R\
    EASON_INTRINSIC_GAS\x10\x0c\x12\x1f\n\x1bREASON_PRECOMPILED_CONTRACT\x10\
    \r\x12!\n\x1dREASON_REFUND_AFTER_EXECUTION\x10\x0e\x12\x11\n\rREASON_RET\
    URN\x10\x0f\x12\x1b\n\x17REASON_RETURN_DATA_COPY\x10\x10\x12\x11\n\rREAS\
    ON_REVERT\x10\x11\x12\x18\n\x14REASON_SELF_DESTRUCT\x10\x12\x12\x16\n\
    \x12REASON_STATIC_CALL\x10\x13\x12\x1c\n\x18REASON_STATE_COLD_ACCESS\x10\
    \x14\"K\n\x0fHeaderOnlyBlock\x128\n\x06header\x18\x05\x20\x01(\x0b2\x20.\
    sf.ethereum.type.v2.BlockHeaderR\x06header\"\xd1\x01\n\rBlockWithRefs\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x120\n\x05block\x18\x02\x20\
    \x01(\x0b2\x1a.sf.ethereum.type.v2.BlockR\x05block\x12Z\n\x16transaction\
    _trace_refs\x18\x03\x20\x01(\x0b2$.sf.ethereum.type.v2.TransactionRefsR\
    \x14transactionTraceRefs\x12\"\n\x0cirreversible\x18\x04\x20\x01(\x08R\
    \x0cirreversible\"\x97\x01\n\x1cTransactionTraceWithBlockRef\x12;\n\x05t\
    race\x18\x01\x20\x01(\x0b2%.sf.ethereum.type.v2.TransactionTraceR\x05tra\
    ce\x12:\n\tblock_ref\x18\x02\x20\x01(\x0b2\x1d.sf.ethereum.type.v2.Block\
    RefR\x08blockRef\")\n\x0fTransactionRefs\x12\x16\n\x06hashes\x18\x01\x20\
    \x03(\x0cR\x06hashes\"6\n\x08BlockRef\x12\x12\n\x04hash\x18\x01\x20\x01(\
    \x0cR\x04hash\x12\x16\n\x06number\x18\x02\x20\x01(\x04R\x06number*N\n\
    \x16TransactionTraceStatus\x12\x0b\n\x07UNKNOWN\x10\0\x12\r\n\tSUCCEEDED\
    \x10\x01\x12\n\n\x06FAILED\x10\x02\x12\x0c\n\x08REVERTED\x10\x03*Y\n\x08\
    CallType\x12\x0f\n\x0bUNSPECIFIED\x10\0\x12\x08\n\x04CALL\x10\x01\x12\
    \x0c\n\x08CALLCODE\x10\x02\x12\x0c\n\x08DELEGATE\x10\x03\x12\n\n\x06STAT\
    IC\x10\x04\x12\n\n\x06CREATE\x10\x05BOZMgithub.com/streamingfast/firehos\
    e-ethereum/types/pb/sf/ethereum/type/v2;pbethJ\xa8\xcc\x01\n\x07\x12\x05\
    \0\0\xbc\x04\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\
    \x02\0\x1c\n\x08\n\x01\x08\x12\x03\x04\0d\n\t\n\x02\x08\x0b\x12\x03\x04\
    \0d\n\t\n\x02\x03\0\x12\x03\x06\0)\n\n\n\x02\x04\0\x12\x04\x08\07\x01\n\
    \n\n\x03\x04\0\x01\x12\x03\x08\x08\r\n(\n\x04\x04\0\x02\0\x12\x03\n\x02\
    \x11\x1a\x1b\x20Hash\x20is\x20the\x20block's\x20hash.\n\n\x0c\n\x05\x04\
    \0\x02\0\x05\x12\x03\n\x02\x07\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\n\x08\
    \x0c\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\n\x0f\x10\nJ\n\x04\x04\0\x02\
    \x01\x12\x03\x0c\x02\x14\x1a=\x20Number\x20is\x20the\x20block's\x20heigh\
    t\x20at\x20which\x20this\x20block\x20was\x20mined.\n\n\x0c\n\x05\x04\0\
    \x02\x01\x05\x12\x03\x0c\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\
    \x0c\t\x0f\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x0c\x12\x13\ng\n\x04\
    \x04\0\x02\x02\x12\x03\x0f\x02\x12\x1aZ\x20Size\x20is\x20the\x20size\x20\
    in\x20bytes\x20of\x20the\x20RLP\x20encoding\x20of\x20the\x20block\x20acc\
    ording\x20to\x20Ethereum\n\x20rules.\n\n\x0c\n\x05\x04\0\x02\x02\x05\x12\
    \x03\x0f\x02\x08\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x0f\t\r\n\x0c\n\
    \x05\x04\0\x02\x02\x03\x12\x03\x0f\x10\x11\n\x97\x01\n\x04\x04\0\x02\x03\
    \x12\x03\x12\x02\x19\x1a\x89\x01\x20Header\x20contain's\x20the\x20block'\
    s\x20header\x20information\x20like\x20its\x20parent\x20hash,\x20the\x20m\
    erkel\x20root\x20hash\n\x20and\x20all\x20other\x20information\x20the\x20\
    form\x20a\x20block.\n\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03\x12\x02\r\n\
    \x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x12\x0e\x14\n\x0c\n\x05\x04\0\x02\
    \x03\x03\x12\x03\x12\x17\x18\n\xaf\x02\n\x04\x04\0\x02\x04\x12\x03\x19\
    \x02\"\x1a\xa1\x02\x20Uncles\x20represents\x20block\x20produced\x20with\
    \x20a\x20valid\x20solution\x20but\x20were\x20not\x20actually\x20choosen\
    \n\x20as\x20the\x20canonical\x20block\x20for\x20the\x20given\x20height\
    \x20so\x20they\x20are\x20mostly\x20\"forked\"\x20blocks.\n\n\x20If\x20th\
    e\x20Block\x20has\x20been\x20produced\x20using\x20the\x20Proof\x20of\x20\
    Stake\x20consensus\x20algorithm,\x20this\n\x20field\x20will\x20actually\
    \x20be\x20always\x20empty.\n\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x03\x19\
    \x02\n\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03\x19\x0b\x16\n\x0c\n\x05\x04\
    \0\x02\x04\x01\x12\x03\x19\x17\x1d\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\
    \x19\x20!\n\xb3\x01\n\x04\x04\0\x02\x05\x12\x03\x1d\x024\x1a\xa5\x01\x20\
    TransactionTraces\x20hold\x20the\x20execute\x20trace\x20of\x20all\x20the\
    \x20transactions\x20that\x20were\x20executed\n\x20in\x20this\x20block.\
    \x20In\x20in\x20there\x20that\x20you\x20will\x20find\x20most\x20of\x20th\
    e\x20Ethereum\x20data\x20model.\n\n\x0c\n\x05\x04\0\x02\x05\x04\x12\x03\
    \x1d\x02\n\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03\x1d\x0b\x1b\n\x0c\n\x05\
    \x04\0\x02\x05\x01\x12\x03\x1d\x1c.\n\x0c\n\x05\x04\0\x02\x05\x03\x12\
    \x03\x1d13\n\x8b\x03\n\x04\x04\0\x02\x06\x12\x03$\x02.\x1a\xfd\x02\x20Ba\
    lanceChanges\x20here\x20is\x20the\x20array\x20of\x20ETH\x20transfer\x20t\
    hat\x20happened\x20at\x20the\x20block\x20level\n\x20outside\x20of\x20the\
    \x20normal\x20transaction\x20flow\x20of\x20a\x20block.\x20The\x20best\
    \x20example\x20of\x20this\x20is\x20mining\n\x20reward\x20for\x20the\x20b\
    lock\x20mined,\x20the\x20transfer\x20of\x20ETH\x20to\x20the\x20miner\x20\
    happens\x20outside\x20the\x20normal\n\x20transaction\x20flow\x20of\x20th\
    e\x20chain\x20and\x20is\x20recorded\x20as\x20a\x20`BalanceChange`\x20her\
    e\x20since\x20we\x20cannot\n\x20attached\x20it\x20to\x20any\x20transacti\
    on.\n\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03$\x02\n\n\x0c\n\x05\x04\0\x02\
    \x06\x06\x12\x03$\x0b\x18\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03$\x19(\n\
    \x0c\n\x05\x04\0\x02\x06\x03\x12\x03$+-\n\xce\x04\n\x04\x04\0\x02\x07\
    \x12\x03.\x02(\x1a\xc0\x04\x20CodeChanges\x20here\x20is\x20the\x20array\
    \x20of\x20smart\x20code\x20change\x20that\x20happened\x20that\x20happene\
    d\x20at\x20the\x20block\x20level\n\x20outside\x20of\x20the\x20normal\x20\
    transaction\x20flow\x20of\x20a\x20block.\x20Some\x20Ethereum's\x20fork\
    \x20like\x20BSC\x20and\x20Polygon\n\x20has\x20some\x20capabilities\x20to\
    \x20upgrade\x20internal\x20smart\x20contracts\x20used\x20usually\x20to\
    \x20track\x20the\x20validator\n\x20list.\n\n\x20On\x20hard\x20fork,\x20s\
    ome\x20procedure\x20runs\x20to\x20upgrade\x20the\x20smart\x20contract\
    \x20code\x20to\x20a\x20new\x20version.\x20In\x20those\n\x20network,\x20a\
    \x20`CodeChange`\x20for\x20each\x20modified\x20smart\x20contract\x20on\
    \x20upgrade\x20would\x20be\x20present\x20here.\x20Note\n\x20that\x20this\
    \x20happen\x20rarely,\x20so\x20the\x20vast\x20majority\x20of\x20block\
    \x20will\x20have\x20an\x20empty\x20list\x20here.\n\n\x0c\n\x05\x04\0\x02\
    \x07\x04\x12\x03.\x02\n\n\x0c\n\x05\x04\0\x02\x07\x06\x12\x03.\x0b\x15\n\
    \x0c\n\x05\x04\0\x02\x07\x01\x12\x03.\x16\"\n\x0c\n\x05\x04\0\x02\x07\
    \x03\x12\x03.%'\n>\n\x03\x04\0\t\x12\x030\x02\x0e\"2\x20bool\x20filterin\
    g_applied\x20=\x2040\x20[deprecated\x20=\x20true];\n\n\x0b\n\x04\x04\0\t\
    \0\x12\x030\x0b\r\n\x0c\n\x05\x04\0\t\0\x01\x12\x030\x0b\r\n\x0c\n\x05\
    \x04\0\t\0\x02\x12\x030\x0b\r\nL\n\x03\x04\0\t\x12\x031\x02\x0e\"@\x20st\
    ring\x20filtering_include_filter_expr\x20=\x2041\x20[deprecated\x20=\x20\
    true];\n\n\x0b\n\x04\x04\0\t\x01\x12\x031\x0b\r\n\x0c\n\x05\x04\0\t\x01\
    \x01\x12\x031\x0b\r\n\x0c\n\x05\x04\0\t\x01\x02\x12\x031\x0b\r\nL\n\x03\
    \x04\0\t\x12\x032\x02\x0e\"@\x20string\x20filtering_exclude_filter_expr\
    \x20=\x2042\x20[deprecated\x20=\x20true];\n\n\x0b\n\x04\x04\0\t\x02\x12\
    \x032\x0b\r\n\x0c\n\x05\x04\0\t\x02\x01\x12\x032\x0b\r\n\x0c\n\x05\x04\0\
    \t\x02\x02\x12\x032\x0b\r\n\xac\x01\n\x04\x04\0\x02\x08\x12\x036\x02\x10\
    \x1a\x9e\x01\x20Ver\x20represents\x20that\x20data\x20model\x20version\
    \x20of\x20the\x20block,\x20it\x20is\x20used\x20internally\x20by\x20Fireh\
    ose\x20on\x20Ethereum\n\x20as\x20a\x20validation\x20that\x20we\x20are\
    \x20reading\x20the\x20correct\x20version.\n\n\x0c\n\x05\x04\0\x02\x08\
    \x05\x12\x036\x02\x07\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x036\x08\x0b\n\
    \x0c\n\x05\x04\0\x02\x08\x03\x12\x036\x0e\x0f\n\x0b\n\x02\x04\x01\x12\
    \x059\0\x8e\x01\x01\n\n\n\x03\x04\x01\x01\x12\x039\x08\x13\n\x0b\n\x04\
    \x04\x01\x02\0\x12\x03:\x02\x18\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03:\
    \x02\x07\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03:\x08\x13\n\x0c\n\x05\x04\
    \x01\x02\0\x03\x12\x03:\x16\x17\n\x98\x03\n\x04\x04\x01\x02\x01\x12\x03A\
    \x02\x17\x1a\x8a\x03\x20Uncle\x20hash\x20of\x20the\x20block,\x20some\x20\
    reference\x20it\x20as\x20`sha3Uncles`,\x20but\x20`sha3``\x20is\x20badly\
    \x20worded,\x20so\x20we\x20prefer\x20`uncle_hash`,\x20also\n\x20referred\
    \x20as\x20`ommers`\x20in\x20EIP\x20specification.\n\n\x20If\x20the\x20Bl\
    ock\x20containing\x20this\x20`BlockHeader`\x20has\x20been\x20produced\
    \x20using\x20the\x20Proof\x20of\x20Stake\n\x20consensus\x20algorithm,\
    \x20this\x20field\x20will\x20actually\x20be\x20constant\x20and\x20set\
    \x20to\x20`0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d\
    49347`.\n\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03A\x02\x07\n\x0c\n\x05\
    \x04\x01\x02\x01\x01\x12\x03A\x08\x12\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x03A\x15\x16\n\x0b\n\x04\x04\x01\x02\x02\x12\x03C\x02\x15\n\x0c\n\
    \x05\x04\x01\x02\x02\x05\x12\x03C\x02\x07\n\x0c\n\x05\x04\x01\x02\x02\
    \x01\x12\x03C\x08\x10\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03C\x13\x14\n\
    \x0b\n\x04\x04\x01\x02\x03\x12\x03D\x02\x17\n\x0c\n\x05\x04\x01\x02\x03\
    \x05\x12\x03D\x02\x07\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03D\x08\x12\n\
    \x0c\n\x05\x04\x01\x02\x03\x03\x12\x03D\x15\x16\n\x0b\n\x04\x04\x01\x02\
    \x04\x12\x03E\x02\x1e\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\x03E\x02\x07\n\
    \x0c\n\x05\x04\x01\x02\x04\x01\x12\x03E\x08\x19\n\x0c\n\x05\x04\x01\x02\
    \x04\x03\x12\x03E\x1c\x1d\n\x0b\n\x04\x04\x01\x02\x05\x12\x03F\x02\x19\n\
    \x0c\n\x05\x04\x01\x02\x05\x05\x12\x03F\x02\x07\n\x0c\n\x05\x04\x01\x02\
    \x05\x01\x12\x03F\x08\x14\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03F\x17\
    \x18\n\x0b\n\x04\x04\x01\x02\x06\x12\x03G\x02\x17\n\x0c\n\x05\x04\x01\
    \x02\x06\x05\x12\x03G\x02\x07\n\x0c\n\x05\x04\x01\x02\x06\x01\x12\x03G\
    \x08\x12\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03G\x15\x16\n\x9a\x02\n\
    \x04\x04\x01\x02\x07\x12\x03M\x02\x18\x1a\x8c\x02\x20Difficulty\x20is\
    \x20the\x20difficulty\x20of\x20the\x20Proof\x20of\x20Work\x20algorithm\
    \x20that\x20was\x20required\x20to\x20compute\x20a\x20solution.\n\n\x20If\
    \x20the\x20Block\x20containing\x20this\x20`BlockHeader`\x20has\x20been\
    \x20produced\x20using\x20the\x20Proof\x20of\x20Stake\n\x20consensus\x20a\
    lgorithm,\x20this\x20field\x20will\x20actually\x20be\x20constant\x20and\
    \x20set\x20to\x20`0x00`.\n\n\x0c\n\x05\x04\x01\x02\x07\x06\x12\x03M\x02\
    \x08\n\x0c\n\x05\x04\x01\x02\x07\x01\x12\x03M\t\x13\n\x0c\n\x05\x04\x01\
    \x02\x07\x03\x12\x03M\x16\x17\n\xf0\x03\n\x04\x04\x01\x02\x08\x12\x03U\
    \x02\x1f\x1a\xe2\x03\x20TotalDifficulty\x20is\x20the\x20sum\x20of\x20all\
    \x20previous\x20blocks\x20difficulty\x20including\x20this\x20block\x20di\
    fficulty.\n\n\x20If\x20the\x20Block\x20containing\x20this\x20`BlockHeade\
    r`\x20has\x20been\x20produced\x20using\x20the\x20Proof\x20of\x20Stake\n\
    \x20consensus\x20algorithm,\x20this\x20field\x20will\x20actually\x20be\
    \x20constant\x20and\x20set\x20to\x20the\x20terminal\x20total\x20difficul\
    ty\n\x20that\x20was\x20required\x20to\x20transition\x20to\x20Proof\x20of\
    \x20Stake\x20algorithm,\x20which\x20varies\x20per\x20network.\x20It\x20i\
    s\x20set\x20to\n\x2058\x20750\x20000\x20000\x20000\x20000\x20000\x20000\
    \x20on\x20Ethereum\x20Mainnet\x20and\x20to\x2010\x20790\x20000\x20on\x20\
    Ethereum\x20Testnet\x20Goerli.\n\n\x0c\n\x05\x04\x01\x02\x08\x06\x12\x03\
    U\x02\x08\n\x0c\n\x05\x04\x01\x02\x08\x01\x12\x03U\t\x19\n\x0c\n\x05\x04\
    \x01\x02\x08\x03\x12\x03U\x1c\x1e\n\x0b\n\x04\x04\x01\x02\t\x12\x03W\x02\
    \x14\n\x0c\n\x05\x04\x01\x02\t\x05\x12\x03W\x02\x08\n\x0c\n\x05\x04\x01\
    \x02\t\x01\x12\x03W\t\x0f\n\x0c\n\x05\x04\x01\x02\t\x03\x12\x03W\x12\x13\
    \n\x0b\n\x04\x04\x01\x02\n\x12\x03X\x02\x18\n\x0c\n\x05\x04\x01\x02\n\
    \x05\x12\x03X\x02\x08\n\x0c\n\x05\x04\x01\x02\n\x01\x12\x03X\t\x12\n\x0c\
    \n\x05\x04\x01\x02\n\x03\x12\x03X\x15\x17\n\x0b\n\x04\x04\x01\x02\x0b\
    \x12\x03Y\x02\x17\n\x0c\n\x05\x04\x01\x02\x0b\x05\x12\x03Y\x02\x08\n\x0c\
    \n\x05\x04\x01\x02\x0b\x01\x12\x03Y\t\x11\n\x0c\n\x05\x04\x01\x02\x0b\
    \x03\x12\x03Y\x14\x16\n\x0b\n\x04\x04\x01\x02\x0c\x12\x03Z\x02+\n\x0c\n\
    \x05\x04\x01\x02\x0c\x06\x12\x03Z\x02\x1b\n\x0c\n\x05\x04\x01\x02\x0c\
    \x01\x12\x03Z\x1c%\n\x0c\n\x05\x04\x01\x02\x0c\x03\x12\x03Z(*\n\xac\x03\
    \n\x04\x04\x01\x02\r\x12\x03b\x02\x18\x1a\x9e\x03\x20ExtraData\x20is\x20\
    free-form\x20bytes\x20included\x20in\x20the\x20block\x20by\x20the\x20\"m\
    iner\".\x20While\x20on\x20Yellow\x20paper\x20of\n\x20Ethereum\x20this\
    \x20value\x20is\x20maxed\x20to\x2032\x20bytes,\x20other\x20consensus\x20\
    algorithm\x20like\x20Clique\x20and\x20some\x20other\n\x20forks\x20are\
    \x20using\x20bigger\x20values\x20to\x20carry\x20special\x20consensus\x20\
    data.\n\n\x20If\x20the\x20Block\x20containing\x20this\x20`BlockHeader`\
    \x20has\x20been\x20produced\x20using\x20the\x20Proof\x20of\x20Stake\n\
    \x20consensus\x20algorithm,\x20this\x20field\x20is\x20strictly\x20enforc\
    ed\x20to\x20be\x20<=\x2032\x20bytes.\n\n\x0c\n\x05\x04\x01\x02\r\x05\x12\
    \x03b\x02\x07\n\x0c\n\x05\x04\x01\x02\r\x01\x12\x03b\x08\x12\n\x0c\n\x05\
    \x04\x01\x02\r\x03\x12\x03b\x15\x17\n\xa7\x01\n\x04\x04\x01\x02\x0e\x12\
    \x03f\x02\x16\x1a\x99\x01\x20MixHash\x20is\x20used\x20to\x20prove,\x20wh\
    en\x20combined\x20with\x20the\x20`nonce`\x20that\x20sufficient\x20amount\
    \x20of\x20computation\x20has\x20been\n\x20achieved\x20and\x20that\x20the\
    \x20solution\x20found\x20is\x20valid.\n\n\x0c\n\x05\x04\x01\x02\x0e\x05\
    \x12\x03f\x02\x07\n\x0c\n\x05\x04\x01\x02\x0e\x01\x12\x03f\x08\x10\n\x0c\
    \n\x05\x04\x01\x02\x0e\x03\x12\x03f\x13\x15\n\xcb\x02\n\x04\x04\x01\x02\
    \x0f\x12\x03m\x02\x14\x1a\xbd\x02\x20Nonce\x20is\x20used\x20to\x20prove,\
    \x20when\x20combined\x20with\x20the\x20`mix_hash`\x20that\x20sufficient\
    \x20amount\x20of\x20computation\x20has\x20been\n\x20achieved\x20and\x20t\
    hat\x20the\x20solution\x20found\x20is\x20valid.\n\n\x20If\x20the\x20Bloc\
    k\x20containing\x20this\x20`BlockHeader`\x20has\x20been\x20produced\x20u\
    sing\x20the\x20Proof\x20of\x20Stake\n\x20consensus\x20algorithm,\x20this\
    \x20field\x20will\x20actually\x20be\x20constant\x20and\x20set\x20to\x20`\
    0`.\n\n\x0c\n\x05\x04\x01\x02\x0f\x05\x12\x03m\x02\x08\n\x0c\n\x05\x04\
    \x01\x02\x0f\x01\x12\x03m\t\x0e\n\x0c\n\x05\x04\x01\x02\x0f\x03\x12\x03m\
    \x11\x13\n\xdf\x03\n\x04\x04\x01\x02\x10\x12\x04\x85\x01\x02\x12\x1a\xd0\
    \x03\x20Hash\x20is\x20the\x20hash\x20of\x20the\x20block\x20which\x20is\
    \x20actually\x20the\x20computation:\n\n\x20\x20Keccak256(rlp([\n\x20\x20\
    \x20\x20parent_hash,\n\x20\x20\x20\x20uncle_hash,\n\x20\x20\x20\x20coinb\
    ase,\n\x20\x20\x20\x20state_root,\n\x20\x20\x20\x20transactions_root,\n\
    \x20\x20\x20\x20receipt_root,\n\x20\x20\x20\x20logs_bloom,\n\x20\x20\x20\
    \x20difficulty,\n\x20\x20\x20\x20number,\n\x20\x20\x20\x20gas_limit,\n\
    \x20\x20\x20\x20gas_used,\n\x20\x20\x20\x20timestamp,\n\x20\x20\x20\x20e\
    xtra_data,\n\x20\x20\x20\x20mix_hash,\n\x20\x20\x20\x20nonce,\n\x20\x20\
    \x20\x20base_fee_per_gas\x20(to\x20be\x20included,\x20only\x20if\x20Lond\
    on\x20Fork\x20is\x20active)\n\x20\x20\x20\x20withdrawals_root\x20(to\x20\
    be\x20included,\x20only\x20if\x20Shangai\x20Fork\x20is\x20active)\n\x20\
    \x20]))\n\n\n\r\n\x05\x04\x01\x02\x10\x05\x12\x04\x85\x01\x02\x07\n\r\n\
    \x05\x04\x01\x02\x10\x01\x12\x04\x85\x01\x08\x0c\n\r\n\x05\x04\x01\x02\
    \x10\x03\x12\x04\x85\x01\x0f\x11\n\x83\x01\n\x04\x04\x01\x02\x11\x12\x04\
    \x88\x01\x02\x1f\x1au\x20Base\x20fee\x20per\x20gas\x20according\x20to\
    \x20EIP-1559\x20(e.g.\x20London\x20Fork)\x20rules,\x20only\x20set\x20if\
    \x20London\x20is\x20present/active\x20on\x20the\x20chain.\n\n\r\n\x05\
    \x04\x01\x02\x11\x06\x12\x04\x88\x01\x02\x08\n\r\n\x05\x04\x01\x02\x11\
    \x01\x12\x04\x88\x01\t\x19\n\r\n\x05\x04\x01\x02\x11\x03\x12\x04\x88\x01\
    \x1c\x1e\n\x8a\x01\n\x04\x04\x01\x02\x12\x12\x04\x8b\x01\x02\x1e\x1a|\
    \x20Withdrawals\x20root\x20hash\x20according\x20to\x20EIP-4895\x20(e.g.\
    \x20Shangai\x20Fork)\x20rules,\x20only\x20set\x20if\x20Shangai\x20is\x20\
    present/active\x20on\x20the\x20chain.\n\n\r\n\x05\x04\x01\x02\x12\x05\
    \x12\x04\x8b\x01\x02\x07\n\r\n\x05\x04\x01\x02\x12\x01\x12\x04\x8b\x01\
    \x08\x18\n\r\n\x05\x04\x01\x02\x12\x03\x12\x04\x8b\x01\x1b\x1d\n\x0c\n\
    \x04\x04\x01\x02\x13\x12\x04\x8d\x01\x02'\n\r\n\x05\x04\x01\x02\x13\x06\
    \x12\x04\x8d\x01\x02\x13\n\r\n\x05\x04\x01\x02\x13\x01\x12\x04\x8d\x01\
    \x14!\n\r\n\x05\x04\x01\x02\x13\x03\x12\x04\x8d\x01$&\n\x0c\n\x02\x04\
    \x02\x12\x06\x90\x01\0\x92\x01\x01\n\x0b\n\x03\x04\x02\x01\x12\x04\x90\
    \x01\x08\x19\n\x0c\n\x04\x04\x02\x02\0\x12\x04\x91\x01\x02\x1f\n\r\n\x05\
    \x04\x02\x02\0\x04\x12\x04\x91\x01\x02\n\n\r\n\x05\x04\x02\x02\0\x06\x12\
    \x04\x91\x01\x0b\x16\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\x91\x01\x17\x1a\
    \n\r\n\x05\x04\x02\x02\0\x03\x12\x04\x91\x01\x1d\x1e\n\x0c\n\x02\x04\x03\
    \x12\x06\x94\x01\0\x96\x01\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\x94\x01\
    \x08\x13\n\x0c\n\x04\x04\x03\x02\0\x12\x04\x95\x01\x02\x1a\n\r\n\x05\x04\
    \x03\x02\0\x04\x12\x04\x95\x01\x02\n\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\
    \x95\x01\x0b\x11\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\x95\x01\x12\x15\n\r\
    \n\x05\x04\x03\x02\0\x03\x12\x04\x95\x01\x18\x19\n\x0c\n\x02\x04\x04\x12\
    \x06\x98\x01\0\x9a\x01\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\x98\x01\x08\
    \x0e\n\x0c\n\x04\x04\x04\x02\0\x12\x04\x99\x01\x02\x12\n\r\n\x05\x04\x04\
    \x02\0\x05\x12\x04\x99\x01\x02\x07\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\
    \x99\x01\x08\r\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\x99\x01\x10\x11\n\x0c\
    \n\x02\x04\x05\x12\x06\x9c\x01\0\x8d\x02\x01\n\x0b\n\x03\x04\x05\x01\x12\
    \x04\x9c\x01\x08\x18\n\x19\n\x04\x04\x05\x02\0\x12\x04\x9e\x01\x02\x0f\
    \x1a\x0b\x20consensus\n\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\x9e\x01\x02\
    \x07\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x9e\x01\x08\n\n\r\n\x05\x04\x05\
    \x02\0\x03\x12\x04\x9e\x01\r\x0e\n\x0c\n\x04\x04\x05\x02\x01\x12\x04\x9f\
    \x01\x02\x13\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\x9f\x01\x02\x08\n\r\n\
    \x05\x04\x05\x02\x01\x01\x12\x04\x9f\x01\t\x0e\n\r\n\x05\x04\x05\x02\x01\
    \x03\x12\x04\x9f\x01\x11\x12\n\xc7\x05\n\x04\x04\x05\x02\x02\x12\x04\xa9\
    \x01\x02\x17\x1a\xb8\x05\x20GasPrice\x20represents\x20the\x20effective\
    \x20price\x20that\x20has\x20been\x20paid\x20for\x20each\x20gas\x20unit\
    \x20of\x20this\x20transaction.\x20Over\x20time,\x20the\n\x20Ethereum\x20\
    rules\x20changes\x20regarding\x20GasPrice\x20field\x20here.\x20Before\
    \x20London\x20fork,\x20the\x20GasPrice\x20was\x20always\x20set\x20to\x20\
    the\n\x20fixed\x20gas\x20price.\x20After\x20London\x20fork,\x20this\x20v\
    alue\x20has\x20different\x20meaning\x20depending\x20on\x20the\x20transac\
    tion\x20type\x20(see\x20`Type`\x20field).\n\n\x20In\x20cases\x20where\
    \x20`TransactionTrace.Type\x20==\x20TRX_TYPE_LEGACY\x20||\x20TRX_TYPE_AC\
    CESS_LIST`,\x20then\x20GasPrice\x20has\x20the\x20same\x20meaning\n\x20as\
    \x20before\x20the\x20London\x20fork.\n\n\x20In\x20cases\x20where\x20`Tra\
    nsactionTrace.Type\x20==\x20TRX_TYPE_DYNAMIC_FEE`,\x20then\x20GasPrice\
    \x20is\x20the\x20effective\x20gas\x20price\x20paid\n\x20for\x20the\x20tr\
    ansaction\x20which\x20is\x20equals\x20to\x20`BlockHeader.BaseFeePerGas\
    \x20+\x20TransactionTrace.`\n\n\r\n\x05\x04\x05\x02\x02\x06\x12\x04\xa9\
    \x01\x02\x08\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xa9\x01\t\x12\n\r\n\
    \x05\x04\x05\x02\x02\x03\x12\x04\xa9\x01\x15\x16\n\xa1\x01\n\x04\x04\x05\
    \x02\x03\x12\x04\xad\x01\x02\x17\x1a\x92\x01\x20GasLimit\x20is\x20the\
    \x20maximum\x20of\x20gas\x20unit\x20the\x20sender\x20of\x20the\x20transa\
    ction\x20is\x20willing\x20to\x20consume\x20when\x20perform\x20the\x20EVM\
    \n\x20execution\x20of\x20the\x20whole\x20transaction\n\n\r\n\x05\x04\x05\
    \x02\x03\x05\x12\x04\xad\x01\x02\x08\n\r\n\x05\x04\x05\x02\x03\x01\x12\
    \x04\xad\x01\t\x12\n\r\n\x05\x04\x05\x02\x03\x03\x12\x04\xad\x01\x15\x16\
    \nU\n\x04\x04\x05\x02\x04\x12\x04\xb0\x01\x02\x13\x1aG\x20Value\x20is\
    \x20the\x20amount\x20of\x20Ether\x20transferred\x20as\x20part\x20of\x20t\
    his\x20transaction.\n\n\r\n\x05\x04\x05\x02\x04\x06\x12\x04\xb0\x01\x02\
    \x08\n\r\n\x05\x04\x05\x02\x04\x01\x12\x04\xb0\x01\t\x0e\n\r\n\x05\x04\
    \x05\x02\x04\x03\x12\x04\xb0\x01\x11\x12\nM\n\x04\x04\x05\x02\x05\x12\
    \x04\xb3\x01\x02\x12\x1a?\x20Input\x20data\x20the\x20transaction\x20will\
    \x20receive\x20for\x20execution\x20of\x20EVM.\n\n\r\n\x05\x04\x05\x02\
    \x05\x05\x12\x04\xb3\x01\x02\x07\n\r\n\x05\x04\x05\x02\x05\x01\x12\x04\
    \xb3\x01\x08\r\n\r\n\x05\x04\x05\x02\x05\x03\x12\x04\xb3\x01\x10\x11\nE\
    \n\x04\x04\x05\x02\x06\x12\x04\xb6\x01\x02\x0e\x1a7\x20V\x20is\x20the\
    \x20recovery\x20ID\x20value\x20for\x20the\x20signature\x20Y\x20point.\n\
    \n\r\n\x05\x04\x05\x02\x06\x05\x12\x04\xb6\x01\x02\x07\n\r\n\x05\x04\x05\
    \x02\x06\x01\x12\x04\xb6\x01\x08\t\n\r\n\x05\x04\x05\x02\x06\x03\x12\x04\
    \xb6\x01\x0c\r\nN\n\x04\x04\x05\x02\x07\x12\x04\xb9\x01\x02\x0e\x1a@\x20\
    R\x20is\x20the\x20signature's\x20X\x20point\x20on\x20the\x20elliptic\x20\
    curve\x20(32\x20bytes).\n\n\r\n\x05\x04\x05\x02\x07\x05\x12\x04\xb9\x01\
    \x02\x07\n\r\n\x05\x04\x05\x02\x07\x01\x12\x04\xb9\x01\x08\t\n\r\n\x05\
    \x04\x05\x02\x07\x03\x12\x04\xb9\x01\x0c\r\nN\n\x04\x04\x05\x02\x08\x12\
    \x04\xbc\x01\x02\x0e\x1a@\x20S\x20is\x20the\x20signature's\x20Y\x20point\
    \x20on\x20the\x20elliptic\x20curve\x20(32\x20bytes).\n\n\r\n\x05\x04\x05\
    \x02\x08\x05\x12\x04\xbc\x01\x02\x07\n\r\n\x05\x04\x05\x02\x08\x01\x12\
    \x04\xbc\x01\x08\t\n\r\n\x05\x04\x05\x02\x08\x03\x12\x04\xbc\x01\x0c\r\n\
    h\n\x04\x04\x05\x02\t\x12\x04\xbf\x01\x02\x17\x1aZ\x20GasUsed\x20is\x20t\
    he\x20total\x20amount\x20of\x20gas\x20unit\x20used\x20for\x20the\x20whol\
    e\x20execution\x20of\x20the\x20transaction.\n\n\r\n\x05\x04\x05\x02\t\
    \x05\x12\x04\xbf\x01\x02\x08\n\r\n\x05\x04\x05\x02\t\x01\x12\x04\xbf\x01\
    \t\x11\n\r\n\x05\x04\x05\x02\t\x03\x12\x04\xbf\x01\x14\x16\n\x90\x02\n\
    \x04\x04\x05\x02\n\x12\x04\xc3\x01\x02\x11\x1a\x81\x02\x20Type\x20repres\
    ents\x20the\x20Ethereum\x20transaction\x20type,\x20available\x20only\x20\
    since\x20EIP-2718\x20&\x20EIP-2930\x20activation\x20which\x20happened\
    \x20on\x20Berlin\x20fork.\n\x20The\x20value\x20is\x20always\x20set\x20ev\
    en\x20for\x20transaction\x20before\x20Berlin\x20fork\x20because\x20those\
    \x20before\x20the\x20fork\x20are\x20still\x20legacy\x20transactions.\n\n\
    \r\n\x05\x04\x05\x02\n\x06\x12\x04\xc3\x01\x02\x06\n\r\n\x05\x04\x05\x02\
    \n\x01\x12\x04\xc3\x01\x07\x0b\n\r\n\x05\x04\x05\x02\n\x03\x12\x04\xc3\
    \x01\x0e\x10\n\x0e\n\x04\x04\x05\x04\0\x12\x06\xc5\x01\x02\xd3\x01\x03\n\
    \r\n\x05\x04\x05\x04\0\x01\x12\x04\xc5\x01\x07\x0b\ng\n\x06\x04\x05\x04\
    \0\x02\0\x12\x04\xc7\x01\x04\x18\x1aW\x20All\x20transactions\x20that\x20\
    ever\x20existed\x20prior\x20Berlin\x20fork\x20before\x20EIP-2718\x20was\
    \x20implemented.\n\n\x0f\n\x07\x04\x05\x04\0\x02\0\x01\x12\x04\xc7\x01\
    \x04\x13\n\x0f\n\x07\x04\x05\x04\0\x02\0\x02\x12\x04\xc7\x01\x16\x17\n\
    \xa5\x01\n\x06\x04\x05\x04\0\x02\x01\x12\x04\xcd\x01\x04\x1d\x1a\x94\x01\
    \x20Transaction\x20that\x20specicy\x20an\x20access\x20list\x20of\x20cont\
    ract/storage_keys\x20that\x20is\x20going\x20to\x20be\x20used\n\x20in\x20\
    this\x20transaction.\n\n\x20Added\x20in\x20Berlin\x20fork\x20(EIP-2930).\
    \n\n\x0f\n\x07\x04\x05\x04\0\x02\x01\x01\x12\x04\xcd\x01\x04\x18\n\x0f\n\
    \x07\x04\x05\x04\0\x02\x01\x02\x12\x04\xcd\x01\x1b\x1c\n\xc9\x02\n\x06\
    \x04\x05\x04\0\x02\x02\x12\x04\xd2\x01\x04\x1d\x1a\xb8\x02\x20Transactio\
    n\x20that\x20specifis\x20an\x20access\x20list\x20just\x20like\x20TRX_TYP\
    E_ACCESS_LIST\x20but\x20in\x20addition\x20defines\x20the\n\x20max\x20bas\
    e\x20gas\x20gee\x20and\x20max\x20priority\x20gas\x20fee\x20to\x20pay\x20\
    for\x20this\x20transaction.\x20Transaction's\x20of\x20those\x20type\x20a\
    re\n\x20executed\x20against\x20EIP-1559\x20rules\x20which\x20dictates\
    \x20a\x20dynamic\x20gas\x20cost\x20based\x20on\x20the\x20congestion\x20o\
    f\x20the\x20network.\n\n\x0f\n\x07\x04\x05\x04\0\x02\x02\x01\x12\x04\xd2\
    \x01\x04\x18\n\x0f\n\x07\x04\x05\x04\0\x02\x02\x02\x12\x04\xd2\x01\x1b\
    \x1c\n\x81\x03\n\x04\x04\x05\x02\x0b\x12\x04\xda\x01\x02(\x1a\xf2\x02\
    \x20AcccessList\x20represents\x20the\x20storage\x20access\x20this\x20tra\
    nsaction\x20has\x20agreed\x20to\x20do\x20in\x20which\x20case\x20those\
    \x20storage\n\x20access\x20cost\x20less\x20gas\x20unit\x20per\x20access.\
    \n\n\x20This\x20will\x20is\x20populated\x20only\x20if\x20`TransactionTra\
    ce.Type\x20==\x20TRX_TYPE_ACCESS_LIST\x20||\x20TRX_TYPE_DYNAMIC_FEE`\x20\
    which\n\x20is\x20possible\x20only\x20if\x20Berlin\x20(TRX_TYPE_ACCESS_LI\
    ST)\x20nor\x20London\x20(TRX_TYPE_DYNAMIC_FEE)\x20fork\x20are\x20active\
    \x20on\x20the\x20chain.\n\n\r\n\x05\x04\x05\x02\x0b\x04\x12\x04\xda\x01\
    \x02\n\n\r\n\x05\x04\x05\x02\x0b\x06\x12\x04\xda\x01\x0b\x16\n\r\n\x05\
    \x04\x05\x02\x0b\x01\x12\x04\xda\x01\x17\"\n\r\n\x05\x04\x05\x02\x0b\x03\
    \x12\x04\xda\x01%'\n\x82\x02\n\x04\x04\x05\x02\x0c\x12\x04\xe0\x01\x02\
    \x1e\x1a\xf3\x01\x20MaxFeePerGas\x20is\x20the\x20maximum\x20fee\x20per\
    \x20gas\x20the\x20user\x20is\x20willing\x20to\x20pay\x20for\x20the\x20tr\
    ansaction\x20gas\x20used.\n\n\x20This\x20will\x20is\x20populated\x20only\
    \x20if\x20`TransactionTrace.Type\x20==\x20TRX_TYPE_DYNAMIC_FEE`\x20which\
    \x20is\x20possible\x20only\n\x20if\x20Londong\x20fork\x20is\x20active\
    \x20on\x20the\x20chain.\n\n\r\n\x05\x04\x05\x02\x0c\x06\x12\x04\xe0\x01\
    \x02\x08\n\r\n\x05\x04\x05\x02\x0c\x01\x12\x04\xe0\x01\t\x18\n\r\n\x05\
    \x04\x05\x02\x0c\x03\x12\x04\xe0\x01\x1b\x1d\n\x95\x02\n\x04\x04\x05\x02\
    \r\x12\x04\xe7\x01\x02'\x1a\x86\x02\x20MaxPriorityFeePerGas\x20is\x20pri\
    ority\x20fee\x20per\x20gas\x20the\x20user\x20to\x20pay\x20in\x20extra\
    \x20to\x20the\x20miner\x20on\x20top\x20of\x20the\x20block's\n\x20base\
    \x20fee.\n\n\x20This\x20will\x20is\x20populated\x20only\x20if\x20`Transa\
    ctionTrace.Type\x20==\x20TRX_TYPE_DYNAMIC_FEE`\x20which\x20is\x20possibl\
    e\x20only\n\x20if\x20Londong\x20fork\x20is\x20active\x20on\x20the\x20cha\
    in.\n\n\r\n\x05\x04\x05\x02\r\x06\x12\x04\xe7\x01\x02\x08\n\r\n\x05\x04\
    \x05\x02\r\x01\x12\x04\xe7\x01\t!\n\r\n\x05\x04\x05\x02\r\x03\x12\x04\
    \xe7\x01$&\n\x14\n\x04\x04\x05\x02\x0e\x12\x04\xea\x01\x02\x14\x1a\x06\
    \x20meta\n\n\r\n\x05\x04\x05\x02\x0e\x05\x12\x04\xea\x01\x02\x08\n\r\n\
    \x05\x04\x05\x02\x0e\x01\x12\x04\xea\x01\t\x0e\n\r\n\x05\x04\x05\x02\x0e\
    \x03\x12\x04\xea\x01\x11\x13\n\x0c\n\x04\x04\x05\x02\x0f\x12\x04\xeb\x01\
    \x02\x12\n\r\n\x05\x04\x05\x02\x0f\x05\x12\x04\xeb\x01\x02\x07\n\r\n\x05\
    \x04\x05\x02\x0f\x01\x12\x04\xeb\x01\x08\x0c\n\r\n\x05\x04\x05\x02\x0f\
    \x03\x12\x04\xeb\x01\x0f\x11\n\x0c\n\x04\x04\x05\x02\x10\x12\x04\xec\x01\
    \x02\x12\n\r\n\x05\x04\x05\x02\x10\x05\x12\x04\xec\x01\x02\x07\n\r\n\x05\
    \x04\x05\x02\x10\x01\x12\x04\xec\x01\x08\x0c\n\r\n\x05\x04\x05\x02\x10\
    \x03\x12\x04\xec\x01\x0f\x11\n\x0c\n\x04\x04\x05\x02\x11\x12\x04\xed\x01\
    \x02\x19\n\r\n\x05\x04\x05\x02\x11\x05\x12\x04\xed\x01\x02\x07\n\r\n\x05\
    \x04\x05\x02\x11\x01\x12\x04\xed\x01\x08\x13\n\r\n\x05\x04\x05\x02\x11\
    \x03\x12\x04\xed\x01\x16\x18\n\x0c\n\x04\x04\x05\x02\x12\x12\x04\xee\x01\
    \x02\x18\n\r\n\x05\x04\x05\x02\x12\x05\x12\x04\xee\x01\x02\x07\n\r\n\x05\
    \x04\x05\x02\x12\x01\x12\x04\xee\x01\x08\x12\n\r\n\x05\x04\x05\x02\x12\
    \x03\x12\x04\xee\x01\x15\x17\n\x0c\n\x04\x04\x05\x02\x13\x12\x04\xef\x01\
    \x02\x1c\n\r\n\x05\x04\x05\x02\x13\x05\x12\x04\xef\x01\x02\x08\n\r\n\x05\
    \x04\x05\x02\x13\x01\x12\x04\xef\x01\t\x16\n\r\n\x05\x04\x05\x02\x13\x03\
    \x12\x04\xef\x01\x19\x1b\n\x0c\n\x04\x04\x05\x02\x14\x12\x04\xf0\x01\x02\
    \x1a\n\r\n\x05\x04\x05\x02\x14\x05\x12\x04\xf0\x01\x02\x08\n\r\n\x05\x04\
    \x05\x02\x14\x01\x12\x04\xf0\x01\t\x14\n\r\n\x05\x04\x05\x02\x14\x03\x12\
    \x04\xf0\x01\x17\x19\n\xd7\r\n\x04\x04\x05\x02\x15\x12\x04\x8a\x02\x02%\
    \x1a\xc8\r\x20TransactionTraceStatus\x20is\x20the\x20status\x20of\x20the\
    \x20transaction\x20execution\x20and\x20will\x20let\x20you\x20know\x20if\
    \x20the\x20transaction\n\x20was\x20successful\x20or\x20not.\n\n\x20A\x20\
    successful\x20transaction\x20has\x20been\x20recorded\x20to\x20the\x20blo\
    ckchain's\x20state\x20for\x20calls\x20in\x20it\x20that\x20were\x20succes\
    sful.\n\x20This\x20means\x20it's\x20possible\x20only\x20a\x20subset\x20o\
    f\x20the\x20calls\x20were\x20properly\x20recorded,\x20refer\x20to\x20[ca\
    lls[].state_reverted]\x20field\n\x20to\x20determine\x20which\x20calls\
    \x20were\x20reverted.\n\n\x20A\x20quirks\x20of\x20the\x20Ethereum\x20pro\
    tocol\x20is\x20that\x20a\x20transaction\x20`FAILED`\x20or\x20`REVERTED`\
    \x20still\x20affects\x20the\x20blockchain's\n\x20state\x20for\x20**some*\
    *\x20of\x20the\x20state\x20changes.\x20Indeed,\x20in\x20those\x20cases,\
    \x20the\x20transactions\x20fees\x20are\x20still\x20paid\x20to\x20the\x20\
    miner\n\x20which\x20means\x20there\x20is\x20a\x20balance\x20change\x20fo\
    r\x20the\x20transaction's\x20emitter\x20(e.g.\x20`from`)\x20to\x20pay\
    \x20the\x20gas\x20fees,\x20an\x20optional\n\x20balance\x20change\x20for\
    \x20gas\x20refunded\x20to\x20the\x20transaction's\x20emitter\x20(e.g.\
    \x20`from`)\x20and\x20a\x20balance\x20change\x20for\x20the\x20miner\x20w\
    ho\n\x20received\x20the\x20transaction\x20fees.\x20There\x20is\x20also\
    \x20a\x20nonce\x20change\x20for\x20the\x20transaction's\x20emitter\x20(e\
    .g.\x20`from`).\n\n\x20This\x20means\x20that\x20to\x20properly\x20record\
    \x20the\x20state\x20changes\x20for\x20a\x20transaction,\x20you\x20need\
    \x20to\x20conditionally\x20procees\x20the\n\x20transaction's\x20status.\
    \n\n\x20For\x20a\x20`SUCCEEDED`\x20transaction,\x20you\x20iterate\x20ove\
    r\x20the\x20`calls`\x20array\x20and\x20record\x20the\x20state\x20changes\
    \x20for\x20each\x20call\x20for\n\x20which\x20`state_reverted\x20==\x20fa\
    lse`\x20(if\x20a\x20transaction\x20succeeded,\x20the\x20call\x20at\x20#0\
    \x20will\x20always\x20`state_reverted\x20==\x20false`\n\x20because\x20it\
    \x20aligns\x20with\x20the\x20transaction).\n\n\x20For\x20a\x20`FAILED`\
    \x20or\x20`REVERTED`\x20transaction,\x20you\x20iterate\x20over\x20the\
    \x20root\x20call\x20(e.g.\x20at\x20#0,\x20will\x20always\x20exist)\x20fo\
    r\n\x20balance\x20changes\x20you\x20process\x20those\x20where\x20`reason\
    `\x20is\x20either\x20`REASON_GAS_BUY`,\x20`REASON_GAS_REFUND`\x20or\n\
    \x20`REASON_REWARD_TRANSACTION_FEE`\x20and\x20for\x20nonce\x20change,\
    \x20still\x20on\x20the\x20root\x20call,\x20you\x20pick\x20the\x20nonce\
    \x20change\x20which\x20the\n\x20smallest\x20ordinal\x20(if\x20more\x20th\
    an\x20one).\n\n\r\n\x05\x04\x05\x02\x15\x06\x12\x04\x8a\x02\x02\x18\n\r\
    \n\x05\x04\x05\x02\x15\x01\x12\x04\x8a\x02\x19\x1f\n\r\n\x05\x04\x05\x02\
    \x15\x03\x12\x04\x8a\x02\"$\n\x0c\n\x04\x04\x05\x02\x16\x12\x04\x8b\x02\
    \x02\"\n\r\n\x05\x04\x05\x02\x16\x06\x12\x04\x8b\x02\x02\x14\n\r\n\x05\
    \x04\x05\x02\x16\x01\x12\x04\x8b\x02\x15\x1c\n\r\n\x05\x04\x05\x02\x16\
    \x03\x12\x04\x8b\x02\x1f!\n\x0c\n\x04\x04\x05\x02\x17\x12\x04\x8c\x02\
    \x02\x1b\n\r\n\x05\x04\x05\x02\x17\x04\x12\x04\x8c\x02\x02\n\n\r\n\x05\
    \x04\x05\x02\x17\x06\x12\x04\x8c\x02\x0b\x0f\n\r\n\x05\x04\x05\x02\x17\
    \x01\x12\x04\x8c\x02\x10\x15\n\r\n\x05\x04\x05\x02\x17\x03\x12\x04\x8c\
    \x02\x18\x1a\n\x86\x01\n\x02\x04\x06\x12\x06\x91\x02\0\x94\x02\x01\x1ax\
    \x20AccessTuple\x20represents\x20a\x20list\x20of\x20storage\x20keys\x20f\
    or\x20a\x20given\x20contract's\x20address\x20and\x20is\x20used\n\x20for\
    \x20AccessList\x20construction.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\x91\
    \x02\x08\x13\n\x0c\n\x04\x04\x06\x02\0\x12\x04\x92\x02\x02\x14\n\r\n\x05\
    \x04\x06\x02\0\x05\x12\x04\x92\x02\x02\x07\n\r\n\x05\x04\x06\x02\0\x01\
    \x12\x04\x92\x02\x08\x0f\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\x92\x02\x12\
    \x13\n\x0c\n\x04\x04\x06\x02\x01\x12\x04\x93\x02\x02\"\n\r\n\x05\x04\x06\
    \x02\x01\x04\x12\x04\x93\x02\x02\n\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\
    \x93\x02\x0b\x10\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\x93\x02\x11\x1d\n\
    \r\n\x05\x04\x06\x02\x01\x03\x12\x04\x93\x02\x20!\n\x0c\n\x02\x05\0\x12\
    \x06\x96\x02\0\x9b\x02\x01\n\x0b\n\x03\x05\0\x01\x12\x04\x96\x02\x05\x1b\
    \n\x0c\n\x04\x05\0\x02\0\x12\x04\x97\x02\x02\x0e\n\r\n\x05\x05\0\x02\0\
    \x01\x12\x04\x97\x02\x02\t\n\r\n\x05\x05\0\x02\0\x02\x12\x04\x97\x02\x0c\
    \r\n\x0c\n\x04\x05\0\x02\x01\x12\x04\x98\x02\x02\x10\n\r\n\x05\x05\0\x02\
    \x01\x01\x12\x04\x98\x02\x02\x0b\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\x98\
    \x02\x0e\x0f\n\x0c\n\x04\x05\0\x02\x02\x12\x04\x99\x02\x02\r\n\r\n\x05\
    \x05\0\x02\x02\x01\x12\x04\x99\x02\x02\x08\n\r\n\x05\x05\0\x02\x02\x02\
    \x12\x04\x99\x02\x0b\x0c\n\x0c\n\x04\x05\0\x02\x03\x12\x04\x9a\x02\x02\
    \x0f\n\r\n\x05\x05\0\x02\x03\x01\x12\x04\x9a\x02\x02\n\n\r\n\x05\x05\0\
    \x02\x03\x02\x12\x04\x9a\x02\r\x0e\n\x0c\n\x02\x04\x07\x12\x06\x9d\x02\0\
    \xad\x02\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\x9d\x02\x08\x1a\n\xa5\x05\n\
    \x04\x04\x07\x02\0\x12\x04\xa9\x02\x02\x17\x1a\x96\x05\x20State\x20root\
    \x20is\x20an\x20intermediate\x20state_root\x20hash,\x20computed\x20in-be\
    tween\x20transactions\x20to\x20make\n\x20**sure**\x20you\x20could\x20bui\
    ld\x20a\x20proof\x20and\x20point\x20to\x20state\x20in\x20the\x20middle\
    \x20of\x20a\x20block.\x20Geth\x20client\n\x20uses\x20`PostState\x20+\x20\
    root\x20+\x20PostStateOrStatus``\x20while\x20Parity\x20used\x20`status_c\
    ode,\x20root...``\x20this\x20piles\n\x20hardforks,\x20see\x20(read\x20th\
    e\x20EIPs\x20first):\n\x20-\x20https://github.com/ethereum/EIPs/blob/mas\
    ter/EIPS/eip-658.md\n\n\x20Moreover,\x20the\x20notion\x20of\x20`Outcome`\
    `\x20in\x20parity,\x20which\x20segregates\x20the\x20two\x20concepts,\x20\
    which\x20are\n\x20stored\x20in\x20the\x20same\x20field\x20`status_code``\
    \x20can\x20be\x20computed\x20based\x20on\x20such\x20a\x20hack\x20of\x20t\
    he\x20`state_root`\n\x20field,\x20following\x20`EIP-658`.\n\n\x20Before\
    \x20Byzantinium\x20hard\x20fork,\x20this\x20field\x20is\x20always\x20emp\
    ty.\n\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xa9\x02\x02\x07\n\r\n\x05\x04\
    \x07\x02\0\x01\x12\x04\xa9\x02\x08\x12\n\r\n\x05\x04\x07\x02\0\x03\x12\
    \x04\xa9\x02\x15\x16\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\xaa\x02\x02!\n\
    \r\n\x05\x04\x07\x02\x01\x05\x12\x04\xaa\x02\x02\x08\n\r\n\x05\x04\x07\
    \x02\x01\x01\x12\x04\xaa\x02\t\x1c\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\
    \xaa\x02\x1f\x20\n\x0c\n\x04\x04\x07\x02\x02\x12\x04\xab\x02\x02\x17\n\r\
    \n\x05\x04\x07\x02\x02\x05\x12\x04\xab\x02\x02\x07\n\r\n\x05\x04\x07\x02\
    \x02\x01\x12\x04\xab\x02\x08\x12\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\
    \xab\x02\x15\x16\n\x0c\n\x04\x04\x07\x02\x03\x12\x04\xac\x02\x02\x18\n\r\
    \n\x05\x04\x07\x02\x03\x04\x12\x04\xac\x02\x02\n\n\r\n\x05\x04\x07\x02\
    \x03\x06\x12\x04\xac\x02\x0b\x0e\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\
    \xac\x02\x0f\x13\n\r\n\x05\x04\x07\x02\x03\x03\x12\x04\xac\x02\x16\x17\n\
    \x0c\n\x02\x04\x08\x12\x06\xaf\x02\0\xcb\x02\x01\n\x0b\n\x03\x04\x08\x01\
    \x12\x04\xaf\x02\x08\x0b\n\x0c\n\x04\x04\x08\x02\0\x12\x04\xb0\x02\x02\
    \x14\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xb0\x02\x02\x07\n\r\n\x05\x04\
    \x08\x02\0\x01\x12\x04\xb0\x02\x08\x0f\n\r\n\x05\x04\x08\x02\0\x03\x12\
    \x04\xb0\x02\x12\x13\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\xb1\x02\x02\x1c\
    \n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\xb1\x02\x02\n\n\r\n\x05\x04\x08\
    \x02\x01\x05\x12\x04\xb1\x02\x0b\x10\n\r\n\x05\x04\x08\x02\x01\x01\x12\
    \x04\xb1\x02\x11\x17\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xb1\x02\x1a\
    \x1b\n\x0c\n\x04\x04\x08\x02\x02\x12\x04\xb2\x02\x02\x11\n\r\n\x05\x04\
    \x08\x02\x02\x05\x12\x04\xb2\x02\x02\x07\n\r\n\x05\x04\x08\x02\x02\x01\
    \x12\x04\xb2\x02\x08\x0c\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xb2\x02\
    \x0f\x10\n\xb5\x01\n\x04\x04\x08\x02\x03\x12\x04\xb7\x02\x02\x13\x1a\xa6\
    \x01\x20Index\x20is\x20the\x20index\x20of\x20the\x20log\x20relative\x20t\
    o\x20the\x20transaction.\x20This\x20index\n\x20is\x20always\x20populated\
    \x20regardless\x20of\x20the\x20state\x20revertion\x20of\x20the\x20the\
    \x20call\n\x20that\x20emitted\x20this\x20log.\n\n\r\n\x05\x04\x08\x02\
    \x03\x05\x12\x04\xb7\x02\x02\x08\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\
    \xb7\x02\t\x0e\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\xb7\x02\x11\x12\n\
    \xa4\x05\n\x04\x04\x08\x02\x04\x12\x04\xc8\x02\x02\x18\x1a\x95\x05\x20Bl\
    ockIndex\x20represents\x20the\x20index\x20of\x20the\x20log\x20relative\
    \x20to\x20the\x20Block.\n\n\x20An\x20**important**\x20notice\x20is\x20th\
    at\x20this\x20field\x20will\x20be\x200\x20when\x20the\x20call\n\x20that\
    \x20emitted\x20the\x20log\x20has\x20been\x20reverted\x20by\x20the\x20cha\
    in.\n\n\x20Currently,\x20there\x20is\x20two\x20locations\x20where\x20a\
    \x20Log\x20can\x20be\x20obtained:\n\x20-\x20block.transaction_traces[].r\
    eceipt.logs[]\n\x20-\x20block.transaction_traces[].calls[].logs[]\n\n\
    \x20In\x20the\x20`receipt`\x20case,\x20the\x20logs\x20will\x20be\x20popu\
    lated\x20only\x20when\x20the\x20call\n\x20that\x20emitted\x20them\x20has\
    \x20not\x20been\x20reverted\x20by\x20the\x20chain\x20and\x20when\x20in\
    \x20this\n\x20position,\x20the\x20`blockIndex`\x20is\x20always\x20popula\
    ted\x20correctly.\n\n\x20In\x20the\x20case\x20of\x20`calls`\x20case,\x20\
    for\x20`call`\x20where\x20`stateReverted\x20==\x20true`,\n\x20the\x20`bl\
    ockIndex`\x20value\x20will\x20always\x20be\x200.\n\n\r\n\x05\x04\x08\x02\
    \x04\x05\x12\x04\xc8\x02\x02\x08\n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\
    \xc8\x02\t\x13\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\xc8\x02\x16\x17\n\
    \x0c\n\x04\x04\x08\x02\x05\x12\x04\xca\x02\x02\x15\n\r\n\x05\x04\x08\x02\
    \x05\x05\x12\x04\xca\x02\x02\x08\n\r\n\x05\x04\x08\x02\x05\x01\x12\x04\
    \xca\x02\t\x10\n\r\n\x05\x04\x08\x02\x05\x03\x12\x04\xca\x02\x13\x14\n\
    \x0c\n\x02\x04\t\x12\x06\xcd\x02\0\xa2\x03\x01\n\x0b\n\x03\x04\t\x01\x12\
    \x04\xcd\x02\x08\x0c\n\x0c\n\x04\x04\t\x02\0\x12\x04\xce\x02\x02\x13\n\r\
    \n\x05\x04\t\x02\0\x05\x12\x04\xce\x02\x02\x08\n\r\n\x05\x04\t\x02\0\x01\
    \x12\x04\xce\x02\t\x0e\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xce\x02\x11\x12\
    \n\x0c\n\x04\x04\t\x02\x01\x12\x04\xcf\x02\x02\x1a\n\r\n\x05\x04\t\x02\
    \x01\x05\x12\x04\xcf\x02\x02\x08\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xcf\
    \x02\t\x15\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xcf\x02\x18\x19\n\x0c\n\
    \x04\x04\t\x02\x02\x12\x04\xd0\x02\x02\x13\n\r\n\x05\x04\t\x02\x02\x05\
    \x12\x04\xd0\x02\x02\x08\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xd0\x02\t\
    \x0e\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xd0\x02\x11\x12\n\x0c\n\x04\x04\
    \t\x02\x03\x12\x04\xd1\x02\x02\x19\n\r\n\x05\x04\t\x02\x03\x06\x12\x04\
    \xd1\x02\x02\n\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xd1\x02\x0b\x14\n\r\n\
    \x05\x04\t\x02\x03\x03\x12\x04\xd1\x02\x17\x18\n\x0c\n\x04\x04\t\x02\x04\
    \x12\x04\xd2\x02\x02\x13\n\r\n\x05\x04\t\x02\x04\x05\x12\x04\xd2\x02\x02\
    \x07\n\r\n\x05\x04\t\x02\x04\x01\x12\x04\xd2\x02\x08\x0e\n\r\n\x05\x04\t\
    \x02\x04\x03\x12\x04\xd2\x02\x11\x12\n\x0c\n\x04\x04\t\x02\x05\x12\x04\
    \xd3\x02\x02\x14\n\r\n\x05\x04\t\x02\x05\x05\x12\x04\xd3\x02\x02\x07\n\r\
    \n\x05\x04\t\x02\x05\x01\x12\x04\xd3\x02\x08\x0f\n\r\n\x05\x04\t\x02\x05\
    \x03\x12\x04\xd3\x02\x12\x13\n\x0c\n\x04\x04\t\x02\x06\x12\x04\xd4\x02\
    \x02\x13\n\r\n\x05\x04\t\x02\x06\x06\x12\x04\xd4\x02\x02\x08\n\r\n\x05\
    \x04\t\x02\x06\x01\x12\x04\xd4\x02\t\x0e\n\r\n\x05\x04\t\x02\x06\x03\x12\
    \x04\xd4\x02\x11\x12\n\x0c\n\x04\x04\t\x02\x07\x12\x04\xd5\x02\x02\x17\n\
    \r\n\x05\x04\t\x02\x07\x05\x12\x04\xd5\x02\x02\x08\n\r\n\x05\x04\t\x02\
    \x07\x01\x12\x04\xd5\x02\t\x12\n\r\n\x05\x04\t\x02\x07\x03\x12\x04\xd5\
    \x02\x15\x16\n\x0c\n\x04\x04\t\x02\x08\x12\x04\xd6\x02\x02\x1a\n\r\n\x05\
    \x04\t\x02\x08\x05\x12\x04\xd6\x02\x02\x08\n\r\n\x05\x04\t\x02\x08\x01\
    \x12\x04\xd6\x02\t\x15\n\r\n\x05\x04\t\x02\x08\x03\x12\x04\xd6\x02\x18\
    \x19\n\x0c\n\x04\x04\t\x02\t\x12\x04\xd7\x02\x02\x19\n\r\n\x05\x04\t\x02\
    \t\x05\x12\x04\xd7\x02\x02\x07\n\r\n\x05\x04\t\x02\t\x01\x12\x04\xd7\x02\
    \x08\x13\n\r\n\x05\x04\t\x02\t\x03\x12\x04\xd7\x02\x16\x18\n\x0c\n\x04\
    \x04\t\x02\n\x12\x04\xd8\x02\x02\x13\n\r\n\x05\x04\t\x02\n\x05\x12\x04\
    \xd8\x02\x02\x07\n\r\n\x05\x04\t\x02\n\x01\x12\x04\xd8\x02\x08\r\n\r\n\
    \x05\x04\t\x02\n\x03\x12\x04\xd8\x02\x10\x12\n\x0c\n\x04\x04\t\x02\x0b\
    \x12\x04\xd9\x02\x02\x1a\n\r\n\x05\x04\t\x02\x0b\x05\x12\x04\xd9\x02\x02\
    \x06\n\r\n\x05\x04\t\x02\x0b\x01\x12\x04\xd9\x02\x07\x14\n\r\n\x05\x04\t\
    \x02\x0b\x03\x12\x04\xd9\x02\x17\x19\n\x0c\n\x04\x04\t\x02\x0c\x12\x04\
    \xda\x02\x02\x14\n\r\n\x05\x04\t\x02\x0c\x05\x12\x04\xda\x02\x02\x06\n\r\
    \n\x05\x04\t\x02\x0c\x01\x12\x04\xda\x02\x07\x0e\n\r\n\x05\x04\t\x02\x0c\
    \x03\x12\x04\xda\x02\x11\x13\n:\n\x04\x04\t\x02\r\x12\x04\xdd\x02\x02,\
    \x1a,\x20hex\x20representation\x20of\x20the\x20hash\x20->\x20preimage\
    \x20\n\r\n\x05\x04\t\x02\r\x06\x12\x04\xdd\x02\x02\x15\n\r\n\x05\x04\t\
    \x02\r\x01\x12\x04\xdd\x02\x16&\n\r\n\x05\x04\t\x02\r\x03\x12\x04\xdd\
    \x02)+\n\x0c\n\x04\x04\t\x02\x0e\x12\x04\xde\x02\x02.\n\r\n\x05\x04\t\
    \x02\x0e\x04\x12\x04\xde\x02\x02\n\n\r\n\x05\x04\t\x02\x0e\x06\x12\x04\
    \xde\x02\x0b\x18\n\r\n\x05\x04\t\x02\x0e\x01\x12\x04\xde\x02\x19(\n\r\n\
    \x05\x04\t\x02\x0e\x03\x12\x04\xde\x02+-\n\x0c\n\x04\x04\t\x02\x0f\x12\
    \x04\xdf\x02\x02.\n\r\n\x05\x04\t\x02\x0f\x04\x12\x04\xdf\x02\x02\n\n\r\
    \n\x05\x04\t\x02\x0f\x06\x12\x04\xdf\x02\x0b\x18\n\r\n\x05\x04\t\x02\x0f\
    \x01\x12\x04\xdf\x02\x19(\n\r\n\x05\x04\t\x02\x0f\x03\x12\x04\xdf\x02+-\
    \n\x0c\n\x04\x04\t\x02\x10\x12\x04\xe0\x02\x02*\n\r\n\x05\x04\t\x02\x10\
    \x04\x12\x04\xe0\x02\x02\n\n\r\n\x05\x04\t\x02\x10\x06\x12\x04\xe0\x02\
    \x0b\x16\n\r\n\x05\x04\t\x02\x10\x01\x12\x04\xe0\x02\x17$\n\r\n\x05\x04\
    \t\x02\x10\x03\x12\x04\xe0\x02')\n\x0c\n\x04\x04\t\x02\x11\x12\x04\xe1\
    \x02\x02\x19\n\r\n\x05\x04\t\x02\x11\x04\x12\x04\xe1\x02\x02\n\n\r\n\x05\
    \x04\t\x02\x11\x06\x12\x04\xe1\x02\x0b\x0e\n\r\n\x05\x04\t\x02\x11\x01\
    \x12\x04\xe1\x02\x0f\x13\n\r\n\x05\x04\t\x02\x11\x03\x12\x04\xe1\x02\x16\
    \x18\n\x0c\n\x04\x04\t\x02\x12\x12\x04\xe2\x02\x02(\n\r\n\x05\x04\t\x02\
    \x12\x04\x12\x04\xe2\x02\x02\n\n\r\n\x05\x04\t\x02\x12\x06\x12\x04\xe2\
    \x02\x0b\x15\n\r\n\x05\x04\t\x02\x12\x01\x12\x04\xe2\x02\x16\"\n\r\n\x05\
    \x04\t\x02\x12\x03\x12\x04\xe2\x02%'\n:\n\x03\x04\t\t\x12\x04\xe5\x02\
    \x02\x0e\x1a-\x20Deprecated:\x20repeated\x20bytes\x20created_accounts\n\
    \n\x0c\n\x04\x04\t\t\0\x12\x04\xe5\x02\x0b\r\n\r\n\x05\x04\t\t\0\x01\x12\
    \x04\xe5\x02\x0b\r\n\r\n\x05\x04\t\t\0\x02\x12\x04\xe5\x02\x0b\r\n\x0c\n\
    \x04\x04\t\x02\x13\x12\x04\xe7\x02\x02&\n\r\n\x05\x04\t\x02\x13\x04\x12\
    \x04\xe7\x02\x02\n\n\r\n\x05\x04\t\x02\x13\x06\x12\x04\xe7\x02\x0b\x14\n\
    \r\n\x05\x04\t\x02\x13\x01\x12\x04\xe7\x02\x15\x20\n\r\n\x05\x04\t\x02\
    \x13\x03\x12\x04\xe7\x02#%\n7\n\x03\x04\t\t\x12\x04\xea\x02\x02\x0e\x1a*\
    \x20Deprecated:\x20repeated\x20GasEvent\x20gas_events\n\n\x0c\n\x04\x04\
    \t\t\x01\x12\x04\xea\x02\x0b\r\n\r\n\x05\x04\t\t\x01\x01\x12\x04\xea\x02\
    \x0b\r\n\r\n\x05\x04\t\t\x01\x02\x12\x04\xea\x02\x0b\r\n\xe7\x03\n\x04\
    \x04\t\x02\x14\x12\x04\xf4\x02\x02\x1a\x1a\xd8\x03\x20In\x20Ethereum,\
    \x20a\x20call\x20can\x20be\x20either:\n\x20-\x20Successfull,\x20executio\
    n\x20passes\x20without\x20any\x20problem\x20encountered\n\x20-\x20Failed\
    ,\x20execution\x20failed,\x20and\x20remaining\x20gas\x20should\x20be\x20\
    consumed\n\x20-\x20Reverted,\x20execution\x20failed,\x20but\x20only\x20g\
    as\x20consumed\x20so\x20far\x20is\x20billed,\x20remaining\x20gas\x20is\
    \x20refunded\n\n\x20When\x20a\x20call\x20is\x20either\x20`failed`\x20or\
    \x20`reverted`,\x20the\x20`status_failed`\x20field\n\x20below\x20is\x20s\
    et\x20to\x20`true`.\x20If\x20the\x20status\x20is\x20`reverted`,\x20then\
    \x20both\x20`status_failed`\n\x20and\x20`status_reverted`\x20are\x20goin\
    g\x20to\x20be\x20set\x20to\x20`true`.\n\n\r\n\x05\x04\t\x02\x14\x05\x12\
    \x04\xf4\x02\x02\x06\n\r\n\x05\x04\t\x02\x14\x01\x12\x04\xf4\x02\x07\x14\
    \n\r\n\x05\x04\t\x02\x14\x03\x12\x04\xf4\x02\x17\x19\n\x0c\n\x04\x04\t\
    \x02\x15\x12\x04\xf5\x02\x02\x1c\n\r\n\x05\x04\t\x02\x15\x05\x12\x04\xf5\
    \x02\x02\x06\n\r\n\x05\x04\t\x02\x15\x01\x12\x04\xf5\x02\x07\x16\n\r\n\
    \x05\x04\t\x02\x15\x03\x12\x04\xf5\x02\x19\x1b\n\x8b\x01\n\x04\x04\t\x02\
    \x16\x12\x04\xf9\x02\x02\x1d\x1a}\x20Populated\x20when\x20a\x20call\x20e\
    ither\x20failed\x20or\x20reverted,\x20so\x20when\x20`status_failed\x20==\
    \x20true`,\n\x20see\x20above\x20for\x20details\x20about\x20those\x20flag\
    s.\n\n\r\n\x05\x04\t\x02\x16\x05\x12\x04\xf9\x02\x02\x08\n\r\n\x05\x04\t\
    \x02\x16\x01\x12\x04\xf9\x02\t\x17\n\r\n\x05\x04\t\x02\x16\x03\x12\x04\
    \xf9\x02\x1a\x1c\n\xf2\x08\n\x04\x04\t\x02\x17\x12\x04\x98\x03\x02\x1b\
    \x1a\xe3\x08\x20This\x20field\x20represents\x20wheter\x20or\x20not\x20th\
    e\x20state\x20changes\x20performed\n\x20by\x20this\x20call\x20were\x20co\
    rrectly\x20recorded\x20by\x20the\x20blockchain.\n\n\x20On\x20Ethereum,\
    \x20a\x20transaction\x20can\x20record\x20state\x20changes\x20even\x20if\
    \x20some\n\x20of\x20its\x20inner\x20nested\x20calls\x20failed.\x20This\
    \x20is\x20problematic\x20however\x20since\n\x20a\x20call\x20will\x20inva\
    lidate\x20all\x20its\x20state\x20changes\x20as\x20well\x20as\x20all\x20s\
    tate\n\x20changes\x20performed\x20by\x20its\x20child\x20call.\x20This\
    \x20means\x20that\x20even\x20if\x20a\x20call\n\x20has\x20a\x20status\x20\
    of\x20`SUCCESS`,\x20the\x20chain\x20might\x20have\x20reverted\x20all\x20\
    the\x20state\n\x20changes\x20it\x20performed.\n\n\x20```text\n\x20\x20\
    \x20Trx\x201\n\x20\x20\x20\x20Call\x20#1\x20<Failed>\n\x20\x20\x20\x20\
    \x20\x20Call\x20#2\x20<Execution\x20Success>\n\x20\x20\x20\x20\x20\x20Ca\
    ll\x20#3\x20<Execution\x20Success>\n\x20\x20\x20\x20\x20\x20|---\x20Fail\
    ure\x20here\n\x20\x20\x20\x20Call\x20#4\n\x20```\n\n\x20In\x20the\x20tra\
    nsaction\x20above,\x20while\x20Call\x20#2\x20and\x20Call\x20#3\x20would\
    \x20have\x20the\n\x20status\x20`EXECUTED`.\n\n\x20If\x20you\x20check\x20\
    all\x20calls\x20and\x20check\x20only\x20`state_reverted`\x20flag,\x20you\
    \x20might\x20be\x20missing\n\x20some\x20balance\x20changes\x20and\x20non\
    ce\x20changes.\x20This\x20is\x20because\x20when\x20a\x20full\x20transact\
    ion\x20fails\n\x20in\x20ethereum\x20(e.g.\x20`calls.all(x.state_reverted\
    \x20==\x20true)`),\x20there\x20is\x20still\x20the\x20transaction\n\x20fe\
    e\x20that\x20are\x20recorded\x20to\x20the\x20chain.\n\n\x20Refer\x20to\
    \x20[TransactionTrace#status]\x20field\x20for\x20more\x20details\x20abou\
    t\x20the\x20handling\x20you\x20must\n\x20perform.\n\n\r\n\x05\x04\t\x02\
    \x17\x05\x12\x04\x98\x03\x02\x06\n\r\n\x05\x04\t\x02\x17\x01\x12\x04\x98\
    \x03\x07\x15\n\r\n\x05\x04\t\x02\x17\x03\x12\x04\x98\x03\x18\x1a\n\x0c\n\
    \x04\x04\t\x02\x18\x12\x04\x9a\x03\x02\x1c\n\r\n\x05\x04\t\x02\x18\x05\
    \x12\x04\x9a\x03\x02\x08\n\r\n\x05\x04\t\x02\x18\x01\x12\x04\x9a\x03\t\
    \x16\n\r\n\x05\x04\t\x02\x18\x03\x12\x04\x9a\x03\x19\x1b\n\x0c\n\x04\x04\
    \t\x02\x19\x12\x04\x9b\x03\x02\x1a\n\r\n\x05\x04\t\x02\x19\x05\x12\x04\
    \x9b\x03\x02\x08\n\r\n\x05\x04\t\x02\x19\x01\x12\x04\x9b\x03\t\x14\n\r\n\
    \x05\x04\t\x02\x19\x03\x12\x04\x9b\x03\x17\x19\n\x0c\n\x04\x04\t\x02\x1a\
    \x12\x04\x9d\x03\x022\n\r\n\x05\x04\t\x02\x1a\x04\x12\x04\x9d\x03\x02\n\
    \n\r\n\x05\x04\t\x02\x1a\x06\x12\x04\x9d\x03\x0b\x1a\n\r\n\x05\x04\t\x02\
    \x1a\x01\x12\x04\x9d\x03\x1b,\n\r\n\x05\x04\t\x02\x1a\x03\x12\x04\x9d\
    \x03/1\nZ\n\x03\x04\t\t\x12\x04\x9f\x03\x02\x0e\"M\x20repeated\x20ERC20B\
    alanceChange\x20erc20_balance_changes\x20=\x2050\x20[deprecated\x20=\x20\
    true];\n\n\x0c\n\x04\x04\t\t\x02\x12\x04\x9f\x03\x0b\r\n\r\n\x05\x04\t\t\
    \x02\x01\x12\x04\x9f\x03\x0b\r\n\r\n\x05\x04\t\t\x02\x02\x12\x04\x9f\x03\
    \x0b\r\nZ\n\x03\x04\t\t\x12\x04\xa0\x03\x02\x0e\"M\x20repeated\x20ERC20T\
    ransferEvent\x20erc20_transfer_events\x20=\x2051\x20[deprecated\x20=\x20\
    true];\n\n\x0c\n\x04\x04\t\t\x03\x12\x04\xa0\x03\x0b\r\n\r\n\x05\x04\t\t\
    \x03\x01\x12\x04\xa0\x03\x0b\r\n\r\n\x05\x04\t\t\x03\x02\x12\x04\xa0\x03\
    \x0b\r\n?\n\x03\x04\t\t\x12\x04\xa1\x03\x02\x0e\"2\x20bool\x20filtering_\
    matched\x20=\x2060\x20[deprecated\x20=\x20true];\n\n\x0c\n\x04\x04\t\t\
    \x04\x12\x04\xa1\x03\x0b\r\n\r\n\x05\x04\t\t\x04\x01\x12\x04\xa1\x03\x0b\
    \r\n\r\n\x05\x04\t\t\x04\x02\x12\x04\xa1\x03\x0b\r\n\x0c\n\x02\x05\x01\
    \x12\x06\xa4\x03\0\xab\x03\x01\n\x0b\n\x03\x05\x01\x01\x12\x04\xa4\x03\
    \x05\r\n\x0c\n\x04\x05\x01\x02\0\x12\x04\xa5\x03\x02\x12\n\r\n\x05\x05\
    \x01\x02\0\x01\x12\x04\xa5\x03\x02\r\n\r\n\x05\x05\x01\x02\0\x02\x12\x04\
    \xa5\x03\x10\x11\n9\n\x04\x05\x01\x02\x01\x12\x04\xa6\x03\x02\x0b\"+\x20\
    direct?\x20what's\x20the\x20name\x20for\x20`Call`\x20alone?\n\n\r\n\x05\
    \x05\x01\x02\x01\x01\x12\x04\xa6\x03\x02\x06\n\r\n\x05\x05\x01\x02\x01\
    \x02\x12\x04\xa6\x03\t\n\n\x0c\n\x04\x05\x01\x02\x02\x12\x04\xa7\x03\x02\
    \x0f\n\r\n\x05\x05\x01\x02\x02\x01\x12\x04\xa7\x03\x02\n\n\r\n\x05\x05\
    \x01\x02\x02\x02\x12\x04\xa7\x03\r\x0e\n\x0c\n\x04\x05\x01\x02\x03\x12\
    \x04\xa8\x03\x02\x0f\n\r\n\x05\x05\x01\x02\x03\x01\x12\x04\xa8\x03\x02\n\
    \n\r\n\x05\x05\x01\x02\x03\x02\x12\x04\xa8\x03\r\x0e\n\x0c\n\x04\x05\x01\
    \x02\x04\x12\x04\xa9\x03\x02\r\n\r\n\x05\x05\x01\x02\x04\x01\x12\x04\xa9\
    \x03\x02\x08\n\r\n\x05\x05\x01\x02\x04\x02\x12\x04\xa9\x03\x0b\x0c\n2\n\
    \x04\x05\x01\x02\x05\x12\x04\xaa\x03\x02\r\"$\x20create2\x20?\x20any\x20\
    other\x20form\x20of\x20calls?\n\n\r\n\x05\x05\x01\x02\x05\x01\x12\x04\
    \xaa\x03\x02\x08\n\r\n\x05\x05\x01\x02\x05\x02\x12\x04\xaa\x03\x0b\x0c\n\
    \x0c\n\x02\x04\n\x12\x06\xad\x03\0\xb4\x03\x01\n\x0b\n\x03\x04\n\x01\x12\
    \x04\xad\x03\x08\x15\n\x0c\n\x04\x04\n\x02\0\x12\x04\xae\x03\x02\x14\n\r\
    \n\x05\x04\n\x02\0\x05\x12\x04\xae\x03\x02\x07\n\r\n\x05\x04\n\x02\0\x01\
    \x12\x04\xae\x03\x08\x0f\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xae\x03\x12\
    \x13\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xaf\x03\x02\x10\n\r\n\x05\x04\n\
    \x02\x01\x05\x12\x04\xaf\x03\x02\x07\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\
    \xaf\x03\x08\x0b\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xaf\x03\x0e\x0f\n\
    \x0c\n\x04\x04\n\x02\x02\x12\x04\xb0\x03\x02\x16\n\r\n\x05\x04\n\x02\x02\
    \x05\x12\x04\xb0\x03\x02\x07\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xb0\x03\
    \x08\x11\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xb0\x03\x14\x15\n\x0c\n\x04\
    \x04\n\x02\x03\x12\x04\xb1\x03\x02\x16\n\r\n\x05\x04\n\x02\x03\x05\x12\
    \x04\xb1\x03\x02\x07\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\xb1\x03\x08\x11\
    \n\r\n\x05\x04\n\x02\x03\x03\x12\x04\xb1\x03\x14\x15\n\x0c\n\x04\x04\n\
    \x02\x04\x12\x04\xb3\x03\x02\x15\n\r\n\x05\x04\n\x02\x04\x05\x12\x04\xb3\
    \x03\x02\x08\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\xb3\x03\t\x10\n\r\n\x05\
    \x04\n\x02\x04\x03\x12\x04\xb3\x03\x13\x14\n\x0c\n\x02\x04\x0b\x12\x06\
    \xb6\x03\0\xd7\x03\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xb6\x03\x08\x15\n\
    \x0c\n\x04\x04\x0b\x02\0\x12\x04\xb7\x03\x02\x14\n\r\n\x05\x04\x0b\x02\0\
    \x05\x12\x04\xb7\x03\x02\x07\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xb7\x03\
    \x08\x0f\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xb7\x03\x12\x13\n\x0c\n\x04\
    \x04\x0b\x02\x01\x12\x04\xb8\x03\x02\x17\n\r\n\x05\x04\x0b\x02\x01\x06\
    \x12\x04\xb8\x03\x02\x08\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xb8\x03\t\
    \x12\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xb8\x03\x15\x16\n\x0c\n\x04\
    \x04\x0b\x02\x02\x12\x04\xb9\x03\x02\x17\n\r\n\x05\x04\x0b\x02\x02\x06\
    \x12\x04\xb9\x03\x02\x08\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\xb9\x03\t\
    \x12\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xb9\x03\x15\x16\n\x0c\n\x04\
    \x04\x0b\x02\x03\x12\x04\xba\x03\x02\x14\n\r\n\x05\x04\x0b\x02\x03\x06\
    \x12\x04\xba\x03\x02\x08\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\xba\x03\t\
    \x0f\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\xba\x03\x12\x13\n\xa8\x01\n\
    \x04\x04\x0b\x04\0\x12\x06\xc1\x03\x02\xd4\x03\x03\x1a\x97\x01\x20Obtain\
    \x20all\x20balanche\x20change\x20reasons\x20under\x20deep\x20mind\x20rep\
    ository:\n\n\x20```shell\n\x20ack\x20-ho\x20'BalanceChangeReason\\(\".*\
    \"\\)'\x20|\x20grep\x20-Eo\x20'\".*\"'\x20|\x20sort\x20|\x20uniq\n\x20``\
    `\n\n\r\n\x05\x04\x0b\x04\0\x01\x12\x04\xc1\x03\x07\r\n\x0e\n\x06\x04\
    \x0b\x04\0\x02\0\x12\x04\xc2\x03\x04\x17\n\x0f\n\x07\x04\x0b\x04\0\x02\0\
    \x01\x12\x04\xc2\x03\x04\x12\n\x0f\n\x07\x04\x0b\x04\0\x02\0\x02\x12\x04\
    \xc2\x03\x15\x16\n\x0e\n\x06\x04\x0b\x04\0\x02\x01\x12\x04\xc3\x03\x04!\
    \n\x0f\n\x07\x04\x0b\x04\0\x02\x01\x01\x12\x04\xc3\x03\x04\x1c\n\x0f\n\
    \x07\x04\x0b\x04\0\x02\x01\x02\x12\x04\xc3\x03\x1f\x20\n\x0e\n\x06\x04\
    \x0b\x04\0\x02\x02\x12\x04\xc4\x03\x04!\n\x0f\n\x07\x04\x0b\x04\0\x02\
    \x02\x01\x12\x04\xc4\x03\x04\x1c\n\x0f\n\x07\x04\x0b\x04\0\x02\x02\x02\
    \x12\x04\xc4\x03\x1f\x20\n\x0e\n\x06\x04\x0b\x04\0\x02\x03\x12\x04\xc5\
    \x03\x04#\n\x0f\n\x07\x04\x0b\x04\0\x02\x03\x01\x12\x04\xc5\x03\x04\x1e\
    \n\x0f\n\x07\x04\x0b\x04\0\x02\x03\x02\x12\x04\xc5\x03!\"\n\x0e\n\x06\
    \x04\x0b\x04\0\x02\x04\x12\x04\xc6\x03\x04\"\n\x0f\n\x07\x04\x0b\x04\0\
    \x02\x04\x01\x12\x04\xc6\x03\x04\x1d\n\x0f\n\x07\x04\x0b\x04\0\x02\x04\
    \x02\x12\x04\xc6\x03\x20!\n\x0e\n\x06\x04\x0b\x04\0\x02\x05\x12\x04\xc7\
    \x03\x04\x18\n\x0f\n\x07\x04\x0b\x04\0\x02\x05\x01\x12\x04\xc7\x03\x04\
    \x13\n\x0f\n\x07\x04\x0b\x04\0\x02\x05\x02\x12\x04\xc7\x03\x16\x17\n\x0e\
    \n\x06\x04\x0b\x04\0\x02\x06\x12\x04\xc8\x03\x04\x1f\n\x0f\n\x07\x04\x0b\
    \x04\0\x02\x06\x01\x12\x04\xc8\x03\x04\x1a\n\x0f\n\x07\x04\x0b\x04\0\x02\
    \x06\x02\x12\x04\xc8\x03\x1d\x1e\n\x0e\n\x06\x04\x0b\x04\0\x02\x07\x12\
    \x04\xc9\x03\x04\x17\n\x0f\n\x07\x04\x0b\x04\0\x02\x07\x01\x12\x04\xc9\
    \x03\x04\x12\n\x0f\n\x07\x04\x0b\x04\0\x02\x07\x02\x12\x04\xc9\x03\x15\
    \x16\n\x0e\n\x06\x04\x0b\x04\0\x02\x08\x12\x04\xca\x03\x04&\n\x0f\n\x07\
    \x04\x0b\x04\0\x02\x08\x01\x12\x04\xca\x03\x04!\n\x0f\n\x07\x04\x0b\x04\
    \0\x02\x08\x02\x12\x04\xca\x03$%\n\x0e\n\x06\x04\x0b\x04\0\x02\t\x12\x04\
    \xcb\x03\x04!\n\x0f\n\x07\x04\x0b\x04\0\x02\t\x01\x12\x04\xcb\x03\x04\
    \x1b\n\x0f\n\x07\x04\x0b\x04\0\x02\t\x02\x12\x04\xcb\x03\x1e\x20\n\x0e\n\
    \x06\x04\x0b\x04\0\x02\n\x12\x04\xcc\x03\x04\x1a\n\x0f\n\x07\x04\x0b\x04\
    \0\x02\n\x01\x12\x04\xcc\x03\x04\x15\n\x0f\n\x07\x04\x0b\x04\0\x02\n\x02\
    \x12\x04\xcc\x03\x18\x19\n\x0e\n\x06\x04\x0b\x04\0\x02\x0b\x12\x04\xcd\
    \x03\x04\x1e\n\x0f\n\x07\x04\x0b\x04\0\x02\x0b\x01\x12\x04\xcd\x03\x04\
    \x18\n\x0f\n\x07\x04\x0b\x04\0\x02\x0b\x02\x12\x04\xcd\x03\x1b\x1d\n\x0e\
    \n\x06\x04\x0b\x04\0\x02\x0c\x12\x04\xce\x03\x04\x1f\n\x0f\n\x07\x04\x0b\
    \x04\0\x02\x0c\x01\x12\x04\xce\x03\x04\x19\n\x0f\n\x07\x04\x0b\x04\0\x02\
    \x0c\x02\x12\x04\xce\x03\x1c\x1e\n\x0e\n\x06\x04\x0b\x04\0\x02\r\x12\x04\
    \xcf\x03\x04!\n\x0f\n\x07\x04\x0b\x04\0\x02\r\x01\x12\x04\xcf\x03\x04\
    \x1b\n\x0f\n\x07\x04\x0b\x04\0\x02\r\x02\x12\x04\xcf\x03\x1e\x20\n\x0e\n\
    \x06\x04\x0b\x04\0\x02\x0e\x12\x04\xd0\x03\x04&\n\x0f\n\x07\x04\x0b\x04\
    \0\x02\x0e\x01\x12\x04\xd0\x03\x04\x20\n\x0f\n\x07\x04\x0b\x04\0\x02\x0e\
    \x02\x12\x04\xd0\x03#%\nC\n\x06\x04\x0b\x04\0\x02\x0f\x12\x04\xd2\x03\
    \x04\x15\x1a3\x20Used\x20on\x20chain(s)\x20where\x20some\x20Ether\x20bur\
    ning\x20happens\n\n\x0f\n\x07\x04\x0b\x04\0\x02\x0f\x01\x12\x04\xd2\x03\
    \x04\x0f\n\x0f\n\x07\x04\x0b\x04\0\x02\x0f\x02\x12\x04\xd2\x03\x12\x14\n\
    \x0e\n\x06\x04\x0b\x04\0\x02\x10\x12\x04\xd3\x03\x04\x1b\n\x0f\n\x07\x04\
    \x0b\x04\0\x02\x10\x01\x12\x04\xd3\x03\x04\x15\n\x0f\n\x07\x04\x0b\x04\0\
    \x02\x10\x02\x12\x04\xd3\x03\x18\x1a\n\x0c\n\x04\x04\x0b\x02\x04\x12\x04\
    \xd6\x03\x02\x15\n\r\n\x05\x04\x0b\x02\x04\x05\x12\x04\xd6\x03\x02\x08\n\
    \r\n\x05\x04\x0b\x02\x04\x01\x12\x04\xd6\x03\t\x10\n\r\n\x05\x04\x0b\x02\
    \x04\x03\x12\x04\xd6\x03\x13\x14\n\x0c\n\x02\x04\x0c\x12\x06\xd9\x03\0\
    \xde\x03\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xd9\x03\x08\x13\n\x0c\n\x04\
    \x04\x0c\x02\0\x12\x04\xda\x03\x02\x14\n\r\n\x05\x04\x0c\x02\0\x05\x12\
    \x04\xda\x03\x02\x07\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xda\x03\x08\x0f\
    \n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xda\x03\x12\x13\n\x0c\n\x04\x04\x0c\
    \x02\x01\x12\x04\xdb\x03\x02\x17\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\
    \xdb\x03\x02\x08\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xdb\x03\t\x12\n\r\
    \n\x05\x04\x0c\x02\x01\x03\x12\x04\xdb\x03\x15\x16\n\x0c\n\x04\x04\x0c\
    \x02\x02\x12\x04\xdc\x03\x02\x17\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\
    \xdc\x03\x02\x08\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xdc\x03\t\x12\n\r\
    \n\x05\x04\x0c\x02\x02\x03\x12\x04\xdc\x03\x15\x16\n\x0c\n\x04\x04\x0c\
    \x02\x03\x12\x04\xdd\x03\x02\x15\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\
    \xdd\x03\x02\x08\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xdd\x03\t\x10\n\r\
    \n\x05\x04\x0c\x02\x03\x03\x12\x04\xdd\x03\x13\x14\n\x0c\n\x02\x04\r\x12\
    \x06\xe0\x03\0\xe3\x03\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xe0\x03\x08\x17\
    \n\x0c\n\x04\x04\r\x02\0\x12\x04\xe1\x03\x02\x14\n\r\n\x05\x04\r\x02\0\
    \x05\x12\x04\xe1\x03\x02\x07\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xe1\x03\
    \x08\x0f\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xe1\x03\x12\x13\n\x0c\n\x04\
    \x04\r\x02\x01\x12\x04\xe2\x03\x02\x15\n\r\n\x05\x04\r\x02\x01\x05\x12\
    \x04\xe2\x03\x02\x08\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xe2\x03\t\x10\n\
    \r\n\x05\x04\r\x02\x01\x03\x12\x04\xe2\x03\x13\x14\n\x0c\n\x02\x04\x0e\
    \x12\x06\xe5\x03\0\xed\x03\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xe5\x03\
    \x08\x12\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xe6\x03\x02\x14\n\r\n\x05\x04\
    \x0e\x02\0\x05\x12\x04\xe6\x03\x02\x07\n\r\n\x05\x04\x0e\x02\0\x01\x12\
    \x04\xe6\x03\x08\x0f\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xe6\x03\x12\x13\
    \n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xe7\x03\x02\x15\n\r\n\x05\x04\x0e\
    \x02\x01\x05\x12\x04\xe7\x03\x02\x07\n\r\n\x05\x04\x0e\x02\x01\x01\x12\
    \x04\xe7\x03\x08\x10\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xe7\x03\x13\
    \x14\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\xe8\x03\x02\x15\n\r\n\x05\x04\
    \x0e\x02\x02\x05\x12\x04\xe8\x03\x02\x07\n\r\n\x05\x04\x0e\x02\x02\x01\
    \x12\x04\xe8\x03\x08\x10\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xe8\x03\
    \x13\x14\n\x0c\n\x04\x04\x0e\x02\x03\x12\x04\xe9\x03\x02\x15\n\r\n\x05\
    \x04\x0e\x02\x03\x05\x12\x04\xe9\x03\x02\x07\n\r\n\x05\x04\x0e\x02\x03\
    \x01\x12\x04\xe9\x03\x08\x10\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xe9\
    \x03\x13\x14\n\x0c\n\x04\x04\x0e\x02\x04\x12\x04\xea\x03\x02\x15\n\r\n\
    \x05\x04\x0e\x02\x04\x05\x12\x04\xea\x03\x02\x07\n\r\n\x05\x04\x0e\x02\
    \x04\x01\x12\x04\xea\x03\x08\x10\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\
    \xea\x03\x13\x14\n\x0c\n\x04\x04\x0e\x02\x05\x12\x04\xec\x03\x02\x15\n\r\
    \n\x05\x04\x0e\x02\x05\x05\x12\x04\xec\x03\x02\x08\n\r\n\x05\x04\x0e\x02\
    \x05\x01\x12\x04\xec\x03\t\x10\n\r\n\x05\x04\x0e\x02\x05\x03\x12\x04\xec\
    \x03\x13\x14\n\xb5\x02\n\x02\x04\x0f\x12\x06\xf5\x03\0\x9a\x04\x01\x1a\
    \xa6\x02\x20The\x20gas\x20change\x20model\x20represents\x20the\x20reason\
    \x20why\x20some\x20gas\x20cost\x20has\x20occurred.\n\x20The\x20gas\x20is\
    \x20computed\x20per\x20actual\x20op\x20codes.\x20Doing\x20them\x20comple\
    tely\x20might\x20prove\n\x20overwhelming\x20in\x20most\x20cases.\n\n\x20\
    Hence,\x20we\x20only\x20index\x20some\x20of\x20them,\x20those\x20that\
    \x20are\x20costy\x20like\x20all\x20the\x20calls\n\x20one,\x20log\x20even\
    ts,\x20return\x20data,\x20etc.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xf5\x03\
    \x08\x11\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xf6\x03\x02\x17\n\r\n\x05\x04\
    \x0f\x02\0\x05\x12\x04\xf6\x03\x02\x08\n\r\n\x05\x04\x0f\x02\0\x01\x12\
    \x04\xf6\x03\t\x12\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xf6\x03\x15\x16\n\
    \x0c\n\x04\x04\x0f\x02\x01\x12\x04\xf7\x03\x02\x17\n\r\n\x05\x04\x0f\x02\
    \x01\x05\x12\x04\xf7\x03\x02\x08\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\
    \xf7\x03\t\x12\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xf7\x03\x15\x16\n\
    \x0c\n\x04\x04\x0f\x02\x02\x12\x04\xf8\x03\x02\x14\n\r\n\x05\x04\x0f\x02\
    \x02\x06\x12\x04\xf8\x03\x02\x08\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\
    \xf8\x03\t\x0f\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xf8\x03\x12\x13\n\
    \x9f\x01\n\x04\x04\x0f\x04\0\x12\x06\xff\x03\x02\x97\x04\x03\x1a\x8e\x01\
    \x20Obtain\x20all\x20gas\x20change\x20reasons\x20under\x20deep\x20mind\
    \x20repository:\n\n\x20```shell\n\x20ack\x20-ho\x20'GasChangeReason\\(\"\
    .*\"\\)'\x20|\x20grep\x20-Eo\x20'\".*\"'\x20|\x20sort\x20|\x20uniq\n\x20\
    ```\n\n\r\n\x05\x04\x0f\x04\0\x01\x12\x04\xff\x03\x07\r\n\x0e\n\x06\x04\
    \x0f\x04\0\x02\0\x12\x04\x80\x04\x04\x17\n\x0f\n\x07\x04\x0f\x04\0\x02\0\
    \x01\x12\x04\x80\x04\x04\x12\n\x0f\n\x07\x04\x0f\x04\0\x02\0\x02\x12\x04\
    \x80\x04\x15\x16\n\x0e\n\x06\x04\x0f\x04\0\x02\x01\x12\x04\x81\x04\x04\
    \x14\n\x0f\n\x07\x04\x0f\x04\0\x02\x01\x01\x12\x04\x81\x04\x04\x0f\n\x0f\
    \n\x07\x04\x0f\x04\0\x02\x01\x02\x12\x04\x81\x04\x12\x13\n\x0e\n\x06\x04\
    \x0f\x04\0\x02\x02\x12\x04\x82\x04\x04\x19\n\x0f\n\x07\x04\x0f\x04\0\x02\
    \x02\x01\x12\x04\x82\x04\x04\x14\n\x0f\n\x07\x04\x0f\x04\0\x02\x02\x02\
    \x12\x04\x82\x04\x17\x18\n\x0e\n\x06\x04\x0f\x04\0\x02\x03\x12\x04\x83\
    \x04\x04\x1e\n\x0f\n\x07\x04\x0f\x04\0\x02\x03\x01\x12\x04\x83\x04\x04\
    \x19\n\x0f\n\x07\x04\x0f\x04\0\x02\x03\x02\x12\x04\x83\x04\x1c\x1d\n\x0e\
    \n\x06\x04\x0f\x04\0\x02\x04\x12\x04\x84\x04\x04\x19\n\x0f\n\x07\x04\x0f\
    \x04\0\x02\x04\x01\x12\x04\x84\x04\x04\x14\n\x0f\n\x07\x04\x0f\x04\0\x02\
    \x04\x02\x12\x04\x84\x04\x17\x18\n\x0e\n\x06\x04\x0f\x04\0\x02\x05\x12\
    \x04\x85\x04\x04\x1c\n\x0f\n\x07\x04\x0f\x04\0\x02\x05\x01\x12\x04\x85\
    \x04\x04\x17\n\x0f\n\x07\x04\x0f\x04\0\x02\x05\x02\x12\x04\x85\x04\x1a\
    \x1b\n\x0e\n\x06\x04\x0f\x04\0\x02\x06\x12\x04\x86\x04\x04!\n\x0f\n\x07\
    \x04\x0f\x04\0\x02\x06\x01\x12\x04\x86\x04\x04\x1c\n\x0f\n\x07\x04\x0f\
    \x04\0\x02\x06\x02\x12\x04\x86\x04\x1f\x20\n\x0e\n\x06\x04\x0f\x04\0\x02\
    \x07\x12\x04\x87\x04\x04\"\n\x0f\n\x07\x04\x0f\x04\0\x02\x07\x01\x12\x04\
    \x87\x04\x04\x1d\n\x0f\n\x07\x04\x0f\x04\0\x02\x07\x02\x12\x04\x87\x04\
    \x20!\n\x0e\n\x06\x04\x0f\x04\0\x02\x08\x12\x04\x88\x04\x04\x1d\n\x0f\n\
    \x07\x04\x0f\x04\0\x02\x08\x01\x12\x04\x88\x04\x04\x18\n\x0f\n\x07\x04\
    \x0f\x04\0\x02\x08\x02\x12\x04\x88\x04\x1b\x1c\n\x0e\n\x06\x04\x0f\x04\0\
    \x02\t\x12\x04\x89\x04\x04\x19\n\x0f\n\x07\x04\x0f\x04\0\x02\t\x01\x12\
    \x04\x89\x04\x04\x14\n\x0f\n\x07\x04\x0f\x04\0\x02\t\x02\x12\x04\x89\x04\
    \x17\x18\n\x0e\n\x06\x04\x0f\x04\0\x02\n\x12\x04\x8a\x04\x04\x1e\n\x0f\n\
    \x07\x04\x0f\x04\0\x02\n\x01\x12\x04\x8a\x04\x04\x18\n\x0f\n\x07\x04\x0f\
    \x04\0\x02\n\x02\x12\x04\x8a\x04\x1b\x1d\n\x0e\n\x06\x04\x0f\x04\0\x02\
    \x0b\x12\x04\x8b\x04\x04!\n\x0f\n\x07\x04\x0f\x04\0\x02\x0b\x01\x12\x04\
    \x8b\x04\x04\x1b\n\x0f\n\x07\x04\x0f\x04\0\x02\x0b\x02\x12\x04\x8b\x04\
    \x1e\x20\n\x0e\n\x06\x04\x0f\x04\0\x02\x0c\x12\x04\x8c\x04\x04\x1e\n\x0f\
    \n\x07\x04\x0f\x04\0\x02\x0c\x01\x12\x04\x8c\x04\x04\x18\n\x0f\n\x07\x04\
    \x0f\x04\0\x02\x0c\x02\x12\x04\x8c\x04\x1b\x1d\n\x0e\n\x06\x04\x0f\x04\0\
    \x02\r\x12\x04\x8d\x04\x04%\n\x0f\n\x07\x04\x0f\x04\0\x02\r\x01\x12\x04\
    \x8d\x04\x04\x1f\n\x0f\n\x07\x04\x0f\x04\0\x02\r\x02\x12\x04\x8d\x04\"$\
    \n\x0e\n\x06\x04\x0f\x04\0\x02\x0e\x12\x04\x8e\x04\x04'\n\x0f\n\x07\x04\
    \x0f\x04\0\x02\x0e\x01\x12\x04\x8e\x04\x04!\n\x0f\n\x07\x04\x0f\x04\0\
    \x02\x0e\x02\x12\x04\x8e\x04$&\n\x0e\n\x06\x04\x0f\x04\0\x02\x0f\x12\x04\
    \x8f\x04\x04\x17\n\x0f\n\x07\x04\x0f\x04\0\x02\x0f\x01\x12\x04\x8f\x04\
    \x04\x11\n\x0f\n\x07\x04\x0f\x04\0\x02\x0f\x02\x12\x04\x8f\x04\x14\x16\n\
    \x0e\n\x06\x04\x0f\x04\0\x02\x10\x12\x04\x90\x04\x04!\n\x0f\n\x07\x04\
    \x0f\x04\0\x02\x10\x01\x12\x04\x90\x04\x04\x1b\n\x0f\n\x07\x04\x0f\x04\0\
    \x02\x10\x02\x12\x04\x90\x04\x1e\x20\n\x0e\n\x06\x04\x0f\x04\0\x02\x11\
    \x12\x04\x91\x04\x04\x17\n\x0f\n\x07\x04\x0f\x04\0\x02\x11\x01\x12\x04\
    \x91\x04\x04\x11\n\x0f\n\x07\x04\x0f\x04\0\x02\x11\x02\x12\x04\x91\x04\
    \x14\x16\n\x0e\n\x06\x04\x0f\x04\0\x02\x12\x12\x04\x92\x04\x04\x1e\n\x0f\
    \n\x07\x04\x0f\x04\0\x02\x12\x01\x12\x04\x92\x04\x04\x18\n\x0f\n\x07\x04\
    \x0f\x04\0\x02\x12\x02\x12\x04\x92\x04\x1b\x1d\n\x0e\n\x06\x04\x0f\x04\0\
    \x02\x13\x12\x04\x93\x04\x04\x1c\n\x0f\n\x07\x04\x0f\x04\0\x02\x13\x01\
    \x12\x04\x93\x04\x04\x16\n\x0f\n\x07\x04\x0f\x04\0\x02\x13\x02\x12\x04\
    \x93\x04\x19\x1b\n3\n\x06\x04\x0f\x04\0\x02\x14\x12\x04\x96\x04\x04\"\
    \x1a#\x20Added\x20in\x20Berlin\x20fork\x20(Geth\x201.10+)\n\n\x0f\n\x07\
    \x04\x0f\x04\0\x02\x14\x01\x12\x04\x96\x04\x04\x1c\n\x0f\n\x07\x04\x0f\
    \x04\0\x02\x14\x02\x12\x04\x96\x04\x1f!\n\x0c\n\x04\x04\x0f\x02\x03\x12\
    \x04\x99\x04\x02\x15\n\r\n\x05\x04\x0f\x02\x03\x05\x12\x04\x99\x04\x02\
    \x08\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\x99\x04\t\x10\n\r\n\x05\x04\
    \x0f\x02\x03\x03\x12\x04\x99\x04\x13\x14\n\xb2\x02\n\x02\x04\x10\x12\x06\
    \xa2\x04\0\xa4\x04\x01\x1a\xa3\x02\x20HeaderOnlyBlock\x20is\x20used\x20t\
    o\x20optimally\x20unpack\x20the\x20[Block]\x20structure\x20(note\x20the\
    \n\x20corresponding\x20message\x20number\x20for\x20the\x20`header`\x20fi\
    eld)\x20while\x20consuming\x20less\n\x20memory,\x20when\x20only\x20the\
    \x20`header`\x20is\x20desired.\n\n\x20WARN:\x20this\x20is\x20a\x20client\
    -side\x20optimization\x20pattern\x20and\x20should\x20be\x20moved\x20in\
    \x20the\n\x20consuming\x20code.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xa2\
    \x04\x08\x17\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xa3\x04\x02\x19\n\r\n\x05\
    \x04\x10\x02\0\x06\x12\x04\xa3\x04\x02\r\n\r\n\x05\x04\x10\x02\0\x01\x12\
    \x04\xa3\x04\x0e\x14\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xa3\x04\x17\x18\
    \n\xb4\x01\n\x02\x04\x11\x12\x06\xa9\x04\0\xae\x04\x01\x1a\xa5\x01\x20Bl\
    ockWithRefs\x20is\x20a\x20lightweight\x20block,\x20with\x20traces\x20and\
    \x20transactions\n\x20purged\x20from\x20the\x20`block`\x20within,\x20and\
    \x20only.\x20\x20It\x20is\x20used\x20in\x20transports\n\x20to\x20pass\
    \x20block\x20data\x20around.\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xa9\x04\
    \x08\x15\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xaa\x04\x02\x10\n\r\n\x05\x04\
    \x11\x02\0\x05\x12\x04\xaa\x04\x02\x08\n\r\n\x05\x04\x11\x02\0\x01\x12\
    \x04\xaa\x04\t\x0b\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xaa\x04\x0e\x0f\n\
    \x0c\n\x04\x04\x11\x02\x01\x12\x04\xab\x04\x02\x12\n\r\n\x05\x04\x11\x02\
    \x01\x06\x12\x04\xab\x04\x02\x07\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\
    \xab\x04\x08\r\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xab\x04\x10\x11\n\
    \x0c\n\x04\x04\x11\x02\x02\x12\x04\xac\x04\x02-\n\r\n\x05\x04\x11\x02\
    \x02\x06\x12\x04\xac\x04\x02\x11\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\
    \xac\x04\x12(\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xac\x04+,\n\x0c\n\
    \x04\x04\x11\x02\x03\x12\x04\xad\x04\x02\x18\n\r\n\x05\x04\x11\x02\x03\
    \x05\x12\x04\xad\x04\x02\x06\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\xad\
    \x04\x07\x13\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\xad\x04\x16\x17\n\x0c\
    \n\x02\x04\x12\x12\x06\xb0\x04\0\xb3\x04\x01\n\x0b\n\x03\x04\x12\x01\x12\
    \x04\xb0\x04\x08$\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xb1\x04\x02\x1d\n\r\
    \n\x05\x04\x12\x02\0\x06\x12\x04\xb1\x04\x02\x12\n\r\n\x05\x04\x12\x02\0\
    \x01\x12\x04\xb1\x04\x13\x18\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xb1\x04\
    \x1b\x1c\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\xb2\x04\x02\x19\n\r\n\x05\
    \x04\x12\x02\x01\x06\x12\x04\xb2\x04\x02\n\n\r\n\x05\x04\x12\x02\x01\x01\
    \x12\x04\xb2\x04\x0b\x14\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xb2\x04\
    \x17\x18\n\x0c\n\x02\x04\x13\x12\x06\xb5\x04\0\xb7\x04\x01\n\x0b\n\x03\
    \x04\x13\x01\x12\x04\xb5\x04\x08\x17\n\x0c\n\x04\x04\x13\x02\0\x12\x04\
    \xb6\x04\x02\x1c\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xb6\x04\x02\n\n\r\n\
    \x05\x04\x13\x02\0\x05\x12\x04\xb6\x04\x0b\x10\n\r\n\x05\x04\x13\x02\0\
    \x01\x12\x04\xb6\x04\x11\x17\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xb6\x04\
    \x1a\x1b\n\x0c\n\x02\x04\x14\x12\x06\xb9\x04\0\xbc\x04\x01\n\x0b\n\x03\
    \x04\x14\x01\x12\x04\xb9\x04\x08\x10\n\x0c\n\x04\x04\x14\x02\0\x12\x04\
    \xba\x04\x02\x11\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xba\x04\x02\x07\n\r\
    \n\x05\x04\x14\x02\0\x01\x12\x04\xba\x04\x08\x0c\n\r\n\x05\x04\x14\x02\0\
    \x03\x12\x04\xba\x04\x0f\x10\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xbb\x04\
    \x02\x14\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xbb\x04\x02\x08\n\r\n\x05\
    \x04\x14\x02\x01\x01\x12\x04\xbb\x04\t\x0f\n\r\n\x05\x04\x14\x02\x01\x03\
    \x12\x04\xbb\x04\x12\x13b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(21);
            messages.push(Block::generated_message_descriptor_data());
            messages.push(BlockHeader::generated_message_descriptor_data());
            messages.push(Uint64NestedArray::generated_message_descriptor_data());
            messages.push(Uint64Array::generated_message_descriptor_data());
            messages.push(BigInt::generated_message_descriptor_data());
            messages.push(TransactionTrace::generated_message_descriptor_data());
            messages.push(AccessTuple::generated_message_descriptor_data());
            messages.push(TransactionReceipt::generated_message_descriptor_data());
            messages.push(Log::generated_message_descriptor_data());
            messages.push(Call::generated_message_descriptor_data());
            messages.push(StorageChange::generated_message_descriptor_data());
            messages.push(BalanceChange::generated_message_descriptor_data());
            messages.push(NonceChange::generated_message_descriptor_data());
            messages.push(AccountCreation::generated_message_descriptor_data());
            messages.push(CodeChange::generated_message_descriptor_data());
            messages.push(GasChange::generated_message_descriptor_data());
            messages.push(HeaderOnlyBlock::generated_message_descriptor_data());
            messages.push(BlockWithRefs::generated_message_descriptor_data());
            messages.push(TransactionTraceWithBlockRef::generated_message_descriptor_data());
            messages.push(TransactionRefs::generated_message_descriptor_data());
            messages.push(BlockRef::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(TransactionTraceStatus::generated_enum_descriptor_data());
            enums.push(CallType::generated_enum_descriptor_data());
            enums.push(transaction_trace::Type::generated_enum_descriptor_data());
            enums.push(balance_change::Reason::generated_enum_descriptor_data());
            enums.push(gas_change::Reason::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}